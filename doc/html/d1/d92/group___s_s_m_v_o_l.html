<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Shore Storage Manager: Devices and Volumes</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
<link href="../../tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="../../main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="../../modules.html"><span>Modules</span></a></li>
    <li><a href="../../namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="../../classes.html"><span>Classes</span></a></li>
    <li><a href="../../files.html"><span>Files</span></a></li>
    <li><a href="../../dirs.html"><span>Directories</span></a></li>
    <li><a href="../../pages.html"><span>Related&nbsp;Pages</span></a></li>
    <li><a href="../../examples.html"><span>Examples</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
  </ul></div>
<h1>Devices and Volumes<br>
<small>
[<a class="el" href="../../dd/d39/group___s_s_m_s_t_g.html">Storage Structures</a>]</small>
</h1>
<p>
Collaboration diagram for Devices and Volumes:<center><table><tr><td><img src="../../d1/d92/group___s_s_m_v_o_l.png" border="0" alt="" usemap="#d6/db4/d1_2d92_2group______s__s__m__v__o__l_map">
<map name="d6/db4/d1_2d92_2group______s__s__m__v__o__l_map">
<area href="../../dd/d39/group___s_s_m_s_t_g.html" shape="rect" coords="6,5,146,32" alt="">
</map></td></tr></table></center>
<hr><a name="_details"></a><h2>Detailed Description</h2>
The storage manager was designed to permit multiple <em>volumes</em> on a <em>device</em>, with <em>volume</em> analogous to a Unix <em>parition</em> and a <em>device</em> analogous to a disk, and the original SHORE contained symmetric peer servers. However good that intention, multiple volumes on a device were never implemented, and times have changed, and the storage manager no longer has any notion of remote and local volumes. The notion a volume, separate from a device, remains, but may some day disappear.<p>
For the time being, a device contains at most one volume.<p>
A device is either an operating system file or an operating system device (e.g., raw disk partition) and is identified by a path name (absolute or relative).<p>
A device has a quota. A device is intended to have multiple volumes on it, but in the current implementation the maximum number of volumes is exactly 1.<p>
A volume is where data are stored. Each volume is a header and a set of pages. All pages are the same size (this is a compile-time constant, the default being 8K and sizes up to 64K permissible).<p>
A volume is identified uniquely and persistently by a long volume ID (<a class="el" href="../../d8/d94/structlvid__t.html">lvid_t</a>), which is stored in its header. Volumes can be used whenever the device they are located on is mounted by the SM. Volumes have a quota. The sum of the quotas of all the volumes on a device cannot exceed the device quota.<p>
A volume contains a variety of data structures. All user data reside in <em>stores</em>. A store is a collection of the pages on the volume, allocated in <em>extents</em> of a size that is a compile-time constant. (The storage manager has only been tested with an extent-size of 8 pages. The compile-time constant can be changed, but it also requires changes elsewhere in the code to maintain alignment of persistent structures. See the comments in config/shore.def.) Thus, the minimum size of a store is one extent's worth of pages. Larger extents provide better clustering, but more wasted space if small files and small indexes will be common.<p>
Stores are identified by a store number (snum_t).<p>
Each volume contains a few stores that are "overhead": 0 -- is reserved for an extent map and a store map 1 -- directory (dir_m) 2 -- root index<p>
Beyond that, for each (user) file created, 2 stores are used, one for small objects, one for large objects, and for each index (btree, rtree) created 1 store is used.<p>
Each volume is laid out thus:<ul>
<li>volume header, which identifies the number of extents on the volume, determined when the volume is formatted. This is always in page 1 of the volume.</li><li>store map: some number of pages describing the stores on the volume, namely, being the heads of linked-lists of extents that make up the stores. The number of such pages is determined when the volume is formatted. The worst case is assumed, which is one might fill the volume with one-extent stores.</li><li>extent map: some number of pages of bitmaps, one bitmap for each extent, describe which pages in the extents are allocated or free.</li><li>data pages: the rest of the volume. </li></ul>

<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="../../db/dc7/classw__rc__t.html">rc_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d92/group___s_s_m_v_o_l.html#gb0bda000aa63b5dbbafab3a4289f8396">ss_m::set_disk_delay</a> (u_int milli_sec)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set sleep time before I/O operations.  <a href="#gb0bda000aa63b5dbbafab3a4289f8396"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="../../db/dc7/classw__rc__t.html">rc_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d92/group___s_s_m_v_o_l.html#g0ad23033dcc850c62191e199b1ce9c71">ss_m::format_dev</a> (const char *device, smksize_t quota_in_KB, bool force)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Format a device.  <a href="#g0ad23033dcc850c62191e199b1ce9c71"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="../../db/dc7/classw__rc__t.html">rc_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d92/group___s_s_m_v_o_l.html#g7d4ada660b41abd232dbc16749799348">ss_m::mount_dev</a> (const char *device, u_int &amp;vol_cnt, <a class="el" href="../../d1/d0c/structdevid__t.html">devid_t</a> &amp;devid, <a class="el" href="../../d3/d3f/structvid__t.html">vid_t</a> local_vid=<a class="el" href="../../d3/d3f/structvid__t.html#3d605b56dec1a5e6fa3cb0201f8a28fd">vid_t::null</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Mount a device.  <a href="#g7d4ada660b41abd232dbc16749799348"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="../../db/dc7/classw__rc__t.html">rc_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d92/group___s_s_m_v_o_l.html#g096f7782e312f404ffbc0640e0ee3921">ss_m::dismount_dev</a> (const char *device)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dismount a device.  <a href="#g096f7782e312f404ffbc0640e0ee3921"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="../../db/dc7/classw__rc__t.html">rc_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d92/group___s_s_m_v_o_l.html#g99057cd5ae7842f51649c0dfd5155878">ss_m::dismount_all</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dismount all mounted devices.  <a href="#g99057cd5ae7842f51649c0dfd5155878"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="../../db/dc7/classw__rc__t.html">rc_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d92/group___s_s_m_v_o_l.html#g567c81260c9251d122145de047646079">ss_m::list_devices</a> (const char **&amp;dev_list, <a class="el" href="../../d1/d0c/structdevid__t.html">devid_t</a> *&amp;devid_list, u_int &amp;dev_cnt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a list of all mounted devices.  <a href="#g567c81260c9251d122145de047646079"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="../../db/dc7/classw__rc__t.html">rc_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d92/group___s_s_m_v_o_l.html#gc060c984b9a423f3106640dd316e6ea5">ss_m::list_volumes</a> (const char *device, <a class="el" href="../../d8/d94/structlvid__t.html">lvid_t</a> *&amp;lvid_list, u_int &amp;lvid_cnt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a list of all volume on a device.  <a href="#gc060c984b9a423f3106640dd316e6ea5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="../../db/dc7/classw__rc__t.html">rc_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d92/group___s_s_m_v_o_l.html#gaf46484d848b32c603afb327e865d430">ss_m::get_device_quota</a> (const char *device, smksize_t &amp;quota_KB, smksize_t &amp;quota_used_KB)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the device quota.  <a href="#gaf46484d848b32c603afb327e865d430"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="../../db/dc7/classw__rc__t.html">rc_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d92/group___s_s_m_v_o_l.html#g91d92425e9b418d16b82965280c4653a">ss_m::set_fake_disk_latency</a> (<a class="el" href="../../d3/d3f/structvid__t.html">vid_t</a> vid, const int adelay)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change the fake disk latency before I/Os on this volume, for debugging purposes.  <a href="#g91d92425e9b418d16b82965280c4653a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="../../db/dc7/classw__rc__t.html">rc_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d92/group___s_s_m_v_o_l.html#ge01f240196a7b99b573dd876863f6143">ss_m::enable_fake_disk_latency</a> (<a class="el" href="../../d3/d3f/structvid__t.html">vid_t</a> vid)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enable the fake disk latency before I/Os on this volume, for debugging purposes.  <a href="#ge01f240196a7b99b573dd876863f6143"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="../../db/dc7/classw__rc__t.html">rc_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d92/group___s_s_m_v_o_l.html#g03b27b3f635dd5524819d9dd81355499">ss_m::disable_fake_disk_latency</a> (<a class="el" href="../../d3/d3f/structvid__t.html">vid_t</a> vid)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Disable the fake disk latency before I/Os on this volume, for debugging purposes.  <a href="#g03b27b3f635dd5524819d9dd81355499"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="../../db/dc7/classw__rc__t.html">rc_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d92/group___s_s_m_v_o_l.html#gcb2dde937240003bf5341df4b3556932">ss_m::generate_new_lvid</a> (<a class="el" href="../../d8/d94/structlvid__t.html">lvid_t</a> &amp;lvid, const char *hostname=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a volume to a device.  <a href="#gcb2dde937240003bf5341df4b3556932"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="../../db/dc7/classw__rc__t.html">rc_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d92/group___s_s_m_v_o_l.html#ga929561cfc19fdc1b50e9ce46d0cff70">ss_m::create_vol</a> (const char *device_name, const <a class="el" href="../../d8/d94/structlvid__t.html">lvid_t</a> &amp;lvid, smksize_t quota_KB, bool skip_raw_init=false, <a class="el" href="../../d3/d3f/structvid__t.html">vid_t</a> local_vid=<a class="el" href="../../d3/d3f/structvid__t.html#3d605b56dec1a5e6fa3cb0201f8a28fd">vid_t::null</a>, const bool apply_fake_io_latency=false, const int fake_disk_latency=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a volume to a device.  <a href="#ga929561cfc19fdc1b50e9ce46d0cff70"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="../../db/dc7/classw__rc__t.html">rc_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d92/group___s_s_m_v_o_l.html#gbee51ea551de351f36eaef35a9eeeab3">ss_m::destroy_vol</a> (const <a class="el" href="../../d8/d94/structlvid__t.html">lvid_t</a> &amp;lvid)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroy a volume.  <a href="#gbee51ea551de351f36eaef35a9eeeab3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="../../db/dc7/classw__rc__t.html">rc_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d92/group___s_s_m_v_o_l.html#g66e014c5ce487f12e9ecd7bc030960d5">ss_m::get_volume_quota</a> (const <a class="el" href="../../d8/d94/structlvid__t.html">lvid_t</a> &amp;lvid, smksize_t &amp;quota_KB, smksize_t &amp;quota_used_KB)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the quotas associated with the volume.  <a href="#g66e014c5ce487f12e9ecd7bc030960d5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="../../db/dc7/classw__rc__t.html">rc_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d92/group___s_s_m_v_o_l.html#gc2fa23322a74cbae9e1cf1e72b1734d5">ss_m::get_du_statistics</a> (<a class="el" href="../../d3/d3f/structvid__t.html">vid_t</a> vid, sm_du_stats_t &amp;du, bool audit=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Analyze a volume and report statistics regarding disk usage.  <a href="#gc2fa23322a74cbae9e1cf1e72b1734d5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="../../db/dc7/classw__rc__t.html">rc_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d92/group___s_s_m_v_o_l.html#g4bf28c5e7b1ffa6471f0e55448c063e5">ss_m::get_du_statistics</a> (const <a class="el" href="../../da/d5b/structstid__t.html">stid_t</a> &amp;stid, sm_du_stats_t &amp;du, bool audit=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Analyze a store and report statistics regarding disk usage.  <a href="#g4bf28c5e7b1ffa6471f0e55448c063e5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="../../db/dc7/classw__rc__t.html">rc_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d92/group___s_s_m_v_o_l.html#g76a1ad8c02285b95d7677483d1783e1e">ss_m::dump_vol_store_info</a> (const <a class="el" href="../../d3/d3f/structvid__t.html">vid_t</a> &amp;vid)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dump disk information about the indicated volume.  <a href="#g76a1ad8c02285b95d7677483d1783e1e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="../../db/dc7/classw__rc__t.html">rc_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d92/group___s_s_m_v_o_l.html#gf8eb87487de0644945f509ccdbff320b">ss_m::get_volume_meta_stats</a> (<a class="el" href="../../d3/d3f/structvid__t.html">vid_t</a> vid, SmVolumeMetaStats &amp;volume_stats, <a class="el" href="../../de/d81/sm__base_8h.html#8a4ace36542f82f7a5e908a7df721a57">concurrency_t</a> cc=t_cc_none)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Analyze a volume and collect brief statistics about its usage.  <a href="#gf8eb87487de0644945f509ccdbff320b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="../../db/dc7/classw__rc__t.html">rc_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d92/group___s_s_m_v_o_l.html#gbdbd758de7fd4f8246b25d36c07780d5">ss_m::get_file_meta_stats</a> (<a class="el" href="../../d3/d3f/structvid__t.html">vid_t</a> vid, <a class="el" href="../../d9/da0/classw__base__t.html#7d1c7ae407200662fd16b64de4dcde46">w_base_t::uint4_t</a> num_files, SmFileMetaStats *file_stats, bool batch_calculate=false, <a class="el" href="../../de/d81/sm__base_8h.html#8a4ace36542f82f7a5e908a7df721a57">concurrency_t</a> cc=t_cc_none)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Analyze a volume and collect brief statistics about its usage.  <a href="#gbdbd758de7fd4f8246b25d36c07780d5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="../../db/dc7/classw__rc__t.html">rc_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d92/group___s_s_m_v_o_l.html#gac7948d4e08ac1c5c713dd5307919d35">ss_m::vol_root_index</a> (const <a class="el" href="../../d3/d3f/structvid__t.html">vid_t</a> &amp;v, <a class="el" href="../../da/d5b/structstid__t.html">stid_t</a> &amp;iid)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the index ID of the root index of the volume.  <a href="#gac7948d4e08ac1c5c713dd5307919d35"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="../../db/dc7/classw__rc__t.html">rc_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d92/group___s_s_m_v_o_l.html#ged476303a8f697b978bba37897ef866d">ss_m::lvid_to_vid</a> (const <a class="el" href="../../d8/d94/structlvid__t.html">lvid_t</a> &amp;lvid, <a class="el" href="../../d3/d3f/structvid__t.html">vid_t</a> &amp;vid)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the short volume ID of a volume.  <a href="#ged476303a8f697b978bba37897ef866d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="../../db/dc7/classw__rc__t.html">rc_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d92/group___s_s_m_v_o_l.html#g79d6a03fe68956196506f964a2e5894e">ss_m::vid_to_lvid</a> (<a class="el" href="../../d3/d3f/structvid__t.html">vid_t</a> vid, <a class="el" href="../../d8/d94/structlvid__t.html">lvid_t</a> &amp;lvid)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the long volume ID of a volume.  <a href="#g79d6a03fe68956196506f964a2e5894e"></a><br></td></tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="gb0bda000aa63b5dbbafab3a4289f8396"></a><!-- doxytag: member="ss_m::set_disk_delay" ref="gb0bda000aa63b5dbbafab3a4289f8396" args="(u_int milli_sec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../db/dc7/classw__rc__t.html">rc_t</a> ss_m::set_disk_delay           </td>
          <td>(</td>
          <td class="paramtype">u_int&nbsp;</td>
          <td class="paramname"> <em>milli_sec</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set sleep time before I/O operations. 
<p>
This method sets a milli_sec delay to occur before each disk read/write operation. This is for debugging. It is useful in discovering thread sync bugs. This delay applies to all threads. 
</div>
</div><p>
<a class="anchor" name="g0ad23033dcc850c62191e199b1ce9c71"></a><!-- doxytag: member="ss_m::format_dev" ref="g0ad23033dcc850c62191e199b1ce9c71" args="(const char *device, smksize_t quota_in_KB, bool force)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../db/dc7/classw__rc__t.html">rc_t</a> ss_m::format_dev           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">smksize_t&nbsp;</td>
          <td class="paramname"> <em>quota_in_KB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>force</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Format a device. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>device</em>&nbsp;</td><td>Operating-system file name of the "device". </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>quota_in_KB</em>&nbsp;</td><td>Quota in kilobytes. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>force</em>&nbsp;</td><td>If true, format the device even if it already exists.</td></tr>
  </table>
</dl>
Since raw devices always "exist", <em>force</em> should be given as true for raw devices.<p>
A device may not be formatted if it is already mounted.<p>
<dl compact><dt><b>Note:</b></dt><dd>This method should <b>not</b> be called in the context of a transaction. </dd></dl>
<dl compact><dt><b>Examples: </b></dt><dd>
<a class="el" href="../../df/d97/create__rec_8cpp-example.html#a41">create_rec.cpp</a>.</dl>
</div>
</div><p>
<a class="anchor" name="g7d4ada660b41abd232dbc16749799348"></a><!-- doxytag: member="ss_m::mount_dev" ref="g7d4ada660b41abd232dbc16749799348" args="(const char *device, u_int &amp;vol_cnt, devid_t &amp;devid, vid_t local_vid=vid_t::null)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../db/dc7/classw__rc__t.html">rc_t</a> ss_m::mount_dev           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int &amp;&nbsp;</td>
          <td class="paramname"> <em>vol_cnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d1/d0c/structdevid__t.html">devid_t</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>devid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d3/d3f/structvid__t.html">vid_t</a>&nbsp;</td>
          <td class="paramname"> <em>local_vid</em> = <code><a class="el" href="../../d3/d3f/structvid__t.html#3d605b56dec1a5e6fa3cb0201f8a28fd">vid_t::null</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Mount a device. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>device</em>&nbsp;</td><td>Operating-system file name of the "device". </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>vol_cnt</em>&nbsp;</td><td>Number of volumes on the device. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>devid</em>&nbsp;</td><td>A local device id assigned by the storage manager. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>local_vid</em>&nbsp;</td><td>A local handle to the (only) volume on the device, to be used when a volume is mounted. The default, <a class="el" href="../../d3/d3f/structvid__t.html#3d605b56dec1a5e6fa3cb0201f8a28fd">vid_t::null</a>, indicates that the storage manager can chose a value for this.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>It is fine to mount a device more than once, as long as device is always the same (you cannot specify a hard link or soft link to an entity mounted under a different path). Device mounts are <b>not</b> reference-counted, so a single dismount_dev renders the volumes on the device unusable.<p>
This method should <b>not</b> be called in the context of a transaction. </dd></dl>
<dl compact><dt><b>Examples: </b></dt><dd>
<a class="el" href="../../df/d97/create__rec_8cpp-example.html#a42">create_rec.cpp</a>.</dl>
</div>
</div><p>
<a class="anchor" name="g096f7782e312f404ffbc0640e0ee3921"></a><!-- doxytag: member="ss_m::dismount_dev" ref="g096f7782e312f404ffbc0640e0ee3921" args="(const char *device)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../db/dc7/classw__rc__t.html">rc_t</a> ss_m::dismount_dev           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>device</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Dismount a device. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>device</em>&nbsp;</td><td>Operating-system file name of the "device".</td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>It is fine to mount a device more than once, as long as device is always the same (you cannot specify a hard link or soft link to an entity mounted under a different path). Device mounts are <b>not</b> reference-counted, so a single dismount_dev renders the volumes on the device unusable.<p>
This method should <b>not</b> be called in the context of a transaction. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g99057cd5ae7842f51649c0dfd5155878"></a><!-- doxytag: member="ss_m::dismount_all" ref="g99057cd5ae7842f51649c0dfd5155878" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../db/dc7/classw__rc__t.html">rc_t</a> ss_m::dismount_all           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Dismount all mounted devices. 
<p>
<dl compact><dt><b>Note:</b></dt><dd>This method should <b>not</b> be called in the context of a transaction. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g567c81260c9251d122145de047646079"></a><!-- doxytag: member="ss_m::list_devices" ref="g567c81260c9251d122145de047646079" args="(const char **&amp;dev_list, devid_t *&amp;devid_list, u_int &amp;dev_cnt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../db/dc7/classw__rc__t.html">rc_t</a> ss_m::list_devices           </td>
          <td>(</td>
          <td class="paramtype">const char **&amp;&nbsp;</td>
          <td class="paramname"> <em>dev_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d1/d0c/structdevid__t.html">devid_t</a> *&amp;&nbsp;</td>
          <td class="paramname"> <em>devid_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int &amp;&nbsp;</td>
          <td class="paramname"> <em>dev_cnt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return a list of all mounted devices. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>dev_list</em>&nbsp;</td><td>Returned list of pointers directly into the mount table. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>devid_list</em>&nbsp;</td><td>Returned list of associated device ids. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>dev_cnt</em>&nbsp;</td><td>Returned number of entries in the two above lists.</td></tr>
  </table>
</dl>
The storage manager allocates the arrays returned with new[], and the caller must return these to the heap with delete[] if they are not null. They will be null if an error is returned or if no devices are mounted.<p>
The strings to which dev_list[*] point are <b>not</b> to be deleted by the caller. 
</div>
</div><p>
<a class="anchor" name="gc060c984b9a423f3106640dd316e6ea5"></a><!-- doxytag: member="ss_m::list_volumes" ref="gc060c984b9a423f3106640dd316e6ea5" args="(const char *device, lvid_t *&amp;lvid_list, u_int &amp;lvid_cnt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../db/dc7/classw__rc__t.html">rc_t</a> ss_m::list_volumes           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d8/d94/structlvid__t.html">lvid_t</a> *&amp;&nbsp;</td>
          <td class="paramname"> <em>lvid_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int &amp;&nbsp;</td>
          <td class="paramname"> <em>lvid_cnt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return a list of all volume on a device. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>device</em>&nbsp;</td><td>Operating-system file name of the "device". </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>lvid_list</em>&nbsp;</td><td>Returned list of pointers directly into the mount table. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>lvid_cnt</em>&nbsp;</td><td>Returned length of list lvid_list.</td></tr>
  </table>
</dl>
The storage manager allocates the array lvid_list with new[], and the caller must return it to the heap with delete[] if it is not null. It will be null if an error is returned.<p>
<dl compact><dt><b>Note:</b></dt><dd>This method should <b>not</b> be called in the context of a transaction. </dd></dl>
<dl compact><dt><b>Examples: </b></dt><dd>
<a class="el" href="../../df/d97/create__rec_8cpp-example.html#a45">create_rec.cpp</a>.</dl>
</div>
</div><p>
<a class="anchor" name="gaf46484d848b32c603afb327e865d430"></a><!-- doxytag: member="ss_m::get_device_quota" ref="gaf46484d848b32c603afb327e865d430" args="(const char *device, smksize_t &amp;quota_KB, smksize_t &amp;quota_used_KB)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../db/dc7/classw__rc__t.html">rc_t</a> ss_m::get_device_quota           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">smksize_t &amp;&nbsp;</td>
          <td class="paramname"> <em>quota_KB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">smksize_t &amp;&nbsp;</td>
          <td class="paramname"> <em>quota_used_KB</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the device quota. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>device</em>&nbsp;</td><td>Operating-system file name of the "device". </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>quota_KB</em>&nbsp;</td><td>Returned quota in kilobytes </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>quota_used_KB</em>&nbsp;</td><td>Returned portion of quota allocated to volumes</td></tr>
  </table>
</dl>
The quota_used_KB is the portion of the quota allocated to volumes on the device.<p>
<dl compact><dt><b>Note:</b></dt><dd>This method <b>may</b> be called in the context of a transaction.<p>
This method <b>may</b> be called in the context of a transaction. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g91d92425e9b418d16b82965280c4653a"></a><!-- doxytag: member="ss_m::set_fake_disk_latency" ref="g91d92425e9b418d16b82965280c4653a" args="(vid_t vid, const int adelay)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../db/dc7/classw__rc__t.html">rc_t</a> ss_m::set_fake_disk_latency           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/d3f/structvid__t.html">vid_t</a>&nbsp;</td>
          <td class="paramname"> <em>vid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>adelay</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Change the fake disk latency before I/Os on this volume, for debugging purposes. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>vid</em>&nbsp;</td><td>The ID of the volume of interest. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>adelay</em>&nbsp;</td><td>Nanoseconds to sleep with nanosleep()</td></tr>
  </table>
</dl>
This is for debugging only. Changing the value of the latency for a volume does not enable the delay. 
</div>
</div><p>
<a class="anchor" name="ge01f240196a7b99b573dd876863f6143"></a><!-- doxytag: member="ss_m::enable_fake_disk_latency" ref="ge01f240196a7b99b573dd876863f6143" args="(vid_t vid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../db/dc7/classw__rc__t.html">rc_t</a> ss_m::enable_fake_disk_latency           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/d3f/structvid__t.html">vid_t</a>&nbsp;</td>
          <td class="paramname"> <em>vid</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enable the fake disk latency before I/Os on this volume, for debugging purposes. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>vid</em>&nbsp;</td><td>The ID of the volume of interest.</td></tr>
  </table>
</dl>
This is for debugging only. When this is enabled, is uses whatever disk latency was set with <a class="el" href="../../d1/d92/group___s_s_m_v_o_l.html#ga929561cfc19fdc1b50e9ce46d0cff70">ss_m::create_vol()</a> or the last applied <a class="el" href="../../d1/d92/group___s_s_m_v_o_l.html#g91d92425e9b418d16b82965280c4653a">ss_m::set_fake_disk_latency()</a>. 
</div>
</div><p>
<a class="anchor" name="g03b27b3f635dd5524819d9dd81355499"></a><!-- doxytag: member="ss_m::disable_fake_disk_latency" ref="g03b27b3f635dd5524819d9dd81355499" args="(vid_t vid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../db/dc7/classw__rc__t.html">rc_t</a> ss_m::disable_fake_disk_latency           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/d3f/structvid__t.html">vid_t</a>&nbsp;</td>
          <td class="paramname"> <em>vid</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Disable the fake disk latency before I/Os on this volume, for debugging purposes. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>vid</em>&nbsp;</td><td>The ID of the volume of interest.</td></tr>
  </table>
</dl>
This is for debugging only. 
</div>
</div><p>
<a class="anchor" name="gcb2dde937240003bf5341df4b3556932"></a><!-- doxytag: member="ss_m::generate_new_lvid" ref="gcb2dde937240003bf5341df4b3556932" args="(lvid_t &amp;lvid, const char *hostname=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../db/dc7/classw__rc__t.html">rc_t</a> ss_m::generate_new_lvid           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d8/d94/structlvid__t.html">lvid_t</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>lvid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>hostname</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add a volume to a device. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>lvid</em>&nbsp;</td><td>Long volume id to be used on <a class="el" href="../../d1/d92/group___s_s_m_v_o_l.html#ga929561cfc19fdc1b50e9ce46d0cff70">ss_m::create_vol()</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>hostname</em>&nbsp;</td><td>Name to use for local host. Default is one of: host name derived from gethostbyname/uname or "localhost.localdomain", depending on whether the requisite functions exist on the local machine. Using a non-null argument obviates the use of any other mechanism to derive a host name. The host name is used to get a host address, which is part of the unique identifier.</td></tr>
  </table>
</dl>
This generates a unique volume identifier to be written persistently on the volume when it is formatted. This enables us to avoid the mistake of doubly-mounting a volume. The identifer is constructed from the machine network address and the time of day. <dl compact><dt><b>Examples: </b></dt><dd>
<a class="el" href="../../df/d97/create__rec_8cpp-example.html#a43">create_rec.cpp</a>.</dl>
</div>
</div><p>
<a class="anchor" name="ga929561cfc19fdc1b50e9ce46d0cff70"></a><!-- doxytag: member="ss_m::create_vol" ref="ga929561cfc19fdc1b50e9ce46d0cff70" args="(const char *device_name, const lvid_t &amp;lvid, smksize_t quota_KB, bool skip_raw_init=false, vid_t local_vid=vid_t::null, const bool apply_fake_io_latency=false, const int fake_disk_latency=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../db/dc7/classw__rc__t.html">rc_t</a> ss_m::create_vol           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>device_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d8/d94/structlvid__t.html">lvid_t</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>lvid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">smksize_t&nbsp;</td>
          <td class="paramname"> <em>quota_KB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>skip_raw_init</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d3/d3f/structvid__t.html">vid_t</a>&nbsp;</td>
          <td class="paramname"> <em>local_vid</em> = <code><a class="el" href="../../d3/d3f/structvid__t.html#3d605b56dec1a5e6fa3cb0201f8a28fd">vid_t::null</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>apply_fake_io_latency</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>fake_disk_latency</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add a volume to a device. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>device_name</em>&nbsp;</td><td>Operating-system file name of the "device". </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>lvid</em>&nbsp;</td><td>Long volume id to use when formatting the new volume. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>quota_KB</em>&nbsp;</td><td>Quota in kilobytes. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>skip_raw_init</em>&nbsp;</td><td>Do not initialize the volume if on a raw device. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>local_vid</em>&nbsp;</td><td>Short volume id by which to refer to this volume. If null, the storage manager will assign one. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>apply_fake_io_latency</em>&nbsp;</td><td>See <a class="el" href="../../d1/d92/group___s_s_m_v_o_l.html#ge01f240196a7b99b573dd876863f6143">ss_m::enable_fake_disk_latency()</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>fake_disk_latency</em>&nbsp;</td><td>See <a class="el" href="../../d1/d92/group___s_s_m_v_o_l.html#g91d92425e9b418d16b82965280c4653a">ss_m::set_fake_disk_latency()</a></td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>This method should <b>not</b> be called in the context of a transaction.</dd></dl>
The pages on the volume <b>must</b> be zeroed; you can only use <em>skip_raw_init</em> = true if you have by some other means already initialized the volume. <dl compact><dt><b>Examples: </b></dt><dd>
<a class="el" href="../../df/d97/create__rec_8cpp-example.html#a44">create_rec.cpp</a>.</dl>
</div>
</div><p>
<a class="anchor" name="gbee51ea551de351f36eaef35a9eeeab3"></a><!-- doxytag: member="ss_m::destroy_vol" ref="gbee51ea551de351f36eaef35a9eeeab3" args="(const lvid_t &amp;lvid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../db/dc7/classw__rc__t.html">rc_t</a> ss_m::destroy_vol           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d8/d94/structlvid__t.html">lvid_t</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>lvid</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destroy a volume. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>lvid</em>&nbsp;</td><td>Long volume id by which the volume is known.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>This method should <b>not</b> be called in the context of a transaction. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g66e014c5ce487f12e9ecd7bc030960d5"></a><!-- doxytag: member="ss_m::get_volume_quota" ref="g66e014c5ce487f12e9ecd7bc030960d5" args="(const lvid_t &amp;lvid, smksize_t &amp;quota_KB, smksize_t &amp;quota_used_KB)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../db/dc7/classw__rc__t.html">rc_t</a> ss_m::get_volume_quota           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d8/d94/structlvid__t.html">lvid_t</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>lvid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">smksize_t &amp;&nbsp;</td>
          <td class="paramname"> <em>quota_KB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">smksize_t &amp;&nbsp;</td>
          <td class="paramname"> <em>quota_used_KB</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the quotas associated with the volume. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>lvid</em>&nbsp;</td><td>Long volume id by which the volume is known. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>quota_KB</em>&nbsp;</td><td>Quota given when the volume was created. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>quota_used_KB</em>&nbsp;</td><td>Portion of the quota has been used by allocated extents. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="gc2fa23322a74cbae9e1cf1e72b1734d5"></a><!-- doxytag: member="ss_m::get_du_statistics" ref="gc2fa23322a74cbae9e1cf1e72b1734d5" args="(vid_t vid, sm_du_stats_t &amp;du, bool audit=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../db/dc7/classw__rc__t.html">rc_t</a> ss_m::get_du_statistics           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/d3f/structvid__t.html">vid_t</a>&nbsp;</td>
          <td class="paramname"> <em>vid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sm_du_stats_t &amp;&nbsp;</td>
          <td class="paramname"> <em>du</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>audit</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Analyze a volume and report statistics regarding disk usage. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>vid</em>&nbsp;</td><td>The volume of interest. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>du</em>&nbsp;</td><td>The structure that will hold the collected statistics. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>audit</em>&nbsp;</td><td>If "true", the method acquires a share lock on the volume and then will check assertions about the correctness of the data structures on the volume. If the audit fails an internal fatal error is generated to facilitate debugging. (It will generate a core file if your shell permits such.) If "false" an IS lock is acquired, which means that the statistics will be fuzzy.</td></tr>
  </table>
</dl>
Using the audit feature is useful for debugging. It is the only safe way to use this method. <dl compact><dt><b>Note:</b></dt><dd>The statistics are added to the sm_du_stats_t structure passed in. This structure is not cleared by the storage manager. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g4bf28c5e7b1ffa6471f0e55448c063e5"></a><!-- doxytag: member="ss_m::get_du_statistics" ref="g4bf28c5e7b1ffa6471f0e55448c063e5" args="(const stid_t &amp;stid, sm_du_stats_t &amp;du, bool audit=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../db/dc7/classw__rc__t.html">rc_t</a> ss_m::get_du_statistics           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/d5b/structstid__t.html">stid_t</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>stid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sm_du_stats_t &amp;&nbsp;</td>
          <td class="paramname"> <em>du</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>audit</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Analyze a store and report statistics regarding disk usage. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>stid</em>&nbsp;</td><td>The store of interest. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>du</em>&nbsp;</td><td>The structure that will hold the collected statistics. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>audit</em>&nbsp;</td><td>If "true", the method acquires a share lock on the store and then will check assertions about the correctness of the data structures on the store.</td></tr>
  </table>
</dl>
Using the audit feature is useful for debugging. It is the only safe way to use this method. 
</div>
</div><p>
<a class="anchor" name="g76a1ad8c02285b95d7677483d1783e1e"></a><!-- doxytag: member="ss_m::dump_vol_store_info" ref="g76a1ad8c02285b95d7677483d1783e1e" args="(const vid_t &amp;vid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../db/dc7/classw__rc__t.html">rc_t</a> ss_m::dump_vol_store_info           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d3/d3f/structvid__t.html">vid_t</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>vid</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Dump disk information about the indicated volume. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>vid</em>&nbsp;</td><td>The volume of interest.</td></tr>
  </table>
</dl>
This function is for debugging. It dumps, to the error log, at info_prio priority, metadata about the given volume, including the number of extents on the volume, the extent size, and the number of pages dedicated to store maps and extent maps. Then, for each store on the volume, it dumps the status of the store and the extents allocated to that store.<p>
This function must be run in a transaction, though the function is read-only. 
</div>
</div><p>
<a class="anchor" name="gf8eb87487de0644945f509ccdbff320b"></a><!-- doxytag: member="ss_m::get_volume_meta_stats" ref="gf8eb87487de0644945f509ccdbff320b" args="(vid_t vid, SmVolumeMetaStats &amp;volume_stats, concurrency_t cc=t_cc_none)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../db/dc7/classw__rc__t.html">rc_t</a> ss_m::get_volume_meta_stats           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/d3f/structvid__t.html">vid_t</a>&nbsp;</td>
          <td class="paramname"> <em>vid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SmVolumeMetaStats &amp;&nbsp;</td>
          <td class="paramname"> <em>volume_stats</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../da/d44/classss__m.html#50662c89c6fd0f384a655ca11e78b861">concurrency_t</a>&nbsp;</td>
          <td class="paramname"> <em>cc</em> = <code>t_cc_none</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Analyze a volume and collect brief statistics about its usage. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>vid</em>&nbsp;</td><td>The volume of interest. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>volume_stats</em>&nbsp;</td><td>The statistics are written here. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>cc</em>&nbsp;</td><td>Indicates whether the volume is to be locked by this method. Acceptable values are t_cc_none and t_cc_volume.</td></tr>
  </table>
</dl>
If no lock is acquired, the method can fail with eRETRY. 
</div>
</div><p>
<a class="anchor" name="gbdbd758de7fd4f8246b25d36c07780d5"></a><!-- doxytag: member="ss_m::get_file_meta_stats" ref="gbdbd758de7fd4f8246b25d36c07780d5" args="(vid_t vid, w_base_t::uint4_t num_files, SmFileMetaStats *file_stats, bool batch_calculate=false, concurrency_t cc=t_cc_none)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../db/dc7/classw__rc__t.html">rc_t</a> ss_m::get_file_meta_stats           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/d3f/structvid__t.html">vid_t</a>&nbsp;</td>
          <td class="paramname"> <em>vid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/da0/classw__base__t.html#7d1c7ae407200662fd16b64de4dcde46">w_base_t::uint4_t</a>&nbsp;</td>
          <td class="paramname"> <em>num_files</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SmFileMetaStats *&nbsp;</td>
          <td class="paramname"> <em>file_stats</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>batch_calculate</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../da/d44/classss__m.html#50662c89c6fd0f384a655ca11e78b861">concurrency_t</a>&nbsp;</td>
          <td class="paramname"> <em>cc</em> = <code>t_cc_none</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Analyze a volume and collect brief statistics about its usage. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>vid</em>&nbsp;</td><td>The volume of interest. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>num_files</em>&nbsp;</td><td>The size of the array file_stats. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>file_stats</em>&nbsp;</td><td>Preallocated array of structs into which to write the statistics for the individual files inspected. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>batch_calculate</em>&nbsp;</td><td>True means make one pass over the volume. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>cc</em>&nbsp;</td><td>Indicates whether the volume is to be locked by this method. Acceptable values are t_cc_none and t_cc_volume.</td></tr>
  </table>
</dl>
If no lock is acquired and batch_calculate is not set, the method can fail with eRETRY.<p>
If batch_calculate is true then this works by making one pass over the meta data, but it looks at all the meta data. This should be the faster way to do the analysis when there are many files, and when files use a large portion of the volume.<p>
If batch_calculate is false then each file is updated indidually, only looking at the extent information for that particular file. This requires a pass over the volume for each file. (Seek-wise it is less efficient). 
</div>
</div><p>
<a class="anchor" name="gac7948d4e08ac1c5c713dd5307919d35"></a><!-- doxytag: member="ss_m::vol_root_index" ref="gac7948d4e08ac1c5c713dd5307919d35" args="(const vid_t &amp;v, stid_t &amp;iid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../db/dc7/classw__rc__t.html">rc_t</a> ss_m::vol_root_index           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d3/d3f/structvid__t.html">vid_t</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../da/d5b/structstid__t.html">stid_t</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>iid</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the index ID of the root index of the volume. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>v</em>&nbsp;</td><td>Volume of interest. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>iid</em>&nbsp;</td><td>Store ID of the root index.</td></tr>
  </table>
</dl>
Each volume has a root index, which is a well-known index available to the server for bootstrapping a database. <dl compact><dt><b>Examples: </b></dt><dd>
<a class="el" href="../../df/d97/create__rec_8cpp-example.html#a24">create_rec.cpp</a>.</dl>
<p>
Definition at line <a class="el" href="../../da/d46/sm_8h-source.html#l01999">1999</a> of file <a class="el" href="../../da/d46/sm_8h-source.html">sm.h</a>.
<p>
References <a class="el" href="../../d1/d83/w__rc_8h.html#0f25e1835ee19d3905bd8ee2d2f0c86c">RCOK</a>, <a class="el" href="../../da/d5b/structstid__t.html#ba17babad0254a9bd7108b7489c6a64e">stid_t::store</a>, and <a class="el" href="../../da/d5b/structstid__t.html#9401c203b02338403a5227f18e27af6c">stid_t::vol</a>.
</div>
</div><p>
<a class="anchor" name="ged476303a8f697b978bba37897ef866d"></a><!-- doxytag: member="ss_m::lvid_to_vid" ref="ged476303a8f697b978bba37897ef866d" args="(const lvid_t &amp;lvid, vid_t &amp;vid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../db/dc7/classw__rc__t.html">rc_t</a> ss_m::lvid_to_vid           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d8/d94/structlvid__t.html">lvid_t</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>lvid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d3/d3f/structvid__t.html">vid_t</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>vid</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the short volume ID of a volume. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>lvid</em>&nbsp;</td><td>Long (persistent) volume ID found on the volume's header. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>vid</em>&nbsp;</td><td>Short volume ID of a mounted volume. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g79d6a03fe68956196506f964a2e5894e"></a><!-- doxytag: member="ss_m::vid_to_lvid" ref="g79d6a03fe68956196506f964a2e5894e" args="(vid_t vid, lvid_t &amp;lvid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../db/dc7/classw__rc__t.html">rc_t</a> ss_m::vid_to_lvid           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/d3f/structvid__t.html">vid_t</a>&nbsp;</td>
          <td class="paramname"> <em>vid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d8/d94/structlvid__t.html">lvid_t</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>lvid</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the long volume ID of a volume. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>vid</em>&nbsp;</td><td>Short volume ID of a mounted volume. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>lvid</em>&nbsp;</td><td>Long (persistent) volume ID found on the volume's header. </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr size="1"><address style="align: right;"><small>Generated on Mon Jan 2 15:14:01 2012 for Shore Storage Manager by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
