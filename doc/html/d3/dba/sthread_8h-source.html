<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Shore Storage Manager: src/sthread/sthread.h Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
<link href="../../tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="../../main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="../../modules.html"><span>Modules</span></a></li>
    <li><a href="../../namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="../../classes.html"><span>Classes</span></a></li>
    <li id="current"><a href="../../files.html"><span>Files</span></a></li>
    <li><a href="../../dirs.html"><span>Directories</span></a></li>
    <li><a href="../../pages.html"><span>Related&nbsp;Pages</span></a></li>
    <li><a href="../../examples.html"><span>Examples</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="../../files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="../../globals.html"><span>File&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="../../dir_ff5597eff5bf2afe4bf6bec877c08348.html">src</a>&nbsp;&raquo&nbsp;<a class="el" href="../../dir_9a74d9245097bf078e64cd41d322b2c9.html">sthread</a></div>
<h1>sthread.h</h1><a href="../../d3/de1/sthread_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/* -*- mode:C++; c-basic-offset:4 -*-</span>
<a name="l00002"></a>00002 <span class="comment">     Shore-MT -- Multi-threaded port of the SHORE storage manager</span>
<a name="l00003"></a>00003 <span class="comment">   </span>
<a name="l00004"></a>00004 <span class="comment">                       Copyright (c) 2007-2009</span>
<a name="l00005"></a>00005 <span class="comment">      Data Intensive Applications and Systems Labaratory (DIAS)</span>
<a name="l00006"></a>00006 <span class="comment">               Ecole Polytechnique Federale de Lausanne</span>
<a name="l00007"></a>00007 <span class="comment">   </span>
<a name="l00008"></a>00008 <span class="comment">                         All Rights Reserved.</span>
<a name="l00009"></a>00009 <span class="comment">   </span>
<a name="l00010"></a>00010 <span class="comment">   Permission to use, copy, modify and distribute this software and</span>
<a name="l00011"></a>00011 <span class="comment">   its documentation is hereby granted, provided that both the</span>
<a name="l00012"></a>00012 <span class="comment">   copyright notice and this permission notice appear in all copies of</span>
<a name="l00013"></a>00013 <span class="comment">   the software, derivative works or modified versions, and any</span>
<a name="l00014"></a>00014 <span class="comment">   portions thereof, and that both notices appear in supporting</span>
<a name="l00015"></a>00015 <span class="comment">   documentation.</span>
<a name="l00016"></a>00016 <span class="comment">   </span>
<a name="l00017"></a>00017 <span class="comment">   This code is distributed in the hope that it will be useful, but</span>
<a name="l00018"></a>00018 <span class="comment">   WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00019"></a>00019 <span class="comment">   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. THE AUTHORS</span>
<a name="l00020"></a>00020 <span class="comment">   DISCLAIM ANY LIABILITY OF ANY KIND FOR ANY DAMAGES WHATSOEVER</span>
<a name="l00021"></a>00021 <span class="comment">   RESULTING FROM THE USE OF THIS SOFTWARE.</span>
<a name="l00022"></a>00022 <span class="comment">*/</span>
<a name="l00023"></a>00023 
<a name="l00024"></a>00024 <span class="comment">// -*- mode:c++; c-basic-offset:4 -*-</span>
<a name="l00025"></a>00025 <span class="comment">/*&lt;std-header orig-src='shore' incl-file-exclusion='STHREAD_H'&gt;</span>
<a name="l00026"></a>00026 <span class="comment"></span>
<a name="l00027"></a>00027 <span class="comment"> $Id: sthread.h,v 1.209 2012/01/02 17:02:22 nhall Exp $</span>
<a name="l00028"></a>00028 <span class="comment"></span>
<a name="l00029"></a>00029 <span class="comment">SHORE -- Scalable Heterogeneous Object REpository</span>
<a name="l00030"></a>00030 <span class="comment"></span>
<a name="l00031"></a>00031 <span class="comment">Copyright (c) 1994-99 Computer Sciences Department, University of</span>
<a name="l00032"></a>00032 <span class="comment">                      Wisconsin -- Madison</span>
<a name="l00033"></a>00033 <span class="comment">All Rights Reserved.</span>
<a name="l00034"></a>00034 <span class="comment"></span>
<a name="l00035"></a>00035 <span class="comment">Permission to use, copy, modify and distribute this software and its</span>
<a name="l00036"></a>00036 <span class="comment">documentation is hereby granted, provided that both the copyright</span>
<a name="l00037"></a>00037 <span class="comment">notice and this permission notice appear in all copies of the</span>
<a name="l00038"></a>00038 <span class="comment">software, derivative works or modified versions, and any portions</span>
<a name="l00039"></a>00039 <span class="comment">thereof, and that both notices appear in supporting documentation.</span>
<a name="l00040"></a>00040 <span class="comment"></span>
<a name="l00041"></a>00041 <span class="comment">THE AUTHORS AND THE COMPUTER SCIENCES DEPARTMENT OF THE UNIVERSITY</span>
<a name="l00042"></a>00042 <span class="comment">OF WISCONSIN - MADISON ALLOW FREE USE OF THIS SOFTWARE IN ITS</span>
<a name="l00043"></a>00043 <span class="comment">"AS IS" CONDITION, AND THEY DISCLAIM ANY LIABILITY OF ANY KIND</span>
<a name="l00044"></a>00044 <span class="comment">FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.</span>
<a name="l00045"></a>00045 <span class="comment"></span>
<a name="l00046"></a>00046 <span class="comment">This software was developed with support by the Advanced Research</span>
<a name="l00047"></a>00047 <span class="comment">Project Agency, ARPA order number 018 (formerly 8230), monitored by</span>
<a name="l00048"></a>00048 <span class="comment">the U.S. Army Research Laboratory under contract DAAB07-91-C-Q518.</span>
<a name="l00049"></a>00049 <span class="comment">Further funding for this work was provided by DARPA through</span>
<a name="l00050"></a>00050 <span class="comment">Rome Research Laboratory Contract No. F30602-97-2-0247.</span>
<a name="l00051"></a>00051 <span class="comment"></span>
<a name="l00052"></a>00052 <span class="comment">*/</span>
<a name="l00053"></a>00053 
<a name="l00054"></a>00054 <span class="comment">/*  -- do not edit anything above this line --   &lt;/std-header&gt;*/</span>
<a name="l00055"></a>00055 
<a name="l00056"></a>00056 <span class="comment">/*</span>
<a name="l00057"></a>00057 <span class="comment"> * The SHORE threads layer has some historical roots in the</span>
<a name="l00058"></a>00058 <span class="comment"> * the NewThreads implementation wrapped up as c++ objects.</span>
<a name="l00059"></a>00059 <span class="comment"> *</span>
<a name="l00060"></a>00060 <span class="comment"> * With release 6.0 of the SHORE Storage Manager, the NewThreads</span>
<a name="l00061"></a>00061 <span class="comment"> * functionality was substantially obviated.  Some bits and pieces</span>
<a name="l00062"></a>00062 <span class="comment"> * of the SHORE threads layer remains in the synchronization variables</span>
<a name="l00063"></a>00063 <span class="comment"> * in the sthread_t API.</span>
<a name="l00064"></a>00064 <span class="comment"> *</span>
<a name="l00065"></a>00065 <span class="comment"> * To the extent that any NewThreads code remains here, </span>
<a name="l00066"></a>00066 <span class="comment"> * the following copyright applies: </span>
<a name="l00067"></a>00067 <span class="comment"> *</span>
<a name="l00068"></a>00068 <span class="comment"> *   NewThreads is Copyright 1992, 1993, 1994, 1995, 1996, 1997 by:</span>
<a name="l00069"></a>00069 <span class="comment"> *</span>
<a name="l00070"></a>00070 <span class="comment"> *    Josef Burger    &lt;bolo@cs.wisc.edu&gt;</span>
<a name="l00071"></a>00071 <span class="comment"> *    Dylan McNamee   &lt;dylan@cse.ogi.edu&gt;</span>
<a name="l00072"></a>00072 <span class="comment"> *    Ed Felten       &lt;felten@cs.princeton.edu&gt;</span>
<a name="l00073"></a>00073 <span class="comment"> *</span>
<a name="l00074"></a>00074 <span class="comment"> *   All Rights Reserved.</span>
<a name="l00075"></a>00075 <span class="comment"> *</span>
<a name="l00076"></a>00076 <span class="comment"> *   NewThreads may be freely used as long as credit is given</span>
<a name="l00077"></a>00077 <span class="comment"> *   to the above authors and the above copyright is maintained.</span>
<a name="l00078"></a>00078 <span class="comment"> */</span>
<a name="l00079"></a>00079 <span class="comment"></span>
<a name="l00080"></a>00080 <span class="comment">/**\file sthread.h</span>
<a name="l00081"></a>00081 <span class="comment"> *\ingroup MACROS</span>
<a name="l00082"></a>00082 <span class="comment"> *</span>
<a name="l00083"></a>00083 <span class="comment"> * This file contains the Shore Threads API.</span>
<a name="l00084"></a>00084 <span class="comment"> */</span>
<a name="l00085"></a>00085 
<a name="l00086"></a>00086 <span class="preprocessor">#ifndef STHREAD_H</span>
<a name="l00087"></a>00087 <span class="preprocessor"></span><span class="preprocessor">#define STHREAD_H</span>
<a name="l00088"></a>00088 <span class="preprocessor"></span>
<a name="l00089"></a>00089 <span class="preprocessor">#include "w_defines.h"</span>
<a name="l00090"></a>00090 <span class="preprocessor">#include "<a class="code" href="../../d1/d83/w__rc_8h.html">w_rc.h</a>"</span>
<a name="l00091"></a>00091 <span class="preprocessor">#include "atomic_templates.h"</span>
<a name="l00092"></a>00092 <span class="preprocessor">#include "w_strstream.h"</span>
<a name="l00093"></a>00093 <span class="preprocessor">#include "stime.h"</span>
<a name="l00094"></a>00094 <span class="preprocessor">#include "gethrtime.h"</span>
<a name="l00095"></a>00095 <span class="preprocessor">#include &lt;vtable.h&gt;</span>
<a name="l00096"></a>00096 <span class="preprocessor">#include &lt;<a class="code" href="../../d8/d92/w__list_8h.html">w_list.h</a>&gt;</span>
<a name="l00097"></a>00097 
<a name="l00098"></a>00098 <span class="comment">// this #include reflects the fact that sthreads is now just a pthreads wrapper</span>
<a name="l00099"></a>00099 <span class="preprocessor">#include &lt;w_pthread.h&gt;</span>
<a name="l00100"></a>00100 <span class="preprocessor">#include &lt;<a class="code" href="../../da/d18/sthread__stats_8h.html">sthread_stats.h</a>&gt;</span>
<a name="l00101"></a>00101 
<a name="l00102"></a>00102 <span class="keyword">class </span><a class="code" href="../../dd/ded/classsthread__t.html">sthread_t</a>;
<a name="l00103"></a>00103 <span class="keyword">class </span><a class="code" href="../../d7/d2a/classsmthread__t.html">smthread_t</a>;
<a name="l00104"></a>00104 
<a name="l00105"></a>00105 
<a name="l00106"></a>00106 <span class="preprocessor">#ifdef __GNUC__</span>
<a name="l00107"></a>00107 <span class="preprocessor"></span><span class="preprocessor">#pragma interface</span>
<a name="l00108"></a>00108 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00109"></a>00109 <span class="preprocessor"></span>
<a name="l00110"></a>00110 <span class="preprocessor">#ifndef SDISK_H</span>
<a name="l00111"></a>00111 <span class="preprocessor"></span><span class="preprocessor">#include &lt;sdisk.h&gt;</span>
<a name="l00112"></a>00112 <span class="preprocessor">#endif</span>
<a name="l00113"></a>00113 <span class="preprocessor"></span>
<a name="l00114"></a>00114 <span class="keyword">class </span><a class="code" href="../../db/d4a/classvtable__row__t.html">vtable_row_t</a>;
<a name="l00115"></a>00115 <span class="keyword">class </span><a class="code" href="../../d3/d76/classvtable__t.html">vtable_t</a>;
<a name="l00116"></a>00116 
<a name="l00117"></a>00117 <span class="keyword">struct </span>sthread_core_t;
<a name="l00118"></a>00118 
<a name="l00119"></a>00119 <span class="keyword">extern</span> <span class="stringliteral">"C"</span> <span class="keywordtype">void</span>         dumpthreads(); <span class="comment">// for calling from debugger</span>
<a name="l00120"></a>00120 
<a name="l00121"></a>00121 <span class="comment"></span>
<a name="l00122"></a>00122 <span class="comment">/**\brief Base class for sthreads.  See \ref timeout_in_ms, \ref timeout_t</span>
<a name="l00123"></a>00123 <span class="comment"> */</span>
<a name="l00124"></a><a class="code" href="../../d2/d6b/classsthread__base__t.html">00124</a> <span class="keyword">class </span><a class="code" href="../../d2/d6b/classsthread__base__t.html">sthread_base_t</a> : <span class="keyword">public</span> <a class="code" href="../../d9/da0/classw__base__t.html">w_base_t</a> {
<a name="l00125"></a>00125 <span class="keyword">public</span>:<span class="comment"></span>
<a name="l00126"></a>00126 <span class="comment">/**\cond skip */</span>
<a name="l00127"></a>00127     <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> w_thread_id_t; <span class="comment">// TODO REMOVE</span>
<a name="l00128"></a>00128     <span class="keyword">typedef</span> w_thread_id_t id_t;<span class="comment"></span>
<a name="l00129"></a>00129 <span class="comment">/**\endcond skip */</span>
<a name="l00130"></a>00130 
<a name="l00131"></a>00131     <span class="comment">/* XXX this is really something for the SM, not the threads package;</span>
<a name="l00132"></a>00132 <span class="comment">       only WAIT_IMMEDIATE should ever make it to the threads package. */</span>
<a name="l00133"></a>00133 <span class="comment"></span>
<a name="l00134"></a>00134 <span class="comment">    /**\enum timeout_t</span>
<a name="l00135"></a>00135 <span class="comment">     * \brief Special values for timeout_in_ms.</span>
<a name="l00136"></a>00136 <span class="comment">     *</span>
<a name="l00137"></a>00137 <span class="comment">     * \details sthreads package recognizes 2 WAIT_* values:</span>
<a name="l00138"></a>00138 <span class="comment">     * == WAIT_IMMEDIATE</span>
<a name="l00139"></a>00139 <span class="comment">     * and != WAIT_IMMEDIATE.</span>
<a name="l00140"></a>00140 <span class="comment">     *</span>
<a name="l00141"></a>00141 <span class="comment">     * If it's not WAIT_IMMEDIATE, it's assumed to be</span>
<a name="l00142"></a>00142 <span class="comment">     * a positive integer (milliseconds) used for the</span>
<a name="l00143"></a>00143 <span class="comment">     * select timeout.</span>
<a name="l00144"></a>00144 <span class="comment">     * WAIT_IMMEDIATE: no wait</span>
<a name="l00145"></a>00145 <span class="comment">     * WAIT_FOREVER:   may block indefinitely</span>
<a name="l00146"></a>00146 <span class="comment">     * The user of the thread (e.g., sm) had better</span>
<a name="l00147"></a>00147 <span class="comment">     * convert timeout that are negative values (WAIT_* below)</span>
<a name="l00148"></a>00148 <span class="comment">     * to something &gt;= 0 before calling block().</span>
<a name="l00149"></a>00149 <span class="comment">     *</span>
<a name="l00150"></a>00150 <span class="comment">     * All other WAIT_* values other than WAIT_IMMEDIATE</span>
<a name="l00151"></a>00151 <span class="comment">     * are handled by sm layer:</span>
<a name="l00152"></a>00152 <span class="comment">     * WAIT_SPECIFIED_BY_THREAD: pick up a timeout_in_ms from the smthread.</span>
<a name="l00153"></a>00153 <span class="comment">     * WAIT_SPECIFIED_BY_XCT: pick up a timeout_in_ms from the transaction.</span>
<a name="l00154"></a>00154 <span class="comment">     * Anything else: not legitimate.</span>
<a name="l00155"></a>00155 <span class="comment">     * </span>
<a name="l00156"></a>00156 <span class="comment">     * \sa timeout_in_ms</span>
<a name="l00157"></a>00157 <span class="comment">     */</span>
<a name="l00158"></a><a class="code" href="../../d2/d6b/classsthread__base__t.html#1fb3df29675e45b79143447297f1c352">00158</a>     <span class="keyword">enum</span> <a class="code" href="../../d2/d6b/classsthread__base__t.html#1fb3df29675e45b79143447297f1c352">timeout_t</a> {
<a name="l00159"></a>00159     WAIT_IMMEDIATE     = 0, 
<a name="l00160"></a>00160     WAIT_FOREVER     = -1,
<a name="l00161"></a>00161     WAIT_SPECIFIED_BY_THREAD     = -4, <span class="comment">// used by lock manager</span>
<a name="l00162"></a>00162     WAIT_SPECIFIED_BY_XCT = -5, <span class="comment">// used by lock manager</span>
<a name="l00163"></a>00163     WAIT_NOT_USED = -6 <span class="comment">// indicates last negative number used by sthreads</span>
<a name="l00164"></a>00164     };
<a name="l00165"></a>00165     <span class="comment">/* XXX int would also work, sized type not necessary */</span><span class="comment"></span>
<a name="l00166"></a>00166 <span class="comment">    /**\typedef int4_t timeout_in_ms;</span>
<a name="l00167"></a>00167 <span class="comment">     * \brief Timeout in milliseconds if &gt; 0</span>
<a name="l00168"></a>00168 <span class="comment">     * \details</span>
<a name="l00169"></a>00169 <span class="comment">     * sthread_t blocking methods take a timeout in milliseconds.</span>
<a name="l00170"></a>00170 <span class="comment">     * If the value is &lt; 0, then it's expected to be a member of the</span>
<a name="l00171"></a>00171 <span class="comment">     * enumeration type timeout_t.</span>
<a name="l00172"></a>00172 <span class="comment">     *</span>
<a name="l00173"></a>00173 <span class="comment">     * \sa timeout_t</span>
<a name="l00174"></a>00174 <span class="comment">     */</span>
<a name="l00175"></a><a class="code" href="../../d2/d6b/classsthread__base__t.html#c1377912ffa5e8f35cf9eb3d67e465b7">00175</a>     <span class="keyword">typedef</span> <a class="code" href="../../d9/da0/classw__base__t.html#1a9601702a65daae96f2e11b6896eed3">int4_t</a> <a class="code" href="../../d2/d6b/classsthread__base__t.html#c1377912ffa5e8f35cf9eb3d67e465b7">timeout_in_ms</a>;
<a name="l00176"></a>00176 <span class="comment"></span>
<a name="l00177"></a>00177 <span class="comment">/**\cond skip */</span>
<a name="l00178"></a>00178     <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="../../d0/d10/structw__error__info__t.html">w_error_t::info_t</a>     error_info[];
<a name="l00179"></a>00179     <span class="keyword">static</span> <span class="keywordtype">void</span>  init_errorcodes();
<a name="l00180"></a>00180 
<a name="l00181"></a>00181 <span class="preprocessor">#include "st_error_enum_gen.h"</span>
<a name="l00182"></a>00182 
<a name="l00183"></a>00183     <span class="keyword">enum</span> {
<a name="l00184"></a>00184     stOS = fcOS,
<a name="l00185"></a>00185     stINTERNAL = fcINTERNAL,
<a name="l00186"></a>00186     stNOTIMPLEMENTED = fcNOTIMPLEMENTED 
<a name="l00187"></a>00187     };
<a name="l00188"></a>00188 
<a name="l00189"></a>00189     <span class="comment">/* import sdisk base */</span>
<a name="l00190"></a>00190     <span class="keyword">typedef</span> sdisk_base_t::fileoff_t    fileoff_t;
<a name="l00191"></a>00191     <span class="keyword">typedef</span> sdisk_base_t::filestat_t   filestat_t;
<a name="l00192"></a>00192     <span class="keyword">typedef</span> sdisk_base_t::iovec_t      iovec_t;
<a name="l00193"></a>00193 
<a name="l00194"></a>00194 
<a name="l00195"></a>00195     <span class="comment">/* XXX magic number */</span>
<a name="l00196"></a>00196     <span class="keyword">enum</span> { iovec_max = 8 };
<a name="l00197"></a>00197 
<a name="l00198"></a>00198     <span class="keyword">enum</span> {
<a name="l00199"></a>00199     OPEN_RDWR = sdisk_base_t::OPEN_RDWR,
<a name="l00200"></a>00200     OPEN_RDONLY = sdisk_base_t::OPEN_RDONLY,
<a name="l00201"></a>00201     OPEN_WRONLY = sdisk_base_t::OPEN_WRONLY,
<a name="l00202"></a>00202 
<a name="l00203"></a>00203     OPEN_SYNC = sdisk_base_t::OPEN_SYNC,
<a name="l00204"></a>00204     OPEN_TRUNC = sdisk_base_t::OPEN_TRUNC,
<a name="l00205"></a>00205     OPEN_CREATE = sdisk_base_t::OPEN_CREATE,
<a name="l00206"></a>00206     OPEN_EXCL = sdisk_base_t::OPEN_EXCL,
<a name="l00207"></a>00207     OPEN_APPEND = sdisk_base_t::OPEN_APPEND,
<a name="l00208"></a>00208     OPEN_RAW = sdisk_base_t::OPEN_RAW
<a name="l00209"></a>00209     };
<a name="l00210"></a>00210     <span class="keyword">enum</span> {
<a name="l00211"></a>00211     SEEK_AT_SET = sdisk_base_t::SEEK_AT_SET,
<a name="l00212"></a>00212     SEEK_AT_CUR = sdisk_base_t::SEEK_AT_CUR,
<a name="l00213"></a>00213     SEEK_AT_END = sdisk_base_t::SEEK_AT_END
<a name="l00214"></a>00214     };<span class="comment"></span>
<a name="l00215"></a>00215 <span class="comment">/**\endcond skip */</span>
<a name="l00216"></a>00216 };
<a name="l00217"></a>00217 <span class="comment"></span>
<a name="l00218"></a>00218 <span class="comment">/**\cond skip */</span>
<a name="l00219"></a>00219 <span class="keyword">class </span>sthread_name_t {
<a name="l00220"></a>00220 <span class="keyword">public</span>:
<a name="l00221"></a>00221     <span class="keyword">enum</span> { NAME_ARRAY = 64 };
<a name="l00222"></a>00222 
<a name="l00223"></a>00223     <span class="keywordtype">char</span>        _name[NAME_ARRAY];
<a name="l00224"></a>00224 
<a name="l00225"></a>00225     sthread_name_t();
<a name="l00226"></a>00226     ~sthread_name_t();
<a name="l00227"></a>00227 
<a name="l00228"></a>00228     <span class="keywordtype">void</span> rename(<span class="keyword">const</span> <span class="keywordtype">char</span> *n1, <span class="keyword">const</span> <span class="keywordtype">char</span> *n2=0, <span class="keyword">const</span> <span class="keywordtype">char</span> *n3=0);
<a name="l00229"></a>00229 };
<a name="l00230"></a>00230 
<a name="l00231"></a>00231 <span class="keyword">class </span>sthread_named_base_t: <span class="keyword">public</span> <a class="code" href="../../d2/d6b/classsthread__base__t.html">sthread_base_t</a>
<a name="l00232"></a>00232 {
<a name="l00233"></a>00233 <span class="keyword">public</span>:
<a name="l00234"></a>00234     <a class="code" href="../../dd/d93/w__base_8h.html#45d83e292de0c4c2a60998a0b9e82332">NORET</a>            sthread_named_base_t(
<a name="l00235"></a>00235     <span class="keyword">const</span> <span class="keywordtype">char</span>*            n1 = 0,
<a name="l00236"></a>00236     <span class="keyword">const</span> <span class="keywordtype">char</span>*            n2 = 0,
<a name="l00237"></a>00237     <span class="keyword">const</span> <span class="keywordtype">char</span>*            n3 = 0);
<a name="l00238"></a>00238     <a class="code" href="../../dd/d93/w__base_8h.html#45d83e292de0c4c2a60998a0b9e82332">NORET</a>            ~sthread_named_base_t();
<a name="l00239"></a>00239     
<a name="l00240"></a>00240     <span class="keywordtype">void</span>            rename(
<a name="l00241"></a>00241     <span class="keyword">const</span> <span class="keywordtype">char</span>*            n1,
<a name="l00242"></a>00242     <span class="keyword">const</span> <span class="keywordtype">char</span>*            n2 = 0,
<a name="l00243"></a>00243     <span class="keyword">const</span> <span class="keywordtype">char</span>*            n3 = 0);
<a name="l00244"></a>00244 
<a name="l00245"></a>00245     <span class="keyword">const</span> <span class="keywordtype">char</span>*            name() <span class="keyword">const</span>;
<a name="l00246"></a>00246     <span class="keywordtype">void</span>                   unname();
<a name="l00247"></a>00247 
<a name="l00248"></a>00248 <span class="keyword">private</span>:
<a name="l00249"></a>00249     sthread_name_t        _name;
<a name="l00250"></a>00250 };
<a name="l00251"></a>00251 
<a name="l00252"></a>00252 <span class="keyword">inline</span> <a class="code" href="../../dd/d93/w__base_8h.html#45d83e292de0c4c2a60998a0b9e82332">NORET</a>
<a name="l00253"></a>00253 sthread_named_base_t::sthread_named_base_t(
<a name="l00254"></a>00254     <span class="keyword">const</span> <span class="keywordtype">char</span>*        n1,
<a name="l00255"></a>00255     <span class="keyword">const</span> <span class="keywordtype">char</span>*        n2,
<a name="l00256"></a>00256     <span class="keyword">const</span> <span class="keywordtype">char</span>*        n3)
<a name="l00257"></a>00257 {
<a name="l00258"></a>00258     rename(n1, n2, n3);
<a name="l00259"></a>00259 
<a name="l00260"></a>00260 }
<a name="l00261"></a>00261 
<a name="l00262"></a>00262 <span class="keyword">inline</span> <span class="keyword">const</span> <span class="keywordtype">char</span>*
<a name="l00263"></a>00263 sthread_named_base_t::name()<span class="keyword"> const</span>
<a name="l00264"></a>00264 <span class="keyword"></span>{
<a name="l00265"></a>00265     <span class="keywordflow">return</span> _name._name;
<a name="l00266"></a>00266 }
<a name="l00267"></a>00267 
<a name="l00268"></a>00268 <span class="keyword">class </span>sthread_main_t;
<a name="l00269"></a>00269 <span class="comment"></span>
<a name="l00270"></a>00270 <span class="comment">/**\endcond skip */</span>
<a name="l00271"></a>00271 <span class="comment"></span>
<a name="l00272"></a>00272 <span class="comment">/**\brief A callback class for traversing the list of all sthreads.</span>
<a name="l00273"></a>00273 <span class="comment"> * \details</span>
<a name="l00274"></a>00274 <span class="comment"> * Use with for_each_thread. Somewhat costly because it's thread-safe.</span>
<a name="l00275"></a>00275 <span class="comment"> */</span>
<a name="l00276"></a><a class="code" href="../../d1/db1/class_thread_func.html">00276</a> <span class="keyword">class </span><a class="code" href="../../d1/db1/class_thread_func.html">ThreadFunc</a>
<a name="l00277"></a>00277 {
<a name="l00278"></a>00278     <span class="keyword">public</span>:
<a name="l00279"></a>00279     <span class="keyword">virtual</span> <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> <a class="code" href="../../dd/ded/classsthread__t.html">sthread_t</a>&amp; thread) = 0;
<a name="l00280"></a><a class="code" href="../../d1/db1/class_thread_func.html#eb82e9dbbbb9fc7b72fbf866b6d0b481">00280</a>     <span class="keyword">virtual</span> <a class="code" href="../../dd/d93/w__base_8h.html#45d83e292de0c4c2a60998a0b9e82332">NORET</a> <a class="code" href="../../d1/db1/class_thread_func.html#eb82e9dbbbb9fc7b72fbf866b6d0b481">~ThreadFunc</a>() {}
<a name="l00281"></a>00281 };
<a name="l00282"></a>00282 
<a name="l00283"></a>00283 
<a name="l00284"></a>00284 <span class="keyword">class </span><a class="code" href="../../d2/d33/classsthread__init__t.html">sthread_init_t</a>;
<a name="l00285"></a>00285 <span class="keyword">class </span>sthread_main_t;
<a name="l00286"></a>00286 
<a name="l00287"></a>00287 <span class="comment">// these macros allow us to notify the SunStudio race detector about lock acquires/releases</span>
<a name="l00288"></a>00288 
<a name="l00289"></a>00289 <span class="preprocessor">#include "os_interface.h"</span>
<a name="l00290"></a>00290 <span class="comment"></span>
<a name="l00291"></a>00291 <span class="comment">/**\brief A test-and-test-and-set spinlock. </span>
<a name="l00292"></a>00292 <span class="comment"> *</span>
<a name="l00293"></a>00293 <span class="comment"> * This lock is good for short, uncontended critical sections. </span>
<a name="l00294"></a>00294 <span class="comment"> * If contention is high, use an mcs_lock. </span>
<a name="l00295"></a>00295 <span class="comment"> * Long critical sections should use pthread_mutex_t.</span>
<a name="l00296"></a>00296 <span class="comment"> *</span>
<a name="l00297"></a>00297 <span class="comment"> * Tradeoffs are:</span>
<a name="l00298"></a>00298 <span class="comment"> *  - test-and-test-and-set locks: low-overhead but not scalable</span>
<a name="l00299"></a>00299 <span class="comment"> *  - queue-based locks: higher overhead but scalable</span>
<a name="l00300"></a>00300 <span class="comment"> *  - pthread mutexes : very high overhead and blocks, but frees up </span>
<a name="l00301"></a>00301 <span class="comment"> *  cpu for other threads when number of cpus is fewer than number of threads</span>
<a name="l00302"></a>00302 <span class="comment"> *</span>
<a name="l00303"></a>00303 <span class="comment"> *  \sa REFSYNC</span>
<a name="l00304"></a>00304 <span class="comment"> */</span>
<a name="l00305"></a><a class="code" href="../../d6/d9d/structtatas__lock.html">00305</a> <span class="keyword">struct </span><a class="code" href="../../d6/d9d/structtatas__lock.html">tatas_lock</a> {<span class="comment"></span>
<a name="l00306"></a>00306 <span class="comment">    /**\cond skip */</span>
<a name="l00307"></a>00307     <span class="keyword">enum</span> { NOBODY=0 };
<a name="l00308"></a>00308     <span class="keyword">typedef</span> <span class="keyword">union  </span>{
<a name="l00309"></a>00309         pthread_t         handle;
<a name="l00310"></a>00310 <span class="preprocessor">#undef CASFUNC </span>
<a name="l00311"></a>00311 <span class="preprocessor"></span><span class="preprocessor">#if SIZEOF_PTHREAD_T==4</span>
<a name="l00312"></a>00312 <span class="preprocessor"></span><span class="preprocessor">#define CASFUNC atomic_cas_32</span>
<a name="l00313"></a>00313 <span class="preprocessor"></span>        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>       bits;
<a name="l00314"></a>00314 <span class="preprocessor">#elif SIZEOF_PTHREAD_T==8</span>
<a name="l00315"></a>00315 <span class="preprocessor"></span><span class="preprocessor"># define CASFUNC atomic_cas_64</span>
<a name="l00316"></a>00316 <span class="preprocessor"></span>        uint64_t           bits;
<a name="l00317"></a>00317 <span class="preprocessor">#elif SIZEOF_PTHREAD_T==0</span>
<a name="l00318"></a>00318 <span class="preprocessor"></span><span class="preprocessor">#error  Configuration could not determine size of pthread_t. Fix configure.ac.</span>
<a name="l00319"></a>00319 <span class="preprocessor"></span><span class="preprocessor">#else </span>
<a name="l00320"></a>00320 <span class="preprocessor"></span><span class="preprocessor">#error  Configuration determined size of pthread_t is unexpected. Fix sthread.h.</span>
<a name="l00321"></a>00321 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00322"></a>00322 <span class="preprocessor"></span>    } holder_type_t;
<a name="l00323"></a>00323     <span class="keyword">volatile</span> holder_type_t _holder;<span class="comment"></span>
<a name="l00324"></a>00324 <span class="comment">    /**\endcond skip */</span>
<a name="l00325"></a>00325 
<a name="l00326"></a><a class="code" href="../../d6/d9d/structtatas__lock.html#0abe8710734d697777456c61beca7179">00326</a>     <a class="code" href="../../d6/d9d/structtatas__lock.html#0abe8710734d697777456c61beca7179">tatas_lock</a>() { _holder.bits=NOBODY; }
<a name="l00327"></a>00327 
<a name="l00328"></a>00328 <span class="keyword">private</span>:
<a name="l00329"></a>00329     <span class="comment">// CC mangles this as __1cKtatas_lockEspin6M_v_</span><span class="comment"></span>
<a name="l00330"></a>00330 <span class="comment">    /// spin until lock is free</span>
<a name="l00331"></a>00331 <span class="comment"></span>    <span class="keywordtype">void</span> spin() { <span class="keywordflow">while</span>(*&amp;(_holder.handle)) ; }
<a name="l00332"></a>00332 
<a name="l00333"></a>00333 <span class="keyword">public</span>:<span class="comment"></span>
<a name="l00334"></a>00334 <span class="comment">    /// Try to acquire the lock immediately.</span>
<a name="l00335"></a><a class="code" href="../../d6/d9d/structtatas__lock.html#e2806aa2f03bc30740e2ca419986af39">00335</a> <span class="comment"></span>    <span class="keywordtype">bool</span> <a class="code" href="../../d6/d9d/structtatas__lock.html#e2806aa2f03bc30740e2ca419986af39">try_lock</a>() 
<a name="l00336"></a>00336     {
<a name="l00337"></a>00337         holder_type_t tid = { pthread_self() };
<a name="l00338"></a>00338         <span class="keywordtype">bool</span> success = <span class="keyword">false</span>;
<a name="l00339"></a>00339         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> old_holder = 
<a name="l00340"></a>00340                         CASFUNC(&amp;_holder.bits, NOBODY, tid.bits);
<a name="l00341"></a>00341         <span class="keywordflow">if</span>(old_holder == NOBODY) {
<a name="l00342"></a>00342             membar_enter();
<a name="l00343"></a>00343             success = <span class="keyword">true</span>;
<a name="l00344"></a>00344         }
<a name="l00345"></a>00345         
<a name="l00346"></a>00346         <span class="keywordflow">return</span> success;
<a name="l00347"></a>00347     }
<a name="l00348"></a>00348 <span class="comment"></span>
<a name="l00349"></a>00349 <span class="comment">    /// Acquire the lock, spinning as long as necessary. </span>
<a name="l00350"></a><a class="code" href="../../d6/d9d/structtatas__lock.html#3e701a5591759ce910b8e8237f8f6fcd">00350</a> <span class="comment"></span>    <span class="keywordtype">void</span> <a class="code" href="../../d6/d9d/structtatas__lock.html#3e701a5591759ce910b8e8237f8f6fcd">acquire</a>() {
<a name="l00351"></a>00351         <a class="code" href="../../dd/d93/w__base_8h.html#bcf9bfdb4e430cecbbaf03b144448b60">w_assert1</a>(!<a class="code" href="../../d6/d9d/structtatas__lock.html#b41a502e2d757fe0bb284a8efec969d6">is_mine</a>());
<a name="l00352"></a>00352         holder_type_t tid = { pthread_self() };
<a name="l00353"></a>00353         <span class="keywordflow">do</span> {
<a name="l00354"></a>00354             spin();
<a name="l00355"></a>00355         }
<a name="l00356"></a>00356         <span class="keywordflow">while</span>(CASFUNC(&amp;_holder.bits, NOBODY, tid.bits));
<a name="l00357"></a>00357         membar_enter();
<a name="l00358"></a>00358         <a class="code" href="../../dd/d93/w__base_8h.html#bcf9bfdb4e430cecbbaf03b144448b60">w_assert1</a>(<a class="code" href="../../d6/d9d/structtatas__lock.html#b41a502e2d757fe0bb284a8efec969d6">is_mine</a>());
<a name="l00359"></a>00359     }
<a name="l00360"></a>00360 <span class="comment"></span>
<a name="l00361"></a>00361 <span class="comment">    /// Release the lock</span>
<a name="l00362"></a><a class="code" href="../../d6/d9d/structtatas__lock.html#75db516e893b599183839850d20b3e14">00362</a> <span class="comment"></span>    <span class="keywordtype">void</span> <a class="code" href="../../d6/d9d/structtatas__lock.html#75db516e893b599183839850d20b3e14">release</a>() {
<a name="l00363"></a>00363         membar_exit();
<a name="l00364"></a>00364         <a class="code" href="../../dd/d93/w__base_8h.html#bcf9bfdb4e430cecbbaf03b144448b60">w_assert1</a>(<a class="code" href="../../d6/d9d/structtatas__lock.html#b41a502e2d757fe0bb284a8efec969d6">is_mine</a>()); <span class="comment">// moved after the membar</span>
<a name="l00365"></a>00365         _holder.bits= NOBODY;
<a name="l00366"></a>00366 <span class="preprocessor">#if W_DEBUG_LEVEL &gt; 0</span>
<a name="l00367"></a>00367 <span class="preprocessor"></span>        {
<a name="l00368"></a>00368             membar_enter(); <span class="comment">// needed for the assert?</span>
<a name="l00369"></a>00369             <a class="code" href="../../dd/d93/w__base_8h.html#bcf9bfdb4e430cecbbaf03b144448b60">w_assert1</a>(!<a class="code" href="../../d6/d9d/structtatas__lock.html#b41a502e2d757fe0bb284a8efec969d6">is_mine</a>());
<a name="l00370"></a>00370         }
<a name="l00371"></a>00371 <span class="preprocessor">#endif</span>
<a name="l00372"></a>00372 <span class="preprocessor"></span>    }
<a name="l00373"></a>00373 <span class="comment"></span>
<a name="l00374"></a>00374 <span class="comment">    /// True if this thread is the lock holder</span>
<a name="l00375"></a><a class="code" href="../../d6/d9d/structtatas__lock.html#b41a502e2d757fe0bb284a8efec969d6">00375</a> <span class="comment"></span>    <span class="keywordtype">bool</span> <a class="code" href="../../d6/d9d/structtatas__lock.html#b41a502e2d757fe0bb284a8efec969d6">is_mine</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> 
<a name="l00376"></a>00376         pthread_equal(_holder.handle, pthread_self()) ? <span class="keyword">true</span> : <span class="keyword">false</span>; }
<a name="l00377"></a>00377 <span class="preprocessor">#undef CASFUNC </span>
<a name="l00378"></a>00378 <span class="preprocessor"></span>};
<a name="l00379"></a>00379 <span class="comment"></span>
<a name="l00380"></a>00380 <span class="comment">/**\brief Wrapper for pthread mutexes, with a queue-based lock API.</span>
<a name="l00381"></a>00381 <span class="comment"> *</span>
<a name="l00382"></a>00382 <span class="comment"> * When the storage manager is configured with the default,</span>
<a name="l00383"></a>00383 <span class="comment"> * --enable-pthread-mutex, this lock uses a Pthreads mutex for the lock.</span>
<a name="l00384"></a>00384 <span class="comment"> * In this case, it is not a true queue-based lock, since</span>
<a name="l00385"></a>00385 <span class="comment"> * release doesn't inform the next node in the queue, and in fact the</span>
<a name="l00386"></a>00386 <span class="comment"> * nodes aren't kept in a queue.</span>
<a name="l00387"></a>00387 <span class="comment"> * It just gives pthread mutexes the same API as the other</span>
<a name="l00388"></a>00388 <span class="comment"> * queue-based locks so that we use the same idioms for</span>
<a name="l00389"></a>00389 <span class="comment"> * critical sections based on different kinds of locks.</span>
<a name="l00390"></a>00390 <span class="comment"> * By configuring with pthreads mutexes implementing this class, the</span>
<a name="l00391"></a>00391 <span class="comment"> * server can spawn any number of threads, regardless of the number</span>
<a name="l00392"></a>00392 <span class="comment"> * of hardware contexts available; threads will block as necessary.</span>
<a name="l00393"></a>00393 <span class="comment"> *</span>
<a name="l00394"></a>00394 <span class="comment"> * When the storage manager is configured with </span>
<a name="l00395"></a>00395 <span class="comment"> * --disable-pthread-mutex, this lock uses an MCS (\ref MCS1) queue-based</span>
<a name="l00396"></a>00396 <span class="comment"> * lock for the lock.</span>
<a name="l00397"></a>00397 <span class="comment"> * In this case, it is a true queue-based lock.</span>
<a name="l00398"></a>00398 <span class="comment"> * By configuring with MCS locks implementing this class, if the</span>
<a name="l00399"></a>00399 <span class="comment"> * server spawn many more threads than hardware contexts, time can be wasted</span>
<a name="l00400"></a>00400 <span class="comment"> * spinning; threads will not block until the operating system (or underlying </span>
<a name="l00401"></a>00401 <span class="comment"> * thread scheduler) determines to block the thread.</span>
<a name="l00402"></a>00402 <span class="comment"> *</span>
<a name="l00403"></a>00403 <span class="comment"> * The idiom for using these locks is</span>
<a name="l00404"></a>00404 <span class="comment"> * that the qnode is on a threads's stack, so the qnode</span>
<a name="l00405"></a>00405 <span class="comment"> * implicitly identifies the owning thread.</span>
<a name="l00406"></a>00406 <span class="comment"> *</span>
<a name="l00407"></a>00407 <span class="comment"> * This allows us to add an is_mine() capability that otherwise</span>
<a name="l00408"></a>00408 <span class="comment"> * the pthread mutexen don't have.</span>
<a name="l00409"></a>00409 <span class="comment"> *</span>
<a name="l00410"></a>00410 <span class="comment"> * Finally, using this class ensures that the pthread_mutex_init/destroy</span>
<a name="l00411"></a>00411 <span class="comment"> * is done (in the --enable-pthread-mutex case).</span>
<a name="l00412"></a>00412 <span class="comment"> *</span>
<a name="l00413"></a>00413 <span class="comment"> *  See also: \ref REFSYNC</span>
<a name="l00414"></a>00414 <span class="comment"> *</span>
<a name="l00415"></a>00415 <span class="comment"> */</span>
<a name="l00416"></a><a class="code" href="../../df/d15/structw__pthread__lock__t.html">00416</a> <span class="keyword">struct </span><a class="code" href="../../df/d15/structw__pthread__lock__t.html">w_pthread_lock_t</a> 
<a name="l00417"></a>00417 {<span class="comment"></span>
<a name="l00418"></a>00418 <span class="comment">    /**\cond skip */</span>
<a name="l00419"></a>00419     <span class="keyword">struct </span>ext_qnode {
<a name="l00420"></a>00420         <a class="code" href="../../df/d15/structw__pthread__lock__t.html">w_pthread_lock_t</a>* _held;
<a name="l00421"></a>00421     };
<a name="l00422"></a>00422 <span class="preprocessor">#define PTHREAD_EXT_QNODE_INITIALIZER { NULL }</span>
<a name="l00423"></a>00423 <span class="preprocessor"></span><span class="preprocessor">#define PTHREAD_EXT_QNODE_INITIALIZE(x) (x)._held =  NULL</span>
<a name="l00424"></a>00424 <span class="preprocessor"></span>
<a name="l00425"></a>00425     <span class="keyword">typedef</span> ext_qnode <span class="keyword">volatile</span>* ext_qnode_ptr;<span class="comment"></span>
<a name="l00426"></a>00426 <span class="comment">    /**\endcond skip */</span>
<a name="l00427"></a>00427 
<a name="l00428"></a>00428 <span class="keyword">private</span>:
<a name="l00429"></a>00429     pthread_mutex_t     _mutex; <span class="comment">// w_pthread_lock_t blocks on this</span><span class="comment"></span>
<a name="l00430"></a>00430 <span class="comment">    /// Holder is this struct if acquire is successful.</span>
<a name="l00431"></a>00431 <span class="comment"></span>    <a class="code" href="../../df/d15/structw__pthread__lock__t.html">w_pthread_lock_t</a> *  _holder;
<a name="l00432"></a>00432 
<a name="l00433"></a>00433 <span class="keyword">public</span>:
<a name="l00434"></a><a class="code" href="../../df/d15/structw__pthread__lock__t.html#bba7c62a5ac2f0c5746433377754abae">00434</a>     <a class="code" href="../../df/d15/structw__pthread__lock__t.html#bba7c62a5ac2f0c5746433377754abae">w_pthread_lock_t</a>() :_holder(0) { pthread_mutex_init(&amp;_mutex, 0); }
<a name="l00435"></a>00435 
<a name="l00436"></a><a class="code" href="../../df/d15/structw__pthread__lock__t.html#86cf586a1228c9ce46dabc77815c3d03">00436</a>     <a class="code" href="../../df/d15/structw__pthread__lock__t.html#86cf586a1228c9ce46dabc77815c3d03">~w_pthread_lock_t</a>() { <a class="code" href="../../dd/d93/w__base_8h.html#bcf9bfdb4e430cecbbaf03b144448b60">w_assert1</a>(!_holder); pthread_mutex_destroy(&amp;_mutex);}
<a name="l00437"></a>00437     <span class="comment"></span>
<a name="l00438"></a>00438 <span class="comment">    /// Returns true if success.</span>
<a name="l00439"></a><a class="code" href="../../df/d15/structw__pthread__lock__t.html#ce47b59547dbf4c5c974e8723d0ea0f2">00439</a> <span class="comment"></span>    <span class="keywordtype">bool</span> <a class="code" href="../../df/d15/structw__pthread__lock__t.html#ce47b59547dbf4c5c974e8723d0ea0f2">attempt</a>(ext_qnode* me) {
<a name="l00440"></a>00440         <span class="keywordflow">if</span>(<a class="code" href="../../df/d15/structw__pthread__lock__t.html#ce47b59547dbf4c5c974e8723d0ea0f2">attempt</a>( *me)) {
<a name="l00441"></a>00441             me-&gt;_held = <span class="keyword">this</span>;
<a name="l00442"></a>00442             _holder = <span class="keyword">this</span>;
<a name="l00443"></a>00443             <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00444"></a>00444         }
<a name="l00445"></a>00445         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00446"></a>00446     }
<a name="l00447"></a>00447 
<a name="l00448"></a>00448 <span class="keyword">private</span>:<span class="comment"></span>
<a name="l00449"></a>00449 <span class="comment">    /// Returns true if success. Helper for attempt(ext_qnode *).</span>
<a name="l00450"></a>00450 <span class="comment"></span>    <span class="keywordtype">bool</span> <a class="code" href="../../df/d15/structw__pthread__lock__t.html#ce47b59547dbf4c5c974e8723d0ea0f2">attempt</a>(ext_qnode &amp; me) {
<a name="l00451"></a>00451         <a class="code" href="../../dd/d93/w__base_8h.html#bcf9bfdb4e430cecbbaf03b144448b60">w_assert1</a>(!<a class="code" href="../../df/d15/structw__pthread__lock__t.html#b573ed809cffc5a74299c1903d909c8a">is_mine</a>(&amp;me));
<a name="l00452"></a>00452         <a class="code" href="../../dd/d93/w__base_8h.html#4b981e571262879b90e6c66658bfa2ff">w_assert0</a>( me._held == 0 );  <span class="comment">// had better not </span>
<a name="l00453"></a>00453         <span class="comment">// be using this qnode for another lock!</span>
<a name="l00454"></a>00454         <span class="keywordflow">return</span> pthread_mutex_trylock(&amp;_mutex) == 0;
<a name="l00455"></a>00455     }
<a name="l00456"></a>00456 
<a name="l00457"></a>00457 <span class="keyword">public</span>:<span class="comment"></span>
<a name="l00458"></a>00458 <span class="comment">    /// Acquire the lock and set the qnode to refer to this lock.</span>
<a name="l00459"></a><a class="code" href="../../df/d15/structw__pthread__lock__t.html#33840cd1e4c8e2863a962d30bb32a9b7">00459</a> <span class="comment"></span>    <span class="keywordtype">void</span>* <a class="code" href="../../df/d15/structw__pthread__lock__t.html#33840cd1e4c8e2863a962d30bb32a9b7">acquire</a>(ext_qnode* me) {
<a name="l00460"></a>00460         <a class="code" href="../../dd/d93/w__base_8h.html#bcf9bfdb4e430cecbbaf03b144448b60">w_assert1</a>(!<a class="code" href="../../df/d15/structw__pthread__lock__t.html#b573ed809cffc5a74299c1903d909c8a">is_mine</a>(me));
<a name="l00461"></a>00461         <a class="code" href="../../dd/d93/w__base_8h.html#bcf9bfdb4e430cecbbaf03b144448b60">w_assert1</a>( me-&gt;_held == 0 );  <span class="comment">// had better not </span>
<a name="l00462"></a>00462         <span class="comment">// be using this qnode for another lock!</span>
<a name="l00463"></a>00463         pthread_mutex_lock(&amp;_mutex);
<a name="l00464"></a>00464         me-&gt;_held = <span class="keyword">this</span>;
<a name="l00465"></a>00465         _holder = <span class="keyword">this</span>;
<a name="l00466"></a>00466 <span class="preprocessor">#if W_DEBUG_LEVEL &gt; 0</span>
<a name="l00467"></a>00467 <span class="preprocessor"></span>        {
<a name="l00468"></a>00468             membar_enter(); <span class="comment">// needed for the assert</span>
<a name="l00469"></a>00469             <a class="code" href="../../dd/d93/w__base_8h.html#bcf9bfdb4e430cecbbaf03b144448b60">w_assert1</a>(<a class="code" href="../../df/d15/structw__pthread__lock__t.html#b573ed809cffc5a74299c1903d909c8a">is_mine</a>(me)); <span class="comment">// TODO: change to assert2</span>
<a name="l00470"></a>00470         }
<a name="l00471"></a>00471 <span class="preprocessor">#endif</span>
<a name="l00472"></a>00472 <span class="preprocessor"></span>        <span class="keywordflow">return</span> 0;
<a name="l00473"></a>00473     }
<a name="l00474"></a>00474 <span class="comment"></span>
<a name="l00475"></a>00475 <span class="comment">    /// Release the lock and clear the qnode.</span>
<a name="l00476"></a><a class="code" href="../../df/d15/structw__pthread__lock__t.html#8df4fbb892aee8252f772811fd9d205c">00476</a> <span class="comment"></span>    <span class="keywordtype">void</span> <a class="code" href="../../df/d15/structw__pthread__lock__t.html#8df4fbb892aee8252f772811fd9d205c">release</a>(ext_qnode &amp;me) { <a class="code" href="../../df/d15/structw__pthread__lock__t.html#8df4fbb892aee8252f772811fd9d205c">release</a>(&amp;me); }
<a name="l00477"></a>00477 <span class="comment"></span>
<a name="l00478"></a>00478 <span class="comment">    /// Release the lock and clear the qnode.</span>
<a name="l00479"></a><a class="code" href="../../df/d15/structw__pthread__lock__t.html#ae18443129399074d07b2f52fa002fc7">00479</a> <span class="comment"></span>    <span class="keywordtype">void</span> <a class="code" href="../../df/d15/structw__pthread__lock__t.html#8df4fbb892aee8252f772811fd9d205c">release</a>(ext_qnode_ptr me) { 
<a name="l00480"></a>00480         <span class="comment">// assert is_mine:</span>
<a name="l00481"></a>00481         <a class="code" href="../../dd/d93/w__base_8h.html#bcf9bfdb4e430cecbbaf03b144448b60">w_assert1</a>( _holder == me-&gt;_held ); 
<a name="l00482"></a>00482         <a class="code" href="../../dd/d93/w__base_8h.html#bcf9bfdb4e430cecbbaf03b144448b60">w_assert1</a>(me-&gt;_held == <span class="keyword">this</span>); 
<a name="l00483"></a>00483          me-&gt;_held = 0; 
<a name="l00484"></a>00484         _holder = 0;
<a name="l00485"></a>00485         pthread_mutex_unlock(&amp;_mutex); 
<a name="l00486"></a>00486 <span class="preprocessor">#if W_DEBUG_LEVEL &gt; 10</span>
<a name="l00487"></a>00487 <span class="preprocessor"></span>        <span class="comment">// This is racy since the containing structure could</span>
<a name="l00488"></a>00488         <span class="comment">// have been freed by the time we do this check.  Thus,</span>
<a name="l00489"></a>00489         <span class="comment">// we'll remove it.</span>
<a name="l00490"></a>00490         {
<a name="l00491"></a>00491             membar_enter(); <span class="comment">// needed for the assertions?</span>
<a name="l00492"></a>00492             <a class="code" href="../../df/d15/structw__pthread__lock__t.html">w_pthread_lock_t</a> *h =  _holder;
<a name="l00493"></a>00493             <a class="code" href="../../df/d15/structw__pthread__lock__t.html">w_pthread_lock_t</a> *m =  me-&gt;_held;
<a name="l00494"></a>00494             <a class="code" href="../../dd/d93/w__base_8h.html#bcf9bfdb4e430cecbbaf03b144448b60">w_assert1</a>( (h==NULL &amp;&amp; m==NULL)
<a name="l00495"></a>00495                 || (h  != m) );
<a name="l00496"></a>00496         }
<a name="l00497"></a>00497 <span class="preprocessor">#endif</span>
<a name="l00498"></a>00498 <span class="preprocessor"></span>    }
<a name="l00499"></a>00499 <span class="comment"></span>
<a name="l00500"></a>00500 <span class="comment">    /**\brief Return true if this thread holds the lock.</span>
<a name="l00501"></a>00501 <span class="comment">     *</span>
<a name="l00502"></a>00502 <span class="comment">     * This method doesn't actually check for this pthread</span>
<a name="l00503"></a>00503 <span class="comment">     * holding the lock, but it checks that the qnode reference</span>
<a name="l00504"></a>00504 <span class="comment">     * is to this lock.  </span>
<a name="l00505"></a>00505 <span class="comment">     * The idiom for using these locks is</span>
<a name="l00506"></a>00506 <span class="comment">     * that the qnode is on a threads's stack, so the qnode</span>
<a name="l00507"></a>00507 <span class="comment">     * implicitly identifies the owning thread.</span>
<a name="l00508"></a>00508 <span class="comment">     */</span>
<a name="l00509"></a>00509     
<a name="l00510"></a><a class="code" href="../../df/d15/structw__pthread__lock__t.html#b573ed809cffc5a74299c1903d909c8a">00510</a>     <span class="keywordtype">bool</span> <a class="code" href="../../df/d15/structw__pthread__lock__t.html#b573ed809cffc5a74299c1903d909c8a">is_mine</a>(ext_qnode* me)<span class="keyword"> const </span>{ 
<a name="l00511"></a>00511        <span class="keywordflow">if</span>( me-&gt;_held == <span class="keyword">this</span> ) {
<a name="l00512"></a>00512            <span class="comment">// only valid if is_mine </span>
<a name="l00513"></a>00513           <a class="code" href="../../dd/d93/w__base_8h.html#bcf9bfdb4e430cecbbaf03b144448b60">w_assert1</a>( _holder == me-&gt;_held ); 
<a name="l00514"></a>00514           <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00515"></a>00515        }
<a name="l00516"></a>00516        <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00517"></a>00517     }
<a name="l00518"></a>00518 };
<a name="l00519"></a>00519 <span class="comment"></span>
<a name="l00520"></a>00520 <span class="comment">/**\def USE_PTHREAD_MUTEX</span>
<a name="l00521"></a>00521 <span class="comment"> * \brief If defined and value is 1, use pthread-based mutex for queue_based_lock_t</span>
<a name="l00522"></a>00522 <span class="comment"> *</span>
<a name="l00523"></a>00523 <span class="comment"> * \details</span>
<a name="l00524"></a>00524 <span class="comment"> * The Shore-MT release contained alternatives for scalable locks in</span>
<a name="l00525"></a>00525 <span class="comment"> * certain places in the storage manager; it was released with</span>
<a name="l00526"></a>00526 <span class="comment"> * these locks replaced by pthreads-based mutexes.</span>
<a name="l00527"></a>00527 <span class="comment"> *</span>
<a name="l00528"></a>00528 <span class="comment"> * You can disable the use of pthreads-based mutexes and use the</span>
<a name="l00529"></a>00529 <span class="comment"> * mcs-based locks by configuring with --disable-pthread-mutex.</span>
<a name="l00530"></a>00530 <span class="comment"> */</span>
<a name="l00531"></a>00531 <span class="comment"></span>
<a name="l00532"></a>00532 <span class="comment">/**\defgroup SYNCPRIM Synchronization Primitives</span>
<a name="l00533"></a>00533 <span class="comment"> *\ingroup UNUSED </span>
<a name="l00534"></a>00534 <span class="comment"> *</span>
<a name="l00535"></a>00535 <span class="comment"> * sthread/sthread.h: As distributed, a queue-based lock </span>
<a name="l00536"></a>00536 <span class="comment"> * is a w_pthread_lock_t,</span>
<a name="l00537"></a>00537 <span class="comment"> * which is a wrapper around a pthread lock to give it a queue-based-lock API.</span>
<a name="l00538"></a>00538 <span class="comment"> * True queue-based locks are not used, nor are time-published</span>
<a name="l00539"></a>00539 <span class="comment"> * locks.</span>
<a name="l00540"></a>00540 <span class="comment"> * Code for these implementations is included for future </span>
<a name="l00541"></a>00541 <span class="comment"> * experimentation, along with typedefs that should allow</span>
<a name="l00542"></a>00542 <span class="comment"> * easy substitution, as they all should have the same API.</span>
<a name="l00543"></a>00543 <span class="comment"> *</span>
<a name="l00544"></a>00544 <span class="comment"> * We don't offer the spin implementations at the moment.</span>
<a name="l00545"></a>00545 <span class="comment"> */</span>
<a name="l00546"></a>00546 <span class="comment">/*</span>
<a name="l00547"></a>00547 <span class="comment"> * These typedefs are included to allow substitution at some  point.</span>
<a name="l00548"></a>00548 <span class="comment"> * Where there is a preference, the code should use the appropriate typedef.</span>
<a name="l00549"></a>00549 <span class="comment"> */</span>
<a name="l00550"></a>00550 
<a name="l00551"></a><a class="code" href="../../d3/de1/sthread_8h.html#517300db74e2ebb84a053be43a0dc6ef">00551</a> <span class="keyword">typedef</span> <a class="code" href="../../df/d15/structw__pthread__lock__t.html">w_pthread_lock_t</a> <a class="code" href="../../df/d15/structw__pthread__lock__t.html">queue_based_block_lock_t</a>; <span class="comment">// blocking impl always ok</span>
<a name="l00552"></a><a class="code" href="../../d3/de1/sthread_8h.html#e0a26cced5a9270e984695c10a600470">00552</a> <span class="preprocessor">#define QUEUE_BLOCK_EXT_QNODE_INITIALIZER PTHREAD_EXT_QNODE_INITIALIZER</span>
<a name="l00553"></a>00553 <span class="preprocessor"></span><span class="comment">// non-static initialize:</span>
<a name="l00554"></a><a class="code" href="../../d3/de1/sthread_8h.html#dc551a68a446028b54e78ec02a1f738c">00554</a> <span class="preprocessor">#define QUEUE_BLOCK_EXT_QNODE_INITIALIZE(x) x._held = NULL</span>
<a name="l00555"></a>00555 <span class="preprocessor"></span>
<a name="l00556"></a>00556 <span class="preprocessor">#if defined(USE_PTHREAD_MUTEX) &amp;&amp; USE_PTHREAD_MUTEX==1</span>
<a name="l00557"></a>00557 <span class="preprocessor"></span><span class="keyword">typedef</span> <a class="code" href="../../df/d15/structw__pthread__lock__t.html">w_pthread_lock_t</a> <a class="code" href="../../d3/de1/sthread_8h.html#9e60597704a7de8ea026df4dec8eb757">queue_based_spin_lock_t</a>; <span class="comment">// spin impl preferred</span>
<a name="l00558"></a>00558 <span class="keyword">typedef</span> <a class="code" href="../../df/d15/structw__pthread__lock__t.html">w_pthread_lock_t</a> <a class="code" href="../../d3/de1/sthread_8h.html#4ba617a3e4b8f1e9f9b534cc9f4f0045">queue_based_lock_t</a>; <span class="comment">// might want to use spin impl</span>
<a name="l00559"></a>00559 <span class="preprocessor">#define QUEUE_SPIN_EXT_QNODE_INITIALIZER PTHREAD_EXT_QNODE_INITIALIZER</span>
<a name="l00560"></a>00560 <span class="preprocessor"></span><span class="preprocessor">#define QUEUE_EXT_QNODE_INITIALIZER      PTHREAD_EXT_QNODE_INITIALIZER</span>
<a name="l00561"></a>00561 <span class="preprocessor"></span><span class="comment">// non-static initialize:</span>
<a name="l00562"></a>00562 <span class="preprocessor">#define QUEUE_EXT_QNODE_INITIALIZE(x) x._held = NULL;</span>
<a name="l00563"></a>00563 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00564"></a>00564 <span class="preprocessor"></span><span class="preprocessor">#include &lt;mcs_lock.h&gt;</span>
<a name="l00565"></a><a class="code" href="../../d3/de1/sthread_8h.html#9e60597704a7de8ea026df4dec8eb757">00565</a> <span class="keyword">typedef</span> mcs_lock queue_based_spin_lock_t; <span class="comment">// spin preferred</span>
<a name="l00566"></a><a class="code" href="../../d3/de1/sthread_8h.html#4ba617a3e4b8f1e9f9b534cc9f4f0045">00566</a> <span class="keyword">typedef</span> mcs_lock queue_based_lock_t;
<a name="l00567"></a><a class="code" href="../../d3/de1/sthread_8h.html#c4c754e316104494c1d7df694f648989">00567</a> <span class="preprocessor">#define QUEUE_SPIN_EXT_QNODE_INITIALIZER MCS_EXT_QNODE_INITIALIZER</span>
<a name="l00568"></a><a class="code" href="../../d3/de1/sthread_8h.html#f065cd961d20e853aff90403e01550fe">00568</a> <span class="preprocessor"></span><span class="preprocessor">#define QUEUE_EXT_QNODE_INITIALIZER      MCS_EXT_QNODE_INITIALIZER</span>
<a name="l00569"></a>00569 <span class="preprocessor"></span><span class="comment">// non-static initialize:</span>
<a name="l00570"></a><a class="code" href="../../d3/de1/sthread_8h.html#6e9f99b6a4c3bdd71258cdda158fa28f">00570</a> <span class="preprocessor">#define QUEUE_EXT_QNODE_INITIALIZE(x) MCS_EXT_QNODE_INITIALIZE(x)</span>
<a name="l00571"></a>00571 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00572"></a>00572 <span class="preprocessor"></span>
<a name="l00573"></a>00573 <span class="preprocessor">#ifndef SRWLOCK_H</span>
<a name="l00574"></a>00574 <span class="preprocessor"></span><span class="preprocessor">#include &lt;srwlock.h&gt;</span>
<a name="l00575"></a>00575 <span class="preprocessor">#endif</span>
<a name="l00576"></a>00576 <span class="preprocessor"></span><span class="comment"></span>
<a name="l00577"></a>00577 <span class="comment">/**\brief A multiple-reader/single-writer lock based on pthreads (blocking)</span>
<a name="l00578"></a>00578 <span class="comment"> *</span>
<a name="l00579"></a>00579 <span class="comment"> * Use this to protect data structures that get hammered by</span>
<a name="l00580"></a>00580 <span class="comment"> *  reads and where updates are very rare.</span>
<a name="l00581"></a>00581 <span class="comment"> * It is used in the storage manager by the histograms (histo.cpp), </span>
<a name="l00582"></a>00582 <span class="comment"> * and in place of some mutexen, where strict exclusion isn't required.</span>
<a name="l00583"></a>00583 <span class="comment"> *</span>
<a name="l00584"></a>00584 <span class="comment"> * This lock is used in the storage manager by the checkpoint thread</span>
<a name="l00585"></a>00585 <span class="comment"> * (the only acquire-writer) and other threads to be sure they don't</span>
<a name="l00586"></a>00586 <span class="comment"> * do certain nasty things when a checkpoint is going on.</span>
<a name="l00587"></a>00587 <span class="comment"> *</span>
<a name="l00588"></a>00588 <span class="comment"> * The idiom for using these locks is</span>
<a name="l00589"></a>00589 <span class="comment"> * that the qnode is on a threads's stack, so the qnode</span>
<a name="l00590"></a>00590 <span class="comment"> * implicitly identifies the owning thread.</span>
<a name="l00591"></a>00591 <span class="comment"> *</span>
<a name="l00592"></a>00592 <span class="comment"> *  See also: \ref REFSYNC</span>
<a name="l00593"></a>00593 <span class="comment"> *</span>
<a name="l00594"></a>00594 <span class="comment"> */</span>
<a name="l00595"></a><a class="code" href="../../d5/d19/structocc__rwlock.html">00595</a> <span class="keyword">struct </span><a class="code" href="../../d5/d19/structocc__rwlock.html">occ_rwlock</a> {
<a name="l00596"></a>00596     <a class="code" href="../../d5/d19/structocc__rwlock.html#89e3bb95016056fb94f8cbda6cb4435c">occ_rwlock</a>();
<a name="l00597"></a>00597     <a class="code" href="../../d5/d19/structocc__rwlock.html#75754e5a2245ce095ebd6aca8fa3faf2">~occ_rwlock</a>();<span class="comment"></span>
<a name="l00598"></a>00598 <span class="comment">    /// The normal way to acquire a read lock.</span>
<a name="l00599"></a>00599 <span class="comment"></span>    <span class="keywordtype">void</span> <a class="code" href="../../d5/d19/structocc__rwlock.html#f731bb06dbca210e9725ebfdbadf6385">acquire_read</a>();<span class="comment"></span>
<a name="l00600"></a>00600 <span class="comment">    /// The normal way to release a read lock.</span>
<a name="l00601"></a>00601 <span class="comment"></span>    <span class="keywordtype">void</span> <a class="code" href="../../d5/d19/structocc__rwlock.html#112c750d38b4f00dc0eff8f71d3d716f">release_read</a>();<span class="comment"></span>
<a name="l00602"></a>00602 <span class="comment">    /// The normal way to acquire a write lock.</span>
<a name="l00603"></a>00603 <span class="comment"></span>    <span class="keywordtype">void</span> <a class="code" href="../../d5/d19/structocc__rwlock.html#b29b54a62e5aaeb1d5eba9ec9d7521cd">acquire_write</a>();<span class="comment"></span>
<a name="l00604"></a>00604 <span class="comment">    /// The normal way to release a write lock.</span>
<a name="l00605"></a>00605 <span class="comment"></span>    <span class="keywordtype">void</span> <a class="code" href="../../d5/d19/structocc__rwlock.html#847b9e445223344dc78406ca06187e6d">release_write</a>();
<a name="l00606"></a>00606 <span class="comment"></span>
<a name="l00607"></a>00607 <span class="comment">    /**\cond skip */</span><span class="comment"></span>
<a name="l00608"></a>00608 <span class="comment">    /// Exposed for critical_section&lt;&gt;. Do not use directly.</span>
<a name="l00609"></a>00609 <span class="comment"></span>    <span class="keyword">struct </span>occ_rlock {
<a name="l00610"></a>00610         <a class="code" href="../../d5/d19/structocc__rwlock.html">occ_rwlock</a>* _lock;
<a name="l00611"></a>00611         <span class="keywordtype">void</span> acquire() { _lock-&gt;acquire_read(); }
<a name="l00612"></a>00612         <span class="keywordtype">void</span> release() { _lock-&gt;release_read(); }
<a name="l00613"></a>00613     };<span class="comment"></span>
<a name="l00614"></a>00614 <span class="comment">    /// Exposed for critical_section&lt;&gt;. Do not use directly.</span>
<a name="l00615"></a>00615 <span class="comment"></span>    <span class="keyword">struct </span>occ_wlock {
<a name="l00616"></a>00616         <a class="code" href="../../d5/d19/structocc__rwlock.html">occ_rwlock</a>* _lock;
<a name="l00617"></a>00617         <span class="keywordtype">void</span> acquire() { _lock-&gt;acquire_write(); }
<a name="l00618"></a>00618         <span class="keywordtype">void</span> release() { _lock-&gt;release_write(); }
<a name="l00619"></a>00619     };
<a name="l00620"></a>00620 <span class="comment"></span>
<a name="l00621"></a>00621 <span class="comment">    /// Exposed for the latch manager.. Do not use directly.</span>
<a name="l00622"></a>00622 <span class="comment"></span>    occ_rlock *read_lock() { <span class="keywordflow">return</span> &amp;_read_lock; }<span class="comment"></span>
<a name="l00623"></a>00623 <span class="comment">    /// Exposed for the latch manager.. Do not use directly.</span>
<a name="l00624"></a>00624 <span class="comment"></span>    occ_wlock *write_lock() { <span class="keywordflow">return</span> &amp;_write_lock; }<span class="comment"></span>
<a name="l00625"></a>00625 <span class="comment">    /**\endcond skip */</span>
<a name="l00626"></a>00626 <span class="keyword">private</span>:
<a name="l00627"></a>00627     <span class="keyword">enum</span> { WRITER=1, READER=2 };
<a name="l00628"></a>00628     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="keyword">volatile</span> _active_count;
<a name="l00629"></a>00629     occ_rlock _read_lock;
<a name="l00630"></a>00630     occ_wlock _write_lock;
<a name="l00631"></a>00631 
<a name="l00632"></a>00632     pthread_mutex_t _read_write_mutex; <span class="comment">// paired w/ _read_cond, _write_cond</span>
<a name="l00633"></a>00633     pthread_cond_t _read_cond; <span class="comment">// paired w/ _read_write_mutex</span>
<a name="l00634"></a>00634     pthread_cond_t _write_cond; <span class="comment">// paired w/ _read_write_mutex</span>
<a name="l00635"></a>00635 };
<a name="l00636"></a>00636 
<a name="l00637"></a><a class="code" href="../../d3/de1/sthread_8h.html#5351774f5b76071d2c0b4a671eedfa2e">00637</a> <span class="keyword">typedef</span> <a class="code" href="../../dc/d68/classw__list__t.html">w_list_t&lt;sthread_t, queue_based_lock_t&gt;</a>        <a class="code" href="../../dc/d68/classw__list__t.html">sthread_list_t</a>;
<a name="l00638"></a>00638 
<a name="l00639"></a>00639 <span class="comment"></span>
<a name="l00640"></a>00640 <span class="comment">/**\brief Thread class for all threads that use the Shore Storage Manager.</span>
<a name="l00641"></a>00641 <span class="comment"> *  </span>
<a name="l00642"></a>00642 <span class="comment"> *  All threads that perform \b any work on behalf of the storage</span>
<a name="l00643"></a>00643 <span class="comment"> *  manager or call any storage manager API \b must be an sthread_t or</span>
<a name="l00644"></a>00644 <span class="comment"> *  a class derived from sthread_t.</span>
<a name="l00645"></a>00645 <span class="comment"> *</span>
<a name="l00646"></a>00646 <span class="comment"> *  Storage manager threads use block/unblock methods provided by</span>
<a name="l00647"></a>00647 <span class="comment"> *  sthread, and use thread-local storage (data attributes of</span>
<a name="l00648"></a>00648 <span class="comment"> *  sthread_t).</span>
<a name="l00649"></a>00649 <span class="comment"> *</span>
<a name="l00650"></a>00650 <span class="comment"> *  This class also provides an os-independent API for file-system</span>
<a name="l00651"></a>00651 <span class="comment"> *  calls (open, read, write, close, etc.) used by the storage manager.</span>
<a name="l00652"></a>00652 <span class="comment"> *</span>
<a name="l00653"></a>00653 <span class="comment"> *  This class is a fairly thin layer over pthreads.  Client threads</span>
<a name="l00654"></a>00654 <span class="comment"> *  may use pthread synchronization primitives. </span>
<a name="l00655"></a>00655 <span class="comment"> */</span>
<a name="l00656"></a><a class="code" href="../../dd/ded/classsthread__t.html">00656</a> <span class="keyword">class </span><a class="code" href="../../dd/ded/classsthread__t.html">sthread_t</a> : <span class="keyword">public</span> sthread_named_base_t  
<a name="l00657"></a>00657 {
<a name="l00658"></a><a class="code" href="../../dd/ded/classsthread__t.html#68221a80acba89f72fed7dea6e8d16a4">00658</a>     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="../../d2/d33/classsthread__init__t.html">sthread_init_t</a>;
<a name="l00659"></a><a class="code" href="../../dd/ded/classsthread__t.html#777e903c78d7fdbabcf0eb63a1ae67e3">00659</a>     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="../../dd/ded/classsthread__t.html#777e903c78d7fdbabcf0eb63a1ae67e3">sthread_main_t</a>;
<a name="l00660"></a>00660     <span class="comment">/* For access to block() and unblock() */</span>
<a name="l00661"></a><a class="code" href="../../dd/ded/classsthread__t.html#be8b725daea42cc8a80fb77abd293706">00661</a>     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="../../d5/d5b/classlatch__t.html">latch_t</a>;
<a name="l00662"></a>00662     <span class="comment">/* For access to I/O stats */</span>
<a name="l00663"></a>00663 
<a name="l00664"></a>00664 
<a name="l00665"></a>00665 <span class="keyword">public</span>:
<a name="l00666"></a>00666     <span class="keyword">static</span> <span class="keywordtype">void</span>  <a class="code" href="../../dd/ded/classsthread__t.html#2391a6a17b5a946f44c811ffe775b341">initialize_sthreads_package</a>();
<a name="l00667"></a>00667 
<a name="l00668"></a><a class="code" href="../../dd/ded/classsthread__t.html#fe28f0ed447cb4e0b554c9cd402a414e">00668</a>     <span class="keyword">enum</span> <a class="code" href="../../dd/ded/classsthread__t.html#fe28f0ed447cb4e0b554c9cd402a414e">status_t</a> {
<a name="l00669"></a>00669         t_defunct,    <span class="comment">// thread has terminated</span>
<a name="l00670"></a>00670         t_virgin,    <span class="comment">// thread hasn't started yet    </span>
<a name="l00671"></a>00671         t_ready,    <span class="comment">// thread is ready to run</span>
<a name="l00672"></a>00672         t_running,    <span class="comment">// when me() is this thread </span>
<a name="l00673"></a>00673         t_blocked,      <span class="comment">// thread is blocked on something</span>
<a name="l00674"></a>00674         t_boot        <span class="comment">// system boot</span>
<a name="l00675"></a>00675     };
<a name="l00676"></a><a class="code" href="../../dd/ded/classsthread__t.html#dd74de93131dceafcf1c27594503b9d0">00676</a>     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="../../dd/ded/classsthread__t.html#dd74de93131dceafcf1c27594503b9d0">status_strings</a>[];
<a name="l00677"></a>00677 
<a name="l00678"></a><a class="code" href="../../dd/ded/classsthread__t.html#ed260674d3651a8a3e1b1d3331f5d4db">00678</a>     <span class="keyword">enum</span> <a class="code" href="../../dd/ded/classsthread__t.html#ed260674d3651a8a3e1b1d3331f5d4db">priority_t</a> {
<a name="l00679"></a>00679         t_time_critical = 1,
<a name="l00680"></a>00680         t_regular    = 0,
<a name="l00681"></a>00681         max_priority    = t_time_critical,
<a name="l00682"></a>00682         min_priority    = t_regular
<a name="l00683"></a>00683     };
<a name="l00684"></a><a class="code" href="../../dd/ded/classsthread__t.html#fb0cf4c9c52eddb2548e63b5467a98f5">00684</a>     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="../../dd/ded/classsthread__t.html#fb0cf4c9c52eddb2548e63b5467a98f5">priority_strings</a>[];
<a name="l00685"></a>00685 
<a name="l00686"></a>00686     <span class="comment">/* Default stack size for a thread */</span>
<a name="l00687"></a>00687     <span class="keyword">enum</span> { default_stack = 64*1024 };
<a name="l00688"></a>00688 
<a name="l00689"></a>00689     <span class="comment">/*</span>
<a name="l00690"></a>00690 <span class="comment">     *  Class member variables</span>
<a name="l00691"></a>00691 <span class="comment">     */</span>
<a name="l00692"></a><a class="code" href="../../dd/ded/classsthread__t.html#ef5900eaa7e9cec08ba8f5f9f8886d92">00692</a>     <span class="keywordtype">void</span>*             <a class="code" href="../../dd/ded/classsthread__t.html#ef5900eaa7e9cec08ba8f5f9f8886d92">user</a>;    <span class="comment">// user can use this </span>
<a name="l00693"></a><a class="code" href="../../dd/ded/classsthread__t.html#5894b828edcf0a95fcec004e2ec280c9">00693</a>     <span class="keyword">const</span> id_t        <a class="code" href="../../dd/ded/classsthread__t.html#5894b828edcf0a95fcec004e2ec280c9">id</a>;
<a name="l00694"></a>00694 
<a name="l00695"></a>00695     <span class="comment">// max_os_file_size is used by the sm and set in</span>
<a name="l00696"></a>00696     <span class="comment">// static initialization of sthreads (sthread_init_t in sthread.cpp)</span>
<a name="l00697"></a><a class="code" href="../../dd/ded/classsthread__t.html#112315bf994c26006d4561314d78efc5">00697</a>     <span class="keyword">static</span> w_base_t::int8_t     <a class="code" href="../../dd/ded/classsthread__t.html#112315bf994c26006d4561314d78efc5">max_os_file_size</a>;
<a name="l00698"></a>00698 
<a name="l00699"></a>00699 <span class="keyword">private</span>:
<a name="l00700"></a>00700 
<a name="l00701"></a>00701     <span class="comment">// ASSUMES WE ALREADY LOCKED self-&gt;_wait_lock</span>
<a name="l00702"></a>00702     <span class="keyword">static</span> <a class="code" href="../../db/dc7/classw__rc__t.html#26d19aeb714443a307b3370cd8b57fc4">w_rc_t::errcode_t</a>        _block(
<a name="l00703"></a>00703                             <a class="code" href="../../d8/d69/smthread_8h.html#cf834513ff7853bf96601820e038ec9a">timeout_in_ms</a>          timeout = WAIT_FOREVER,
<a name="l00704"></a>00704                             <span class="keyword">const</span> <span class="keywordtype">char</span>* <span class="keyword">const</span>      caller = 0,
<a name="l00705"></a>00705                             <span class="keyword">const</span> <span class="keywordtype">void</span> *           <span class="keywordtype">id</span> = 0);
<a name="l00706"></a>00706 
<a name="l00707"></a>00707     <span class="keyword">static</span> <a class="code" href="../../db/dc7/classw__rc__t.html#26d19aeb714443a307b3370cd8b57fc4">w_rc_t::errcode_t</a>        _block(
<a name="l00708"></a>00708                             pthread_mutex_t        *lock, 
<a name="l00709"></a>00709                             <a class="code" href="../../d8/d69/smthread_8h.html#cf834513ff7853bf96601820e038ec9a">timeout_in_ms</a>          timeout = WAIT_FOREVER,
<a name="l00710"></a>00710                             sthread_list_t*        list = 0,
<a name="l00711"></a>00711                             <span class="keyword">const</span> <span class="keywordtype">char</span>* <span class="keyword">const</span>      caller = 0,
<a name="l00712"></a>00712                             <span class="keyword">const</span> <span class="keywordtype">void</span> *           <span class="keywordtype">id</span> = 0);
<a name="l00713"></a>00713 
<a name="l00714"></a>00714     <a class="code" href="../../db/dc7/classw__rc__t.html">w_rc_t</a>               _unblock(<a class="code" href="../../db/dc7/classw__rc__t.html#26d19aeb714443a307b3370cd8b57fc4">w_rc_t::errcode_t</a> e);
<a name="l00715"></a>00715 
<a name="l00716"></a>00716 <span class="keyword">public</span>:
<a name="l00717"></a>00717     <span class="keyword">static</span> <span class="keywordtype">void</span>          <a class="code" href="../../dd/ded/classsthread__t.html#1ad50e311620d5a4c23d615539a98338">timeout_to_timespec</a>(<a class="code" href="../../d8/d69/smthread_8h.html#cf834513ff7853bf96601820e038ec9a">timeout_in_ms</a> timeout, 
<a name="l00718"></a>00718                                              <span class="keyword">struct</span> timespec &amp;when);
<a name="l00719"></a>00719     <a class="code" href="../../db/dc7/classw__rc__t.html">w_rc_t</a>               <a class="code" href="../../dd/ded/classsthread__t.html#fdce57ecabe9912ad6dcc1d7f5fe41d3">unblock</a>(<a class="code" href="../../db/dc7/classw__rc__t.html#26d19aeb714443a307b3370cd8b57fc4">w_rc_t::errcode_t</a> e);
<a name="l00720"></a>00720     <span class="keyword">static</span> <a class="code" href="../../db/dc7/classw__rc__t.html">w_rc_t</a>        <a class="code" href="../../dd/ded/classsthread__t.html#3a6a960ab5eff34cdf2ac44e35dcac98">block</a>(
<a name="l00721"></a>00721                             pthread_mutex_t        &amp;lock,
<a name="l00722"></a>00722                             <a class="code" href="../../d8/d69/smthread_8h.html#cf834513ff7853bf96601820e038ec9a">timeout_in_ms</a>          timeout = WAIT_FOREVER,
<a name="l00723"></a>00723                             sthread_list_t*        list = 0,
<a name="l00724"></a>00724                             <span class="keyword">const</span> <span class="keywordtype">char</span>* <span class="keyword">const</span>      caller = 0,
<a name="l00725"></a>00725                             <span class="keyword">const</span> <span class="keywordtype">void</span> *           <span class="keywordtype">id</span> = 0);
<a name="l00726"></a>00726     <span class="keyword">static</span> <a class="code" href="../../db/dc7/classw__rc__t.html#26d19aeb714443a307b3370cd8b57fc4">w_rc_t::errcode_t</a>       <a class="code" href="../../dd/ded/classsthread__t.html#3a6a960ab5eff34cdf2ac44e35dcac98">block</a>(int4_t  timeout = WAIT_FOREVER);
<a name="l00727"></a>00727 
<a name="l00728"></a>00728     <span class="keyword">virtual</span> <span class="keywordtype">void</span>        <a class="code" href="../../dd/ded/classsthread__t.html#7548ee0560a2606183945c0e0f775586">_dump</a>(ostream &amp;) <span class="keyword">const</span>; <span class="comment">// to be over-ridden</span>
<a name="l00729"></a>00729 
<a name="l00730"></a>00730     <span class="comment">// these traverse all threads</span>
<a name="l00731"></a>00731     <span class="keyword">static</span> <span class="keywordtype">void</span>       <a class="code" href="../../dd/ded/classsthread__t.html#93592b0330aecf53fd64fd4d0945dfa5">dumpall</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *, ostream &amp;);
<a name="l00732"></a>00732     <span class="keyword">static</span> <span class="keywordtype">void</span>       <a class="code" href="../../dd/ded/classsthread__t.html#93592b0330aecf53fd64fd4d0945dfa5">dumpall</a>(ostream &amp;);
<a name="l00733"></a>00733 
<a name="l00734"></a>00734     <span class="keyword">static</span> <span class="keywordtype">void</span>       dump_io(ostream &amp;);
<a name="l00735"></a>00735     <span class="keyword">static</span> <span class="keywordtype">void</span>       dump_event(ostream &amp;);
<a name="l00736"></a>00736 
<a name="l00737"></a>00737     <span class="keyword">static</span> <span class="keywordtype">void</span>       <a class="code" href="../../dd/ded/classsthread__t.html#ab7a8186cb9cc1afcf6b08a7cb99a52e">dump_stats</a>(ostream &amp;);
<a name="l00738"></a>00738     <span class="keyword">static</span> <span class="keywordtype">void</span>       <a class="code" href="../../dd/ded/classsthread__t.html#cadcaed7f731151dd89dbf48c00d90c0">reset_stats</a>();
<a name="l00739"></a>00739 <span class="comment"></span>
<a name="l00740"></a>00740 <span class="comment">    /// Collect a row of a virtual table. One row per thread.</span>
<a name="l00741"></a>00741 <span class="comment">    /// Subclasses override this.</span>
<a name="l00742"></a>00742 <span class="comment"></span>    <span class="keyword">virtual</span> <span class="keywordtype">void</span>      <a class="code" href="../../dd/ded/classsthread__t.html#7b420df74d4dbdc4695b1714d7705f1d">vtable_collect</a>(<a class="code" href="../../db/d4a/classvtable__row__t.html">vtable_row_t</a> &amp;); <span class="comment">// to be over-ridden</span><span class="comment"></span>
<a name="l00743"></a>00743 <span class="comment">    /// Stuff the attribute names in this row.</span>
<a name="l00744"></a>00744 <span class="comment"></span>    <span class="keyword">static</span>  <span class="keywordtype">void</span>      <a class="code" href="../../dd/ded/classsthread__t.html#4cdf9eecfe1d6c087372d20383f7ca90">vtable_collect_names</a>(<a class="code" href="../../db/d4a/classvtable__row__t.html">vtable_row_t</a> &amp;); <span class="comment">// to be over-ridden</span>
<a name="l00745"></a>00745 <span class="comment"></span>
<a name="l00746"></a>00746 <span class="comment">    /// Collect an entire table, one row per thread that the sthreads package</span>
<a name="l00747"></a>00747 <span class="comment">    /// knows about. If attr_names_too is true, the first row will be</span>
<a name="l00748"></a>00748 <span class="comment">    /// attribute names.</span>
<a name="l00749"></a>00749 <span class="comment"></span>    <span class="keyword">static</span> <span class="keywordtype">int</span>        <a class="code" href="../../dd/ded/classsthread__t.html#68b93fde4e0932e312ea7aa65fdc005a">collect</a>(<a class="code" href="../../d3/d76/classvtable__t.html">vtable_t</a>&amp;v, <span class="keywordtype">bool</span> attr_names_too=<span class="keyword">true</span>); 
<a name="l00750"></a>00750                         <span class="comment">// in vtable_sthread.cpp</span>
<a name="l00751"></a>00751 
<a name="l00752"></a>00752     <span class="keyword">static</span> <span class="keywordtype">void</span>      find_stack(<span class="keywordtype">void</span> *address);
<a name="l00753"></a>00753     <span class="keyword">static</span> <span class="keywordtype">void</span>      <a class="code" href="../../dd/ded/classsthread__t.html#d53564d44c98141bc683b5d3221ac94b">for_each_thread</a>(<a class="code" href="../../d1/db1/class_thread_func.html">ThreadFunc</a>&amp; f);
<a name="l00754"></a>00754 
<a name="l00755"></a>00755     <span class="comment">/* request stack overflow check, die on error. */</span>
<a name="l00756"></a>00756     <span class="keyword">static</span> <span class="keywordtype">void</span>      <a class="code" href="../../dd/ded/classsthread__t.html#afed003b148cc53329be44285d4cdd87">check_all_stacks</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *file = <span class="stringliteral">""</span>,
<a name="l00757"></a>00757                              <span class="keywordtype">int</span> line = 0);
<a name="l00758"></a>00758     <span class="keywordtype">bool</span>             <a class="code" href="../../dd/ded/classsthread__t.html#ab6cffaae40c2bcb9530b40617390cb9">isStackOK</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *file = <span class="stringliteral">""</span>, <span class="keywordtype">int</span> line = 0) <span class="keyword">const</span>;
<a name="l00759"></a>00759 
<a name="l00760"></a>00760     <span class="comment">/* Recursion, etc stack depth estimator */</span>
<a name="l00761"></a>00761     <span class="keywordtype">bool</span>             <a class="code" href="../../dd/ded/classsthread__t.html#20d7449ab45da4a5df60d8d35a0512a6">isStackFrameOK</a>(size_t size = 0);
<a name="l00762"></a>00762 
<a name="l00763"></a>00763     <a class="code" href="../../db/dc7/classw__rc__t.html">w_rc_t</a>           <a class="code" href="../../dd/ded/classsthread__t.html#ce87d255f8f4f6864062f63058b29560">set_priority</a>(<a class="code" href="../../dd/ded/classsthread__t.html#ed260674d3651a8a3e1b1d3331f5d4db">priority_t</a> priority);
<a name="l00764"></a>00764     <a class="code" href="../../dd/ded/classsthread__t.html#ed260674d3651a8a3e1b1d3331f5d4db">priority_t</a>       priority() <span class="keyword">const</span>;
<a name="l00765"></a>00765     <a class="code" href="../../dd/ded/classsthread__t.html#fe28f0ed447cb4e0b554c9cd402a414e">status_t</a>         status() <span class="keyword">const</span>;
<a name="l00766"></a>00766 
<a name="l00767"></a>00767 <span class="keyword">private</span>:
<a name="l00768"></a>00768 
<a name="l00769"></a>00769 <span class="comment">// WITHOUT_MMAP is controlled by configure</span>
<a name="l00770"></a>00770 <span class="preprocessor">#ifdef WITHOUT_MMAP</span>
<a name="l00771"></a>00771 <span class="preprocessor"></span>    <span class="keyword">static</span> <a class="code" href="../../db/dc7/classw__rc__t.html">w_rc_t</a>     set_bufsize_memalign(size_t size, 
<a name="l00772"></a>00772                         <span class="keywordtype">char</span> *&amp;buf_start <span class="comment">/* in/out*/</span>, <span class="keywordtype">long</span> system_page_size);
<a name="l00773"></a>00773 <span class="preprocessor">#endif</span>
<a name="l00774"></a>00774 <span class="preprocessor"></span><span class="preprocessor">#ifdef HAVE_HUGETLBFS</span>
<a name="l00775"></a>00775 <span class="preprocessor"></span><span class="keyword">public</span>:
<a name="l00776"></a>00776     <span class="comment">// Must be called if we are configured with  hugetlbfs</span>
<a name="l00777"></a>00777     <span class="keyword">static</span> <a class="code" href="../../db/dc7/classw__rc__t.html">w_rc_t</a>     set_hugetlbfs_path(<span class="keyword">const</span> <span class="keywordtype">char</span> *path);
<a name="l00778"></a>00778 <span class="keyword">private</span>:
<a name="l00779"></a>00779     <span class="keyword">static</span> <a class="code" href="../../db/dc7/classw__rc__t.html">w_rc_t</a>     set_bufsize_huge(size_t size, 
<a name="l00780"></a>00780                         <span class="keywordtype">char</span> *&amp;buf_start <span class="comment">/* in/out*/</span>, <span class="keywordtype">long</span> system_page_size);
<a name="l00781"></a>00781 <span class="preprocessor">#endif</span>
<a name="l00782"></a>00782 <span class="preprocessor"></span>    <span class="keyword">static</span> <a class="code" href="../../db/dc7/classw__rc__t.html">w_rc_t</a>     set_bufsize_normal(size_t size, 
<a name="l00783"></a>00783                         <span class="keywordtype">char</span> *&amp;buf_start <span class="comment">/* in/out*/</span>, <span class="keywordtype">long</span> system_page_size);
<a name="l00784"></a>00784     <span class="keyword">static</span> <span class="keywordtype">void</span>       align_bufsize(size_t size, <span class="keywordtype">long</span> system_page_size,
<a name="l00785"></a>00785                                                 <span class="keywordtype">long</span> max_page_size);
<a name="l00786"></a>00786     <span class="keyword">static</span> <span class="keywordtype">long</span>       get_max_page_size(<span class="keywordtype">long</span> system_page_size);
<a name="l00787"></a>00787     <span class="keyword">static</span> <span class="keywordtype">void</span>       align_for_sm(size_t requested_size);
<a name="l00788"></a>00788 
<a name="l00789"></a>00789 <span class="keyword">public</span>:
<a name="l00790"></a>00790     <span class="keyword">static</span> <span class="keywordtype">int</span>          do_unmap(); 
<a name="l00791"></a>00791     <span class="comment">/*</span>
<a name="l00792"></a>00792 <span class="comment">     *  Concurrent I/O ops</span>
<a name="l00793"></a>00793 <span class="comment">     */</span>
<a name="l00794"></a>00794     <span class="keyword">static</span> <span class="keywordtype">char</span>*        set_bufsize(size_t size);
<a name="l00795"></a>00795     <span class="keyword">static</span> <a class="code" href="../../db/dc7/classw__rc__t.html">w_rc_t</a>       set_bufsize(size_t size, <span class="keywordtype">char</span> *&amp;buf_start <span class="comment">/* in/out*/</span>,
<a name="l00796"></a>00796                                     <span class="keywordtype">bool</span> use_normal_if_huge_fails=<span class="keyword">false</span>);
<a name="l00797"></a>00797 
<a name="l00798"></a>00798     <span class="keyword">static</span> <a class="code" href="../../db/dc7/classw__rc__t.html">w_rc_t</a>        open(
<a name="l00799"></a>00799                             <span class="keyword">const</span> <span class="keywordtype">char</span>*            path,
<a name="l00800"></a>00800                             <span class="keywordtype">int</span>                flags,
<a name="l00801"></a>00801                             <span class="keywordtype">int</span>                <a class="code" href="../../d5/d5b/classlatch__t.html#e0bb43a3e6fb708aaf8b4754df4006cc">mode</a>,
<a name="l00802"></a>00802                             <span class="keywordtype">int</span>&amp;                fd);
<a name="l00803"></a>00803     <span class="keyword">static</span> <a class="code" href="../../db/dc7/classw__rc__t.html">w_rc_t</a>        close(<span class="keywordtype">int</span> fd);
<a name="l00804"></a>00804     <span class="keyword">static</span> <a class="code" href="../../db/dc7/classw__rc__t.html">w_rc_t</a>        read(
<a name="l00805"></a>00805                             <span class="keywordtype">int</span>                 fd,
<a name="l00806"></a>00806                             <span class="keywordtype">void</span>*                 buf,
<a name="l00807"></a>00807                             <span class="keywordtype">int</span>                 n);
<a name="l00808"></a>00808     <span class="keyword">static</span> <a class="code" href="../../db/dc7/classw__rc__t.html">w_rc_t</a>        write(
<a name="l00809"></a>00809                             <span class="keywordtype">int</span>                 fd, 
<a name="l00810"></a>00810                             <span class="keyword">const</span> <span class="keywordtype">void</span>*             buf, 
<a name="l00811"></a>00811                             <span class="keywordtype">int</span>                 n);
<a name="l00812"></a>00812     <span class="keyword">static</span> <a class="code" href="../../db/dc7/classw__rc__t.html">w_rc_t</a>        readv(
<a name="l00813"></a>00813                             <span class="keywordtype">int</span>                 fd, 
<a name="l00814"></a>00814                             <span class="keyword">const</span> iovec_t*             iov,
<a name="l00815"></a>00815                             size_t                iovcnt);
<a name="l00816"></a>00816     <span class="keyword">static</span> <a class="code" href="../../db/dc7/classw__rc__t.html">w_rc_t</a>        writev(
<a name="l00817"></a>00817                             <span class="keywordtype">int</span>                 fd,
<a name="l00818"></a>00818                             <span class="keyword">const</span> iovec_t*                iov,
<a name="l00819"></a>00819                             size_t                 iovcnt);
<a name="l00820"></a>00820 
<a name="l00821"></a>00821     <span class="keyword">static</span> <a class="code" href="../../db/dc7/classw__rc__t.html">w_rc_t</a>        pread(<span class="keywordtype">int</span> fd, <span class="keywordtype">void</span> *buf, <span class="keywordtype">int</span> n, fileoff_t pos);
<a name="l00822"></a>00822     <span class="keyword">static</span> <a class="code" href="../../db/dc7/classw__rc__t.html">w_rc_t</a>        pwrite(<span class="keywordtype">int</span> fd, <span class="keyword">const</span> <span class="keywordtype">void</span> *buf, <span class="keywordtype">int</span> n,
<a name="l00823"></a>00823                            fileoff_t pos);
<a name="l00824"></a>00824     <span class="keyword">static</span> <a class="code" href="../../db/dc7/classw__rc__t.html">w_rc_t</a>        lseek(
<a name="l00825"></a>00825                             <span class="keywordtype">int</span>                fd,
<a name="l00826"></a>00826                             fileoff_t            offset,
<a name="l00827"></a>00827                             <span class="keywordtype">int</span>                whence,
<a name="l00828"></a>00828                             fileoff_t&amp;            ret);
<a name="l00829"></a>00829     <span class="comment">/* returns an error if the seek doesn't match its destination */</span>
<a name="l00830"></a>00830     <span class="keyword">static</span> <a class="code" href="../../db/dc7/classw__rc__t.html">w_rc_t</a>        lseek(
<a name="l00831"></a>00831                             <span class="keywordtype">int</span>                fd,
<a name="l00832"></a>00832                             fileoff_t                offset,
<a name="l00833"></a>00833                             <span class="keywordtype">int</span>                whence);
<a name="l00834"></a>00834     <span class="keyword">static</span> <a class="code" href="../../db/dc7/classw__rc__t.html">w_rc_t</a>        fsync(<span class="keywordtype">int</span> fd);
<a name="l00835"></a>00835     <span class="keyword">static</span> <a class="code" href="../../db/dc7/classw__rc__t.html">w_rc_t</a>        ftruncate(<span class="keywordtype">int</span> fd, fileoff_t sz);
<a name="l00836"></a>00836     <span class="keyword">static</span> <a class="code" href="../../db/dc7/classw__rc__t.html">w_rc_t</a>        fstat(<span class="keywordtype">int</span> fd, filestat_t &amp;sb);
<a name="l00837"></a>00837     <span class="keyword">static</span> <a class="code" href="../../db/dc7/classw__rc__t.html">w_rc_t</a>        fisraw(<span class="keywordtype">int</span> fd, <span class="keywordtype">bool</span> &amp;raw);
<a name="l00838"></a>00838 
<a name="l00839"></a>00839 
<a name="l00840"></a>00840     <span class="comment">/*</span>
<a name="l00841"></a>00841 <span class="comment">     *  Misc</span>
<a name="l00842"></a>00842 <span class="comment">     */</span>
<a name="l00843"></a>00843 <span class="keyword">private</span>:
<a name="l00844"></a>00844     <span class="comment">// NOTE: this returns a REFERENCE to a pointer</span>
<a name="l00845"></a>00845     <span class="comment">/* #\fn static sthread_t*&amp; sthread_t::me_lval()</span>
<a name="l00846"></a>00846 <span class="comment">     ** \brief Returns a (writable) reference to the a </span>
<a name="l00847"></a>00847 <span class="comment">     * pointer to the running sthread_t.</span>
<a name="l00848"></a>00848 <span class="comment">     * \ingroup TLS</span>
<a name="l00849"></a>00849 <span class="comment">     */</span>
<a name="l00850"></a>00850     <span class="keyword">inline</span> <span class="keyword">static</span> <a class="code" href="../../dd/ded/classsthread__t.html">sthread_t</a>*&amp; me_lval() {<span class="comment"></span>
<a name="l00851"></a>00851 <span class="comment">        /**\var sthread_t* _me;</span>
<a name="l00852"></a>00852 <span class="comment">         * \brief A pointer to the running sthread_t.</span>
<a name="l00853"></a>00853 <span class="comment">         * \ingroup TLS</span>
<a name="l00854"></a>00854 <span class="comment">         */</span>
<a name="l00855"></a>00855         <span class="keyword">static</span> __thread <a class="code" href="../../dd/ded/classsthread__t.html">sthread_t</a>* _TLSme(NULL);
<a name="l00856"></a>00856         <span class="keywordflow">return</span> _TLSme;
<a name="l00857"></a>00857     }
<a name="l00858"></a>00858 <span class="keyword">public</span>:
<a name="l00859"></a>00859     <span class="comment">// NOTE: this returns a POINTER</span>
<a name="l00860"></a><a class="code" href="../../dd/ded/classsthread__t.html#2976cb2cdcef1b63ce879f3398d37733">00860</a>     <span class="keyword">static</span> <a class="code" href="../../dd/ded/classsthread__t.html">sthread_t</a>*    <a class="code" href="../../dd/ded/classsthread__t.html#2976cb2cdcef1b63ce879f3398d37733">me</a>() { <span class="keywordflow">return</span> me_lval(); }
<a name="l00861"></a>00861                          <span class="comment">// for debugging:</span>
<a name="l00862"></a>00862     pthread_t            <a class="code" href="../../dd/ded/classsthread__t.html#c9513ddd71e824e5ea902adec6600216">myself</a>(); <span class="comment">// pthread_t associated with this </span>
<a name="l00863"></a>00863     <span class="keyword">static</span> <span class="keywordtype">int</span>           <a class="code" href="../../dd/ded/classsthread__t.html#8c474cb70ed865ca2561dc855b5eb995">rand</a>(); <span class="comment">// returns an int in [0, 2**31)</span>
<a name="l00864"></a>00864     <span class="keyword">static</span> <span class="keywordtype">double</span>        <a class="code" href="../../dd/ded/classsthread__t.html#d785352d32dcf7fd70c51a083775a211">drand</a>(); <span class="comment">// returns a double in [0.0, 1)</span>
<a name="l00865"></a>00865     <span class="keyword">static</span> <span class="keywordtype">int</span>           <a class="code" href="../../dd/ded/classsthread__t.html#fd5396ffeb20cbe1185fbfba1e4d3f66">randn</a>(<span class="keywordtype">int</span> max); <span class="comment">// returns an int in [0, max)</span>
<a name="l00866"></a>00866 
<a name="l00867"></a>00867     <span class="comment">/* XXX  sleep, fork, and wait exit overlap the unix version. */</span>
<a name="l00868"></a>00868 
<a name="l00869"></a>00869     <span class="comment">// sleep for timeout milliseconds</span>
<a name="l00870"></a>00870     <span class="keywordtype">void</span>                 <a class="code" href="../../dd/ded/classsthread__t.html#67a2bbdc6b10c929215816713064c668">sleep</a>(<a class="code" href="../../d8/d69/smthread_8h.html#cf834513ff7853bf96601820e038ec9a">timeout_in_ms</a> timeout = WAIT_IMMEDIATE,
<a name="l00871"></a>00871                          <span class="keyword">const</span> <span class="keywordtype">char</span> *reason = 0);
<a name="l00872"></a>00872     <span class="keywordtype">void</span>                 <a class="code" href="../../dd/ded/classsthread__t.html#620b828db8bbd2be32785d99bb366b32">wakeup</a>();
<a name="l00873"></a>00873 
<a name="l00874"></a>00874     <span class="comment">// wait for a thread to finish running</span>
<a name="l00875"></a>00875     <a class="code" href="../../db/dc7/classw__rc__t.html">w_rc_t</a>            <a class="code" href="../../dd/ded/classsthread__t.html#54d600f6766d23204c7d8a03389a4d0e">join</a>(<a class="code" href="../../d8/d69/smthread_8h.html#cf834513ff7853bf96601820e038ec9a">timeout_in_ms</a> timeout = WAIT_FOREVER);
<a name="l00876"></a>00876 
<a name="l00877"></a>00877     <span class="comment">// start a thread</span>
<a name="l00878"></a>00878     <a class="code" href="../../db/dc7/classw__rc__t.html">w_rc_t</a>            <a class="code" href="../../dd/ded/classsthread__t.html#2ffa1efbf617551d8f63cea87312ce23">fork</a>();
<a name="l00879"></a>00879 
<a name="l00880"></a>00880     <span class="comment">// give up the processor</span>
<a name="l00881"></a>00881     <span class="keyword">static</span> <span class="keywordtype">void</span>        <a class="code" href="../../dd/ded/classsthread__t.html#7139958441a6cd3f6963d5a0e1685718">yield</a>();
<a name="l00882"></a>00882     ostream            &amp;<a class="code" href="../../dd/ded/classsthread__t.html#69b3d8da8a68062d80bc47d6b6ddbf73">print</a>(ostream &amp;) <span class="keyword">const</span>;
<a name="l00883"></a>00883 
<a name="l00884"></a>00884     <span class="comment">// anyone can wait and delete a thread</span>
<a name="l00885"></a>00885     <span class="keyword">virtual</span>            <a class="code" href="../../dd/ded/classsthread__t.html#7889565b40fd656e9e5ed9bf813a535f">~sthread_t</a>();
<a name="l00886"></a>00886 
<a name="l00887"></a>00887     <span class="comment">// function to do runtime up-cast to smthread_t</span>
<a name="l00888"></a>00888     <span class="comment">// return 0 if the sthread is not derrived from sm_thread_t.</span>
<a name="l00889"></a>00889     <span class="comment">// should be removed when RTTI is supported</span>
<a name="l00890"></a>00890     <span class="keyword">virtual</span> <a class="code" href="../../d7/d2a/classsmthread__t.html">smthread_t</a>*        dynamic_cast_to_smthread();
<a name="l00891"></a>00891     <span class="keyword">virtual</span> <span class="keyword">const</span> <a class="code" href="../../d7/d2a/classsmthread__t.html">smthread_t</a>*  dynamic_cast_to_const_smthread() <span class="keyword">const</span>;
<a name="l00892"></a>00892 
<a name="l00893"></a><a class="code" href="../../dd/ded/classsthread__t.html#d993890a5ba2558ca3927f3bbdbe2a9f">00893</a>     <a class="code" href="../../db/dc7/classw__rc__t.html#26d19aeb714443a307b3370cd8b57fc4">w_rc_t::errcode_t</a>    <a class="code" href="../../dd/ded/classsthread__t.html#d993890a5ba2558ca3927f3bbdbe2a9f">error_code</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> _rce;}
<a name="l00894"></a>00894 
<a name="l00895"></a>00895 <span class="keyword">protected</span>:
<a name="l00896"></a>00896     <a class="code" href="../../dd/ded/classsthread__t.html#52d37d0ef80e706d442989441953125c">sthread_t</a>(
<a name="l00897"></a>00897           <a class="code" href="../../dd/ded/classsthread__t.html#ed260674d3651a8a3e1b1d3331f5d4db">priority_t</a>    priority = t_regular,
<a name="l00898"></a>00898           <span class="keyword">const</span> <span class="keywordtype">char</span>    *name = 0,
<a name="l00899"></a>00899           <span class="keywordtype">unsigned</span>        stack_size = default_stack);
<a name="l00900"></a>00900 
<a name="l00901"></a><a class="code" href="../../dd/ded/classsthread__t.html#bd1a68b338ee7e6c6883c7512843514c">00901</a>     <span class="keyword">virtual</span> <span class="keywordtype">void</span>        <a class="code" href="../../dd/ded/classsthread__t.html#bd1a68b338ee7e6c6883c7512843514c">before_run</a>() { }
<a name="l00902"></a>00902     <span class="keyword">virtual</span> <span class="keywordtype">void</span>        run() = 0;
<a name="l00903"></a><a class="code" href="../../dd/ded/classsthread__t.html#ff5d8f9f64a9becac56fc0b7341d78af">00903</a>     <span class="keyword">virtual</span> <span class="keywordtype">void</span>        <a class="code" href="../../dd/ded/classsthread__t.html#ff5d8f9f64a9becac56fc0b7341d78af">after_run</a>() { }
<a name="l00904"></a>00904 
<a name="l00905"></a>00905 <span class="keyword">private</span>:
<a name="l00906"></a>00906 
<a name="l00907"></a>00907     <span class="comment">/* start offset of sthread FDs, to differentiate from system FDs */</span>
<a name="l00908"></a>00908     <span class="keyword">enum</span> { fd_base = 4000 };
<a name="l00909"></a>00909     <span class="keywordtype">void</span> *                      _start_frame;
<a name="l00910"></a>00910     <span class="keywordtype">void</span> *                      _danger;
<a name="l00911"></a>00911     size_t                      _stack_size;
<a name="l00912"></a>00912 
<a name="l00913"></a>00913     pthread_mutex_t             _wait_lock; <span class="comment">// paired with _wait_cond, also</span>
<a name="l00914"></a>00914                                 <span class="comment">// protects _link</span>
<a name="l00915"></a>00915     pthread_cond_t              _wait_cond; <span class="comment">// posted when thread should unblock</span>
<a name="l00916"></a>00916 
<a name="l00917"></a>00917     pthread_mutex_t*            _start_terminate_lock; <span class="comment">// _start_cond, _terminate_cond, _forked</span>
<a name="l00918"></a>00918     pthread_cond_t *            _start_cond; <span class="comment">// paired w/ _start_terminate_lock</span>
<a name="l00919"></a>00919 
<a name="l00920"></a>00920     <span class="keyword">volatile</span> <span class="keywordtype">bool</span>               _sleeping;
<a name="l00921"></a>00921     <span class="keyword">volatile</span> <span class="keywordtype">bool</span>               _forked;
<a name="l00922"></a>00922     <span class="keywordtype">bool</span>                        _terminated; <span class="comment">// protects against double calls</span>
<a name="l00923"></a>00923                                 <span class="comment">// to sthread_core_exit</span>
<a name="l00924"></a>00924     <span class="keyword">volatile</span> <span class="keywordtype">bool</span>               _unblock_flag; <span class="comment">// used internally by _block()</span>
<a name="l00925"></a>00925 
<a name="l00926"></a>00926     <a class="code" href="../../dc/db1/structfill4.html">fill4</a>                       _dummy4valgrind;
<a name="l00927"></a>00927     
<a name="l00928"></a>00928     sthread_core_t *            _core;        <span class="comment">// registers, stack, etc</span>
<a name="l00929"></a>00929     <span class="keyword">volatile</span> <a class="code" href="../../dd/ded/classsthread__t.html#fe28f0ed447cb4e0b554c9cd402a414e">status_t</a>           _status;    <span class="comment">// thread status</span>
<a name="l00930"></a>00930     <a class="code" href="../../dd/ded/classsthread__t.html#ed260674d3651a8a3e1b1d3331f5d4db">priority_t</a>                  _priority;     <span class="comment">// thread priority</span>
<a name="l00931"></a>00931     <a class="code" href="../../db/dc7/classw__rc__t.html#26d19aeb714443a307b3370cd8b57fc4">w_rc_t::errcode_t</a>           _rce;        <span class="comment">// used in block/unblock</span>
<a name="l00932"></a>00932 
<a name="l00933"></a>00933     <a class="code" href="../../dd/de8/classw__link__t.html">w_link_t</a>                    _link;        <span class="comment">// protected by _wait_lock</span>
<a name="l00934"></a>00934 
<a name="l00935"></a>00935     <a class="code" href="../../dd/de8/classw__link__t.html">w_link_t</a>                    _class_link;    <span class="comment">// used in _class_list,</span>
<a name="l00936"></a>00936                                  <span class="comment">// protected by _class_list_lock</span>
<a name="l00937"></a>00937     <span class="keyword">static</span> sthread_list_t*      _class_list;
<a name="l00938"></a>00938     <span class="keyword">static</span> queue_based_lock_t   _class_list_lock; <span class="comment">// for protecting _class_list</span>
<a name="l00939"></a>00939 
<a name="l00940"></a>00940 
<a name="l00941"></a>00941     <span class="comment">/* XXX alignment probs in derived thread classes.  Sigh */</span>
<a name="l00942"></a>00942     <span class="comment">// fill4                       _ex_fill;</span>
<a name="l00943"></a>00943 
<a name="l00944"></a>00944     <span class="comment">/* I/O subsystem */</span>
<a name="l00945"></a>00945     <span class="keyword">static</span>    sdisk_t        **_disks;
<a name="l00946"></a>00946     <span class="keyword">static</span>    <span class="keywordtype">unsigned</span>       open_max;
<a name="l00947"></a>00947     <span class="keyword">static</span>    <span class="keywordtype">unsigned</span>       open_count;
<a name="l00948"></a>00948 
<a name="l00949"></a>00949     <span class="comment">/* in-thread startup and shutdown */</span> 
<a name="l00950"></a>00950     <span class="keyword">static</span> <span class="keywordtype">void</span>            __start(<span class="keywordtype">void</span> *arg_thread);
<a name="l00951"></a>00951     <span class="keywordtype">void</span>                   _start();
<a name="l00952"></a>00952 
<a name="l00953"></a>00953 
<a name="l00954"></a>00954     <span class="comment">/* system initialization and shutdown */</span>
<a name="l00955"></a>00955     <span class="keyword">static</span> <a class="code" href="../../db/dc7/classw__rc__t.html">w_rc_t</a>        cold_startup();
<a name="l00956"></a>00956     <span class="keyword">static</span> <a class="code" href="../../db/dc7/classw__rc__t.html">w_rc_t</a>        shutdown();
<a name="l00957"></a>00957     <span class="keyword">static</span> stime_t        boot_time;
<a name="l00958"></a>00958     <span class="keyword">static</span> <a class="code" href="../../dd/ded/classsthread__t.html">sthread_t</a>*    _main_thread; 
<a name="l00959"></a>00959     <span class="keyword">static</span> uint4_t        _next_id;    <span class="comment">// unique id generator</span>
<a name="l00960"></a>00960 
<a name="l00961"></a>00961 <span class="keyword">private</span>:
<a name="l00962"></a>00962     <span class="keyword">static</span> <span class="keywordtype">int</span>           _disk_buffer_disalignment;
<a name="l00963"></a>00963     <span class="keyword">static</span> size_t        _disk_buffer_size;
<a name="l00964"></a>00964     <span class="keyword">static</span> <span class="keywordtype">char</span> *        _disk_buffer;
<a name="l00965"></a>00965 <span class="keyword">public</span>:
<a name="l00966"></a>00966     <span class="comment">// export so smthread can read it and so latch/srwlock can write it:</span>
<a name="l00967"></a><a class="code" href="../../dd/ded/classsthread__t.html#f3db996736e34eb7f6d8d074377a660c">00967</a>     <a class="code" href="../../dd/dc8/classsthread__stats.html">sthread_stats</a>        <a class="code" href="../../dd/ded/classsthread__t.html#f3db996736e34eb7f6d8d074377a660c">SthreadStats</a>;
<a name="l00968"></a>00968 };
<a name="l00969"></a>00969 
<a name="l00970"></a>00970 <span class="keyword">extern</span> ostream &amp;<a class="code" href="../../de/d94/w__hash_8h.html#7c2e56bc1ff4f3aa420f06b5e25dd768">operator&lt;&lt;</a>(ostream &amp;o, <span class="keyword">const</span> <a class="code" href="../../dd/ded/classsthread__t.html">sthread_t</a> &amp;t);
<a name="l00971"></a>00971 
<a name="l00972"></a>00972 <span class="keywordtype">void</span> print_timeout(ostream&amp; o, <span class="keyword">const</span> <a class="code" href="../../d2/d6b/classsthread__base__t.html#c1377912ffa5e8f35cf9eb3d67e465b7">sthread_base_t::timeout_in_ms</a> timeout);
<a name="l00973"></a>00973 
<a name="l00974"></a>00974 <span class="comment"></span>
<a name="l00975"></a>00975 <span class="comment">/**\cond skip */</span><span class="comment"></span>
<a name="l00976"></a>00976 <span class="comment">/**\brief The main thread. </span>
<a name="l00977"></a>00977 <span class="comment">*</span>
<a name="l00978"></a>00978 <span class="comment">* Called from sthread_t::cold_startup(), which is</span>
<a name="l00979"></a>00979 <span class="comment">* called from sthread_init_t::do_init(), which is </span>
<a name="l00980"></a>00980 <span class="comment">* called from sthread_t::initialize_sthreads_package(), which is called </span>
<a name="l00981"></a>00981 <span class="comment">* when the storage manager sets up options, among other places.</span>
<a name="l00982"></a>00982 <span class="comment">*/</span>
<a name="l00983"></a>00983 <span class="keyword">class </span>sthread_main_t : <span class="keyword">public</span> <a class="code" href="../../dd/ded/classsthread__t.html">sthread_t</a>  {
<a name="l00984"></a>00984     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="../../dd/ded/classsthread__t.html">sthread_t</a>;
<a name="l00985"></a>00985     
<a name="l00986"></a>00986 <span class="keyword">protected</span>:
<a name="l00987"></a>00987     <a class="code" href="../../dd/d93/w__base_8h.html#45d83e292de0c4c2a60998a0b9e82332">NORET</a>            <a class="code" href="../../dd/ded/classsthread__t.html#777e903c78d7fdbabcf0eb63a1ae67e3">sthread_main_t</a>();
<a name="l00988"></a>00988     <span class="keyword">virtual</span> <span class="keywordtype">void</span>        run();
<a name="l00989"></a>00989 };<span class="comment"></span>
<a name="l00990"></a>00990 <span class="comment">/**\endcond skip */</span>
<a name="l00991"></a>00991 
<a name="l00992"></a>00992 <span class="comment"></span>
<a name="l00993"></a>00993 <span class="comment">/**\cond skip */</span>
<a name="l00994"></a>00994 
<a name="l00995"></a>00995 <span class="preprocessor">#define MUTEX_ACQUIRE(mutex)    W_COERCE((mutex).acquire());</span>
<a name="l00996"></a>00996 <span class="preprocessor"></span><span class="preprocessor">#define MUTEX_RELEASE(mutex)    (mutex).release();</span>
<a name="l00997"></a>00997 <span class="preprocessor"></span><span class="preprocessor">#define MUTEX_IS_MINE(mutex)    (mutex).is_mine()</span>
<a name="l00998"></a>00998 <span class="preprocessor"></span>
<a name="l00999"></a>00999 <span class="comment">// critical_section.h contains the macros needed for the following</span>
<a name="l01000"></a>01000 <span class="comment">// SPECIALIZE_CS</span>
<a name="l01001"></a>01001 <span class="preprocessor">#include "critical_section.h"</span>
<a name="l01002"></a>01002 
<a name="l01003"></a>01003 <span class="comment">// tatas_lock doesn't have is_mine, but I changed its release()</span>
<a name="l01004"></a>01004 <span class="comment">// to Release and through compiling saw everywhere that uses release,</span>
<a name="l01005"></a>01005 <span class="comment">// and fixed those places</span>
<a name="l01006"></a>01006 SPECIALIZE_CS(<a class="code" href="../../d6/d9d/structtatas__lock.html">tatas_lock</a>, <span class="keywordtype">int</span> _dummy, (_dummy=0), 
<a name="l01007"></a>01007     _mutex-&gt;acquire(), _mutex-&gt;release());
<a name="l01008"></a>01008 
<a name="l01009"></a>01009 <span class="comment">// queue_based_lock_t asserts is_mine() in release()</span>
<a name="l01010"></a>01010 SPECIALIZE_CS(<a class="code" href="../../df/d15/structw__pthread__lock__t.html">w_pthread_lock_t</a>, w_pthread_lock_t::ext_qnode _me, (_me._held=0), 
<a name="l01011"></a>01011     _mutex-&gt;acquire(&amp;_me), _mutex-&gt;release(&amp;_me));
<a name="l01012"></a>01012 <span class="preprocessor">#if !defined(USE_PTHREAD_MUTEX) || USE_PTHREAD_MUTEX==0</span>
<a name="l01013"></a>01013 <span class="preprocessor"></span>SPECIALIZE_CS(mcs_lock, mcs_lock::ext_qnode _me, (_me._held=0), 
<a name="l01014"></a>01014     _mutex-&gt;acquire(&amp;_me), _mutex-&gt;release(&amp;_me));
<a name="l01015"></a>01015 <span class="preprocessor">#endif</span>
<a name="l01016"></a>01016 <span class="preprocessor"></span>
<a name="l01017"></a>01017 SPECIALIZE_CS(occ_rwlock::occ_rlock, <span class="keywordtype">int</span> _dummy, (_dummy=0), 
<a name="l01018"></a>01018     _mutex-&gt;acquire(), _mutex-&gt;release());
<a name="l01019"></a>01019 
<a name="l01020"></a>01020 SPECIALIZE_CS(occ_rwlock::occ_wlock, <span class="keywordtype">int</span> _dummy, (_dummy=0), 
<a name="l01021"></a>01021     _mutex-&gt;acquire(), _mutex-&gt;release());
<a name="l01022"></a>01022 
<a name="l01023"></a>01023 <span class="keyword">inline</span> <a class="code" href="../../dd/ded/classsthread__t.html#ed260674d3651a8a3e1b1d3331f5d4db">sthread_t::priority_t</a>
<a name="l01024"></a>01024 sthread_t::priority()<span class="keyword"> const</span>
<a name="l01025"></a>01025 <span class="keyword"></span>{
<a name="l01026"></a>01026     <span class="keywordflow">return</span> _priority;
<a name="l01027"></a>01027 }
<a name="l01028"></a>01028 
<a name="l01029"></a>01029 <span class="keyword">inline</span> <a class="code" href="../../dd/ded/classsthread__t.html#fe28f0ed447cb4e0b554c9cd402a414e">sthread_t::status_t</a>
<a name="l01030"></a>01030 sthread_t::status()<span class="keyword"> const</span>
<a name="l01031"></a>01031 <span class="keyword"></span>{
<a name="l01032"></a>01032     <span class="keywordflow">return</span> _status;
<a name="l01033"></a>01033 }
<a name="l01034"></a>01034 
<a name="l01035"></a>01035 <span class="preprocessor">#include &lt;w_strstream.h&gt;</span>
<a name="l01036"></a>01036 <span class="comment">// Need string.h to get strerror_r </span>
<a name="l01037"></a>01037 <span class="preprocessor">#include &lt;string.h&gt;</span><span class="comment"></span>
<a name="l01038"></a>01038 <span class="comment">/**\endcond skip */</span>
<a name="l01039"></a>01039 
<a name="l01040"></a>01040 
<a name="l01041"></a>01041 <span class="comment">/*&lt;std-footer incl-file-exclusion='STHREAD_H'&gt;  -- do not edit anything below this line -- */</span>
<a name="l01042"></a>01042 
<a name="l01043"></a>01043 <span class="preprocessor">#endif          </span><span class="comment">/*&lt;/std-footer&gt;*/</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Mon Jan 2 15:13:57 2012 for Shore Storage Manager by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
