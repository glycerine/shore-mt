<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Shore Storage Manager: Transactions, Locking and Logging</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
<link href="../../tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="../../main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="../../modules.html"><span>Modules</span></a></li>
    <li><a href="../../namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="../../classes.html"><span>Classes</span></a></li>
    <li><a href="../../files.html"><span>Files</span></a></li>
    <li><a href="../../dirs.html"><span>Directories</span></a></li>
    <li><a href="../../pages.html"><span>Related&nbsp;Pages</span></a></li>
    <li><a href="../../examples.html"><span>Examples</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
  </ul></div>
<h1>Transactions, Locking and Logging<br>
<small>
[<a class="el" href="../../dc/dc8/group___s_s_m_a_p_i.html">SHORE Storage Manager Application Programming Interface (SSM API)</a>]</small>
</h1>
<p>
Collaboration diagram for Transactions, Locking and Logging:<center><table><tr><td><img src="../../d8/d1e/group___s_s_m_x_c_t.png" border="0" alt="" usemap="#d4/d79/d8_2d1e_2group______s__s__m__x__c__t_map">
<map name="d4/d79/d8_2d1e_2group______s__s__m__x__c__t_map">
<area href="../../d2/dae/group___s_s_m2_p_c.html" shape="rect" coords="809,5,1114,32" alt="">
<area href="../../d8/da8/group___s_s_m_l_o_c_k.html" shape="rect" coords="926,56,997,83" alt="">
<area href="../../df/d2d/group___l_o_g_s_p_a_c_e.html" shape="rect" coords="867,107,1055,133" alt="">
<area href="../../dc/d53/group___s_s_m_m_u_l_t_i_x_c_t.html" shape="rect" coords="863,157,1059,184" alt="">
<area href="../../de/def/group___s_s_m_q_k.html" shape="rect" coords="863,208,1060,235" alt="">
<area href="../../d0/d4e/group___s_s_m_s_p.html" shape="rect" coords="863,259,1059,285" alt="">
<area href="../../df/db2/group___l_s_n_s.html" shape="rect" coords="827,309,1095,336" alt="">
<area href="../../dc/dc8/group___s_s_m_a_p_i.html" shape="rect" coords="5,157,472,184" alt="">
</map></td></tr></table></center>
<hr><a name="_details"></a><h2>Detailed Description</h2>
All storage manager operations on data must be done within the scope of a transaction (<a class="el" href="../../d8/d1e/group___s_s_m_x_c_t.html#ga18b22291428a1c82a18f4c170298aeb">ss_m::begin_xct</a>, <a class="el" href="../../d8/d1e/group___s_s_m_x_c_t.html#gdcc84a1d655f398fa9a054b79eb6e544">ss_m::commit_xct</a>, <a class="el" href="../../d8/d1e/group___s_s_m_x_c_t.html#g1ef08428870c5ad773dcb7d95dfe9bff">ss_m::abort_xct</a>, <a class="el" href="../../d8/d1e/group___s_s_m_x_c_t.html#g6d01a3863578576383768a5456808393">ss_m::chain_xct</a>).<p>
A very few storage manager operations, such as formatting a volume, are called outside the scope of a transaction and the storage manager begins its own transaction to do the work.<p>
Operations that fail return an error indication and the storage manager assumes that the server will thereafter abort the transaction in which the error occurred, when abort is indicated. Abort is indicated when eUSERABORT or eDEADLOCK is returned and when the erver chooses to abort rather than to work around the problem (whatever it might be, such as eRETRY).<p>
The storage manager does not enforce the aborting of any erroneous transactions except, possibly, those that are in danger of running out of log space. (This is done with the destructor of the prologue used on each call to the storage manager, see next paragraph).<p>
It is always the server's responsibility to abort. When the storage manager encounters a eLOGSPACEWARN condition (the log hasn't enough space <em>at</em> <em>this</em> <em>moment</em> to abort the running transaction, assuming a 1:1 ration of rollback-logging overhead to forward-processing logging overhead), it does one of two things:<ul>
<li>passes the error code eLOGSPACEWARN up the call stack back to the server if the storage manager was constructed with no log-space-warning callback argument (see LOG_WARN_CALLBACK_FUNC, <a class="el" href="../../de/db0/group___s_s_m_i_n_i_t.html#g4b4479aa4533cf55b6baccc3758d08b2">ss_m::ss_m</a>).</li><li>tries to abort a transaction before passing an error code back up the call stack to the server. Choosing a victim transaction to abort is done by the server in its log-space-warning callback function (passed in on <a class="el" href="../../de/db0/group___s_s_m_i_n_i_t.html#g4b4479aa4533cf55b6baccc3758d08b2">ss_m::ss_m</a>, q.v. Only if that callback function returns a non-null victim transaction and returns eUSERABORT does the storage manager abort that victim before returning eUSERABORT up the call stack. Any other error code returned by the callback function is just returned up the call stack.</li></ul>
<h2><a class="anchor" name="LOCKS">
Locks</a></h2>
The storage manager automatically acquires the necessary locks when the data are read or written. The locks thus acquired are normally released at the end of a transaction, thus, by default, transactions are two-phase and well-formed (degree 3).<h3><a class="anchor" name="GRAN">
Lock Granularity</a></h3>
The fine-grained locks are normally used for records in files, but provision is made for using coarser-grained locks. The transaction has a default lock level associated with it, which governs the granularity of locks acquired by the storage manager on behalf of the transaction. The lock manager provides for lock escalation to coarser locks to reduce the locking costs. See <a class="el" href="../../d8/da8/group___s_s_m_l_o_c_k.html">Locking</a> and <a class="el" href="../../de/d81/sm__base_8h.html#8a4ace36542f82f7a5e908a7df721a57">smlevel_0::concurrency_t</a>.<p>
Key-value locking is normally used for B+-Trees. (See <a class="el" href="../../references.html#MOH1">[MOH1]</a>.) R*-Trees normally use coarse-granularity locking. The locking protocol used with an index is determined when the index is created. A transaction may acquire coarse (index-level) locks with explicit calls to the lock manager, but by default, the granularity/level/protocol associated with the index is used. See <a class="el" href="../../de/d81/sm__base_8h.html#8a4ace36542f82f7a5e908a7df721a57">smlevel_0::concurrency_t</a>.<h2><a class="anchor" name="DISTXCT">
Distributed Transactions</a></h2>
Storage manager transactions may be used as "threads" (to overload this term) of distributed transactions. Coordination of 2-phase commit must be done externally, but the storage manager supports preparing the (local) transaction "thread" for two-phase commit, and it will log the necessary data for recovering in-doubt transactions.<h2><a class="anchor" name="ATTACH">
Threads and Transactions</a></h2>
Transactions are not tied to storage manager threads (<a class="el" href="../../d7/d2a/classsmthread__t.html">smthread_t</a>, not to be confused with a local "thread" of a distributed transaction) in any way other than that a transaction must be <em>attached</em> to a thread while any storage manager work is being done on behalf of that transaction. This is how the storage manager knows <em>which</em> transaction is to acquire the locks and latches, etc. But a thread can attach and detach from transactions at will, so work may be performed by different threads each time the storage manager is called on behalf of a given transaction; this allows the server to keep a pool of threads to perform work and allows them to perform work on behalf of any active transaction.<p>
<dl compact><dt><b>Warning:</b></dt><dd>While there are limited circumstances in which multiple threads can be attached to the same transaction <em>concurrently</em> and perform storage manager operations on behalf of that transaction concurrently, which is a hold-over from the original storage manager, this functionality may be deprecated soon. The reason for this is that it is extremely difficult to handle errors internally when multiple threads are attached to a transaction because partial rollback is impossible in the absence of multiple log streams for a transaction.</dd></dl>
Under no circumstances may a thread attach to more than one transaction at a time.<h2><a class="anchor" name="EXOTICA">
Exotica</a></h2>
The storage manager also provides<ul>
<li>partial rollback (<a class="el" href="../../d0/d4e/group___s_s_m_s_p.html#g90a637501fe6e70de18742dfd9d59d20">ss_m::save_work</a> and <a class="el" href="../../d0/d4e/group___s_s_m_s_p.html#g888b894a58102d61794d91758f9032e1">ss_m::rollback_work</a>), which undoes actions but does not release locks,</li><li>transaction chaining (<a class="el" href="../../d8/d1e/group___s_s_m_x_c_t.html#g6d01a3863578576383768a5456808393">ss_m::chain_xct</a>), which commits, but retains locks and gives them to a new transaction,</li><li>lock release (<a class="el" href="../../d3/dfc/classsm__quark__t.html">sm_quark_t</a>, <a class="el" href="../../d8/da8/group___s_s_m_l_o_c_k.html#g90cc2cc0f95397a82a94a119313219d2">ss_m::unlock</a>), allowing less-than-3-degree transactions.</li></ul>
<p>
To reduce the cost (particularly in logging) of loading databases, the storage manager provides for unlogged loading of stores. See <a class="el" href="../../d2/dc6/group___s_s_m_s_t_o_r_e.html">Stores</a>.<p>
All work performed on behalf of a transaction must occur while that transaction is "attached" to the thread that performs the work. Creating a transaction attaches it to the thread that creates the transaction. The thread may detach from the transaction and attach to another. Multiple threads may attach to a single transaction and do work in certain circumstances. See <a class="el" href="../../dc/d53/group___s_s_m_m_u_l_t_i_x_c_t.html">Multi-threaded Transactions</a> 
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Modules</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/da8/group___s_s_m_l_o_c_k.html">Locking</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d4e/group___s_s_m_s_p.html">Partial Rollback: Savepoints</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/def/group___s_s_m_q_k.html">Early Lock Release: Quarks</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dae/group___s_s_m2_p_c.html">Distributed Transactions: Two-Phase Commit</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d53/group___s_s_m_m_u_l_t_i_x_c_t.html">Multi-threaded Transactions</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d2d/group___l_o_g_s_p_a_c_e.html">Running Out of Log Space</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/db2/group___l_s_n_s.html">How Log Sequence Numbers are Used</a></td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="../../db/dc7/classw__rc__t.html">rc_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d1e/group___s_s_m_x_c_t.html#ga18b22291428a1c82a18f4c170298aeb">ss_m::begin_xct</a> (<a class="el" href="../../d8/d69/smthread_8h.html#cf834513ff7853bf96601820e038ec9a">timeout_in_ms</a> timeout=WAIT_SPECIFIED_BY_THREAD)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Begin a transaction.  <a href="#ga18b22291428a1c82a18f4c170298aeb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="../../db/dc7/classw__rc__t.html">rc_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d1e/group___s_s_m_x_c_t.html#ga8bca632d0b0bfb69559bfcd3ad9bdd8">ss_m::begin_xct</a> (<a class="el" href="../../d9/dee/classsm__stats__info__t.html">sm_stats_info_t</a> *stats, <a class="el" href="../../d8/d69/smthread_8h.html#cf834513ff7853bf96601820e038ec9a">timeout_in_ms</a> timeout=WAIT_SPECIFIED_BY_THREAD)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Begin an instrumented transaction.  <a href="#ga8bca632d0b0bfb69559bfcd3ad9bdd8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="../../db/dc7/classw__rc__t.html">rc_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d1e/group___s_s_m_x_c_t.html#gab35cb44896fd3722c5f7d6ef098661a">ss_m::begin_xct</a> (<a class="el" href="../../d8/d12/classtid__t.html">tid_t</a> &amp;tid, <a class="el" href="../../d8/d69/smthread_8h.html#cf834513ff7853bf96601820e038ec9a">timeout_in_ms</a> timeout=WAIT_SPECIFIED_BY_THREAD)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Begin a transaction and return the transaction id.  <a href="#gab35cb44896fd3722c5f7d6ef098661a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="../../db/dc7/classw__rc__t.html">rc_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d1e/group___s_s_m_x_c_t.html#gdcc84a1d655f398fa9a054b79eb6e544">ss_m::commit_xct</a> (bool lazy=false, <a class="el" href="../../d2/d19/classlsn__t.html">lsn_t</a> *plastlsn=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Commit a transaction.  <a href="#gdcc84a1d655f398fa9a054b79eb6e544"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="../../db/dc7/classw__rc__t.html">rc_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d1e/group___s_s_m_x_c_t.html#g18e0794b043b9341534708cb90752265">ss_m::commit_xct</a> (<a class="el" href="../../d9/dee/classsm__stats__info__t.html">sm_stats_info_t</a> *&amp;stats, bool lazy=false, <a class="el" href="../../d2/d19/classlsn__t.html">lsn_t</a> *plastlsn=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Commit an instrumented transaction and get its statistics.  <a href="#g18e0794b043b9341534708cb90752265"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="../../db/dc7/classw__rc__t.html">rc_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d1e/group___s_s_m_x_c_t.html#g6d01a3863578576383768a5456808393">ss_m::chain_xct</a> (<a class="el" href="../../d9/dee/classsm__stats__info__t.html">sm_stats_info_t</a> *&amp;stats, bool lazy=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Commit an instrumented transaction and start a new one.  <a href="#g6d01a3863578576383768a5456808393"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="../../db/dc7/classw__rc__t.html">rc_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d1e/group___s_s_m_x_c_t.html#g88fcd541415da2a829ddb4e3efd22c68">ss_m::chain_xct</a> (bool lazy=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Commit a transaction and start a new one, inheriting locks.  <a href="#g88fcd541415da2a829ddb4e3efd22c68"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="../../db/dc7/classw__rc__t.html">rc_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d1e/group___s_s_m_x_c_t.html#ge608513aae569ee9514abcc33dd47c53">ss_m::commit_xct_group</a> (<a class="el" href="../../df/d32/classxct__t.html">xct_t</a> *list[], int listlen)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Commit a group of transactions.  <a href="#ge608513aae569ee9514abcc33dd47c53"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="../../db/dc7/classw__rc__t.html">rc_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d1e/group___s_s_m_x_c_t.html#g1ef08428870c5ad773dcb7d95dfe9bff">ss_m::abort_xct</a> (<a class="el" href="../../d9/dee/classsm__stats__info__t.html">sm_stats_info_t</a> *&amp;stats)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Abort an instrumented transaction and get its statistics.  <a href="#g1ef08428870c5ad773dcb7d95dfe9bff"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="../../db/dc7/classw__rc__t.html">rc_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d1e/group___s_s_m_x_c_t.html#g4d196fdd42c4822f8c71befa57495ad2">ss_m::abort_xct</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Abort a transaction.  <a href="#g4d196fdd42c4822f8c71befa57495ad2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="../../d9/da0/classw__base__t.html#7d1c7ae407200662fd16b64de4dcde46">w_base_t::uint4_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d1e/group___s_s_m_x_c_t.html#g8c6df270f40ca4f3de2fc362f35b6dff">ss_m::num_active_xcts</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the number of transactions in active state.  <a href="#g8c6df270f40ca4f3de2fc362f35b6dff"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d1e/group___s_s_m_x_c_t.html#g44eff1b2893c1ada85b61f8f6a989a4a">ss_m::attach_xct</a> (<a class="el" href="../../df/d32/classxct__t.html">xct_t</a> *x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attach the given transaction to the currently-running <a class="el" href="../../d7/d2a/classsmthread__t.html">smthread_t</a>.  <a href="#g44eff1b2893c1ada85b61f8f6a989a4a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d1e/group___s_s_m_x_c_t.html#g62a2b3ff069b05b4178dfc5c15cb9cf4">ss_m::detach_xct</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Detach any attached from the currently-running <a class="el" href="../../d7/d2a/classsmthread__t.html">smthread_t</a>.  <a href="#g62a2b3ff069b05b4178dfc5c15cb9cf4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="../../df/d32/classxct__t.html">xct_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d1e/group___s_s_m_x_c_t.html#g5ab27cd8421f0f60c2701f89349ee299">ss_m::tid_to_xct</a> (const <a class="el" href="../../d8/d12/classtid__t.html">tid_t</a> &amp;tid)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the transaction structure for a given a transaction id.  <a href="#g5ab27cd8421f0f60c2701f89349ee299"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="../../d8/d12/classtid__t.html">tid_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d1e/group___s_s_m_x_c_t.html#ga1e0f29ece464c1a489887c3f16f0fbc">ss_m::xct_to_tid</a> (const <a class="el" href="../../df/d32/classxct__t.html">xct_t</a> *x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the transaction ID for a given a transaction structure.  <a href="#ga1e0f29ece464c1a489887c3f16f0fbc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static xct_state_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d1e/group___s_s_m_x_c_t.html#g6724730bfb2c8faaf3a445150984a26a">ss_m::state_xct</a> (const <a class="el" href="../../df/d32/classxct__t.html">xct_t</a> *x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the transaction state for a given transaction (structure).  <a href="#g6724730bfb2c8faaf3a445150984a26a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g31f44e953b0cedc9f16789db27ffa135"></a><!-- doxytag: member="SSMXCT::xct_log_space_needed" ref="g31f44e953b0cedc9f16789db27ffa135" args="()" -->
static smlevel_0::fileoff_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d1e/group___s_s_m_x_c_t.html#g31f44e953b0cedc9f16789db27ffa135">ss_m::xct_log_space_needed</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the amount of log this transaction would consume if it rolled back.<p>
If a transaction aborts with eOUTOFLOGSPACE this function can be used in conjunction with xct_reserve_log_space to pre-allocate the needed amount of log space before retrying. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gbcb91e9cdd7cd5c2946e49bbffc1852e"></a><!-- doxytag: member="SSMXCT::xct_reserve_log_space" ref="gbcb91e9cdd7cd5c2946e49bbffc1852e" args="(fileoff_t amt)" -->
static <a class="el" href="../../db/dc7/classw__rc__t.html">rc_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d1e/group___s_s_m_x_c_t.html#gbcb91e9cdd7cd5c2946e49bbffc1852e">ss_m::xct_reserve_log_space</a> (fileoff_t amt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Require the specified amount of log space to be available for this transaction before continuing.<p>
If a transaction risks running out of log space it can pre-request some or all of the needed amount before starting in order to improve its chances of success. Other new transactions will be unable to acquire log space before this request is granted (existing ones will be able to commit, unless they also run out of space, because that tends to free up log space and avoids wasting work). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="../../db/dc7/classw__rc__t.html">rc_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d1e/group___s_s_m_x_c_t.html#geb3c76f7ef4cecb2edd02afbf3c1fa97">ss_m::gather_xct_stats</a> (<a class="el" href="../../d9/dee/classsm__stats__info__t.html">sm_stats_info_t</a> &amp;stats, bool reset=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a copy of the statistics from an attached instrumented transaction.  <a href="#geb3c76f7ef4cecb2edd02afbf3c1fa97"></a><br></td></tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="ga18b22291428a1c82a18f4c170298aeb"></a><!-- doxytag: member="ss_m::begin_xct" ref="ga18b22291428a1c82a18f4c170298aeb" args="(timeout_in_ms timeout=WAIT_SPECIFIED_BY_THREAD)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../db/dc7/classw__rc__t.html">rc_t</a> ss_m::begin_xct           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d8/d69/smthread_8h.html#cf834513ff7853bf96601820e038ec9a">timeout_in_ms</a>&nbsp;</td>
          <td class="paramname"> <em>timeout</em> = <code>WAIT_SPECIFIED_BY_THREAD</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Begin a transaction. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>timeout</em>&nbsp;</td><td>Optional, controls blocking behavior.</td></tr>
  </table>
</dl>
Start a new transaction and "attach" it to this thread. No running transaction may be attached to this thread.<p>
Storage manager methods that must block (e.g., to acquire a lock) will use the timeout given. The default timeout is the one associated with this thread.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="../../d8/d69/smthread_8h.html#cf834513ff7853bf96601820e038ec9a">timeout_in_ms</a> </dd></dl>
<dl compact><dt><b>Examples: </b></dt><dd>
<a class="el" href="../../df/d97/create__rec_8cpp-example.html#a23">create_rec.cpp</a>, and <a class="el" href="../../d6/d97/sort__stream_8cpp-example.html#a135">sort_stream.cpp</a>.</dl>
</div>
</div><p>
<a class="anchor" name="ga8bca632d0b0bfb69559bfcd3ad9bdd8"></a><!-- doxytag: member="ss_m::begin_xct" ref="ga8bca632d0b0bfb69559bfcd3ad9bdd8" args="(sm_stats_info_t *stats, timeout_in_ms timeout=WAIT_SPECIFIED_BY_THREAD)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../db/dc7/classw__rc__t.html">rc_t</a> ss_m::begin_xct           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dee/classsm__stats__info__t.html">sm_stats_info_t</a> *&nbsp;</td>
          <td class="paramname"> <em>stats</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d8/d69/smthread_8h.html#cf834513ff7853bf96601820e038ec9a">timeout_in_ms</a>&nbsp;</td>
          <td class="paramname"> <em>timeout</em> = <code>WAIT_SPECIFIED_BY_THREAD</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Begin an instrumented transaction. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>stats</em>&nbsp;</td><td>Pointer to an allocated statistics-holding structure. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>timeout</em>&nbsp;</td><td>Optional, controls blocking behavior.</td></tr>
  </table>
</dl>
No running transaction may be already attached to this thread. A new transaction is started and attached to the running thread.<p>
The transaction will be instrumented. This structure is updated by the storage manager whenever a thread detaches from this transaction. The activity recorded during the time the thread is attached to the transcation will be stored in the per-transaction statistics. <dl compact><dt><b>Attention:</b></dt><dd>It is the client's responsibility to delete the statistics-holding structure.</dd></dl>
Storage manager methods that must block (e.g., to acquire a lock) will use the timeout given. The default timeout is the one associated with this thread.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="../../d8/d69/smthread_8h.html#cf834513ff7853bf96601820e038ec9a">timeout_in_ms</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="gab35cb44896fd3722c5f7d6ef098661a"></a><!-- doxytag: member="ss_m::begin_xct" ref="gab35cb44896fd3722c5f7d6ef098661a" args="(tid_t &amp;tid, timeout_in_ms timeout=WAIT_SPECIFIED_BY_THREAD)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../db/dc7/classw__rc__t.html">rc_t</a> ss_m::begin_xct           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d8/d12/classtid__t.html">tid_t</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>tid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d8/d69/smthread_8h.html#cf834513ff7853bf96601820e038ec9a">timeout_in_ms</a>&nbsp;</td>
          <td class="paramname"> <em>timeout</em> = <code>WAIT_SPECIFIED_BY_THREAD</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Begin a transaction and return the transaction id. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>tid</em>&nbsp;</td><td>Transaction id of new transaction. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>timeout</em>&nbsp;</td><td>Optional, controls blocking behavior.</td></tr>
  </table>
</dl>
No running transaction may be attached to this thread.<p>
Storage manager methods that must block (e.g., to acquire a lock) will use the timeout given. The default timeout is the one associated with this thread.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="../../d8/d69/smthread_8h.html#cf834513ff7853bf96601820e038ec9a">timeout_in_ms</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="gdcc84a1d655f398fa9a054b79eb6e544"></a><!-- doxytag: member="ss_m::commit_xct" ref="gdcc84a1d655f398fa9a054b79eb6e544" args="(bool lazy=false, lsn_t *plastlsn=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../db/dc7/classw__rc__t.html">rc_t</a> ss_m::commit_xct           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>lazy</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d2/d19/classlsn__t.html">lsn_t</a> *&nbsp;</td>
          <td class="paramname"> <em>plastlsn</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Commit a transaction. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>lazy</em>&nbsp;</td><td>Optional, controls flushing of log. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>plastlsn</em>&nbsp;</td><td>If non-null, this is a pointer to a log sequence number into which the storage manager writes the that of the last log record inserted for this transaction.</td></tr>
  </table>
</dl>
Commit the attached transaction and detach it, destroy it. If <em>lazy</em> is true, the log is not synced. This means that recovery of this transaction might not be possible. <dl compact><dt><b>Examples: </b></dt><dd>
<a class="el" href="../../df/d97/create__rec_8cpp-example.html#a27">create_rec.cpp</a>, and <a class="el" href="../../d6/d97/sort__stream_8cpp-example.html#a142">sort_stream.cpp</a>.</dl>
</div>
</div><p>
<a class="anchor" name="g18e0794b043b9341534708cb90752265"></a><!-- doxytag: member="ss_m::commit_xct" ref="g18e0794b043b9341534708cb90752265" args="(sm_stats_info_t *&amp;stats, bool lazy=false, lsn_t *plastlsn=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../db/dc7/classw__rc__t.html">rc_t</a> ss_m::commit_xct           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dee/classsm__stats__info__t.html">sm_stats_info_t</a> *&amp;&nbsp;</td>
          <td class="paramname"> <em>stats</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>lazy</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d2/d19/classlsn__t.html">lsn_t</a> *&nbsp;</td>
          <td class="paramname"> <em>plastlsn</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Commit an instrumented transaction and get its statistics. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>stats</em>&nbsp;</td><td>Get a copy of the statistics for this transaction. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>lazy</em>&nbsp;</td><td>Optional, controls flushing of log. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>plastlsn</em>&nbsp;</td><td>If non-null, this is a pointer to a log sequence number into which the storage manager writes the that of the last log record inserted for this transaction.</td></tr>
  </table>
</dl>
Commit the attached transaction and detach it, destroy it. If <em>lazy</em> is true, the log is not synced. This means that recovery of this transaction might not be possible. 
</div>
</div><p>
<a class="anchor" name="g6d01a3863578576383768a5456808393"></a><!-- doxytag: member="ss_m::chain_xct" ref="g6d01a3863578576383768a5456808393" args="(sm_stats_info_t *&amp;stats, bool lazy=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../db/dc7/classw__rc__t.html">rc_t</a> ss_m::chain_xct           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dee/classsm__stats__info__t.html">sm_stats_info_t</a> *&amp;&nbsp;</td>
          <td class="paramname"> <em>stats</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>lazy</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Commit an instrumented transaction and start a new one. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>stats</em>&nbsp;</td><td>Get a copy of the statistics for the first transaction. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>lazy</em>&nbsp;</td><td>Optional, controls flushing of log.</td></tr>
  </table>
</dl>
Commit the attached transaction and detach it, destroy it. Start a new transaction and attach it to this thread. <dl compact><dt><b>Note:</b></dt><dd><em>The</em> <em>new</em> <em>transaction</em> <em>inherits</em> <em>the</em> <em>locks</em> <em>of</em> <em>the</em> <em>old</em> <em>transaction</em>.</dd></dl>
If <em>lazy</em> is true, the log is not synced. This means that recovery of this transaction might not be possible. 
</div>
</div><p>
<a class="anchor" name="g88fcd541415da2a829ddb4e3efd22c68"></a><!-- doxytag: member="ss_m::chain_xct" ref="g88fcd541415da2a829ddb4e3efd22c68" args="(bool lazy=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../db/dc7/classw__rc__t.html">rc_t</a> ss_m::chain_xct           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>lazy</em> = <code>false</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Commit a transaction and start a new one, inheriting locks. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>lazy</em>&nbsp;</td><td>Optional, controls flushing of log.</td></tr>
  </table>
</dl>
Commit the attached transaction and detach it, destroy it. Start a new transaction and attach it to this thread. <dl compact><dt><b>Note:</b></dt><dd><em>The</em> <em>new</em> <em>transaction</em> <em>inherits</em> <em>the</em> <em>locks</em> <em>of</em> <em>the</em> <em>old</em> <em>transaction</em>.</dd></dl>
If <em>lazy</em> is true, the log is not synced. This means that recovery of the committed transaction might not be possible. 
</div>
</div><p>
<a class="anchor" name="ge608513aae569ee9514abcc33dd47c53"></a><!-- doxytag: member="ss_m::commit_xct_group" ref="ge608513aae569ee9514abcc33dd47c53" args="(xct_t *list[], int listlen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../db/dc7/classw__rc__t.html">rc_t</a> ss_m::commit_xct_group           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/d32/classxct__t.html">xct_t</a> *&nbsp;</td>
          <td class="paramname"> <em>list</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>listlen</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Commit a group of transactions. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>list</em>&nbsp;</td><td>List of pointers to transactions to commit. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>listlen</em>&nbsp;</td><td>Number of transactions in the list.</td></tr>
  </table>
</dl>
Commit each transaction in the list as an all-or-none affair. Any transaction that is attached to the thread will be detached before anything is done.<p>
The purpose of this method is to allow multiple transactions to commit together with a single log record. No voting takes place. The entire list of transaction identifiers must fit in a single log record. If it does not, a descriptive error will be returned and no transaction will be committed. In this case, the server has the option to singly commit each transaction.<p>
If any other error occurs during one of the commits, the error will be returned to the caller and none of the transactions will be committed; they <b>must</b> be aborted thereafter.<p>
This is not intended to be used with transactions that are participating in two-phase commit, but if one of the transactions is participating in two-phase commit, they all must be and they all must be prepared.<p>
Chaining and lazy commit are not offered with this form of commit. If a transaction in the list is instrumented, its statistics resources will be deleted upon successful commit.<p>
<dl compact><dt><b>Note:</b></dt><dd>By taking a list of transaction pointers, this avoids a the tid_to_xct lookup for each transaction, but the server must regard the transaction pointers as invalid after this method returns. The transactions, once committed, do not exist anymore. If an error is returned, the server has to re-verify the transaction pointers by using <a class="el" href="../../d8/d1e/group___s_s_m_x_c_t.html#g5ab27cd8421f0f60c2701f89349ee299">ss_m::tid_to_xct</a> from a separate list of transaction ids to determine which transactions are extant. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g1ef08428870c5ad773dcb7d95dfe9bff"></a><!-- doxytag: member="ss_m::abort_xct" ref="g1ef08428870c5ad773dcb7d95dfe9bff" args="(sm_stats_info_t *&amp;stats)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../db/dc7/classw__rc__t.html">rc_t</a> ss_m::abort_xct           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dee/classsm__stats__info__t.html">sm_stats_info_t</a> *&amp;&nbsp;</td>
          <td class="paramname"> <em>stats</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Abort an instrumented transaction and get its statistics. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>stats</em>&nbsp;</td><td>Get a copy of the statistics for this transaction.</td></tr>
  </table>
</dl>
Abort the attached transaction and detach it, destroy it. 
</div>
</div><p>
<a class="anchor" name="g4d196fdd42c4822f8c71befa57495ad2"></a><!-- doxytag: member="ss_m::abort_xct" ref="g4d196fdd42c4822f8c71befa57495ad2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../db/dc7/classw__rc__t.html">rc_t</a> ss_m::abort_xct           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Abort a transaction. 
<p>
Abort the attached transaction and detach it, destroy it. 
</div>
</div><p>
<a class="anchor" name="g8c6df270f40ca4f3de2fc362f35b6dff"></a><!-- doxytag: member="ss_m::num_active_xcts" ref="g8c6df270f40ca4f3de2fc362f35b6dff" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../d9/da0/classw__base__t.html#7d1c7ae407200662fd16b64de4dcde46">w_base_t::uint4_t</a> ss_m::num_active_xcts           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the number of transactions in active state. 
<p>
While this is thread-safe, the moment a value is returned, it could be out of date. Useful only for debugging. 
</div>
</div><p>
<a class="anchor" name="g44eff1b2893c1ada85b61f8f6a989a4a"></a><!-- doxytag: member="ss_m::attach_xct" ref="g44eff1b2893c1ada85b61f8f6a989a4a" args="(xct_t *x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void ss_m::attach_xct           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/d32/classxct__t.html">xct_t</a> *&nbsp;</td>
          <td class="paramname"> <em>x</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Attach the given transaction to the currently-running <a class="el" href="../../d7/d2a/classsmthread__t.html">smthread_t</a>. 
<p>
It is assumed that the currently running thread is an <a class="el" href="../../d7/d2a/classsmthread__t.html">smthread_t</a>. 
<p>
Definition at line <a class="el" href="../../da/d46/sm_8h-source.html#l01179">1179</a> of file <a class="el" href="../../da/d46/sm_8h-source.html">sm.h</a>.
</div>
</div><p>
<a class="anchor" name="g62a2b3ff069b05b4178dfc5c15cb9cf4"></a><!-- doxytag: member="ss_m::detach_xct" ref="g62a2b3ff069b05b4178dfc5c15cb9cf4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void ss_m::detach_xct           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Detach any attached from the currently-running <a class="el" href="../../d7/d2a/classsmthread__t.html">smthread_t</a>. 
<p>
Sever the connection between the running thread and the transaction. This allow the running thread to attach a different transaction and to perform work in its behalf. 
<p>
Definition at line <a class="el" href="../../da/d46/sm_8h-source.html#l01244">1244</a> of file <a class="el" href="../../da/d46/sm_8h-source.html">sm.h</a>.
</div>
</div><p>
<a class="anchor" name="g5ab27cd8421f0f60c2701f89349ee299"></a><!-- doxytag: member="ss_m::tid_to_xct" ref="g5ab27cd8421f0f60c2701f89349ee299" args="(const tid_t &amp;tid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../df/d32/classxct__t.html">xct_t</a>* ss_m::tid_to_xct           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d8/d12/classtid__t.html">tid_t</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>tid</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the transaction structure for a given a transaction id. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>tid</em>&nbsp;</td><td>Transaction ID.</td></tr>
  </table>
</dl>
Return a pointer to the storage manager's transaction structure. Can be used with detach_xct and attach_xct. 
</div>
</div><p>
<a class="anchor" name="ga1e0f29ece464c1a489887c3f16f0fbc"></a><!-- doxytag: member="ss_m::xct_to_tid" ref="ga1e0f29ece464c1a489887c3f16f0fbc" args="(const xct_t *x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../d8/d12/classtid__t.html">tid_t</a> ss_m::xct_to_tid           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/d32/classxct__t.html">xct_t</a> *&nbsp;</td>
          <td class="paramname"> <em>x</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the transaction ID for a given a transaction structure. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>x</em>&nbsp;</td><td>Pointer to transaction structure.</td></tr>
  </table>
</dl>
Return the transaction ID for the given transaction. 
</div>
</div><p>
<a class="anchor" name="g6724730bfb2c8faaf3a445150984a26a"></a><!-- doxytag: member="ss_m::state_xct" ref="g6724730bfb2c8faaf3a445150984a26a" args="(const xct_t *x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static xct_state_t ss_m::state_xct           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/d32/classxct__t.html">xct_t</a> *&nbsp;</td>
          <td class="paramname"> <em>x</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the transaction state for a given transaction (structure). 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>x</em>&nbsp;</td><td>Pointer to transaction structure.</td></tr>
  </table>
</dl>
Returns the state of the transaction (active, prepared). It is hard to get the state of an aborted or committed transaction, since their structures no longer exist. 
</div>
</div><p>
<a class="anchor" name="geb3c76f7ef4cecb2edd02afbf3c1fa97"></a><!-- doxytag: member="ss_m::gather_xct_stats" ref="geb3c76f7ef4cecb2edd02afbf3c1fa97" args="(sm_stats_info_t &amp;stats, bool reset=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../db/dc7/classw__rc__t.html">rc_t</a> ss_m::gather_xct_stats           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dee/classsm__stats__info__t.html">sm_stats_info_t</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>stats</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>reset</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get a copy of the statistics from an attached instrumented transaction. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>stats</em>&nbsp;</td><td>Returns a copy of the statistics for this transaction. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>reset</em>&nbsp;</td><td>If true, the statistics for this transaction will be zeroed. </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr size="1"><address style="align: right;"><small>Generated on Mon Jan 2 15:14:01 2012 for Shore Storage Manager by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
