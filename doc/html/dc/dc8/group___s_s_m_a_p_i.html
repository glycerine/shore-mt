<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Shore Storage Manager: SHORE Storage Manager Application Programming Interface (SSM API)</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
<link href="../../tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="../../main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="../../modules.html"><span>Modules</span></a></li>
    <li><a href="../../namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="../../classes.html"><span>Classes</span></a></li>
    <li><a href="../../files.html"><span>Files</span></a></li>
    <li><a href="../../dirs.html"><span>Directories</span></a></li>
    <li><a href="../../pages.html"><span>Related&nbsp;Pages</span></a></li>
    <li><a href="../../examples.html"><span>Examples</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
  </ul></div>
<h1>SHORE Storage Manager Application Programming Interface (SSM API)</h1>
<p>
Collaboration diagram for SHORE Storage Manager Application Programming Interface (SSM API):<center><table><tr><td><img src="../../dc/dc8/group___s_s_m_a_p_i.png" border="0" alt="" usemap="#de/da1/dc_2dc8_2group______s__s__m__a__p__i_map">
<map name="de/da1/dc_2dc8_2group______s__s__m__a__p__i_map">
<area href="../../d5/d38/group___s_s_m_v_t_a_b_l_e.html" shape="rect" coords="621,5,726,32" alt="">
<area href="../../d6/ddf/group___m_a_c_r_o_s.html" shape="rect" coords="554,56,793,83" alt="">
<area href="../../d8/db7/group___m_i_s_c.html" shape="rect" coords="618,107,729,133" alt="">
<area href="../../dd/d39/group___s_s_m_s_t_g.html" shape="rect" coords="603,157,743,184" alt="">
<area href="../../d8/d1e/group___s_s_m_x_c_t.html" shape="rect" coords="553,208,793,235" alt="">
<area href="../../d0/dcf/group___i_d_i_o_m_s.html" shape="rect" coords="597,259,750,285" alt="">
<area href="../../d3/dc7/group___i_d_s.html" shape="rect" coords="631,309,715,336" alt="">
<area href="../../de/db0/group___s_s_m_i_n_i_t.html" shape="rect" coords="525,360,822,387" alt="">
<area href="../../d9/d76/group___s_s_m_s_t_a_t_s.html" shape="rect" coords="578,411,769,437" alt="">
<area href="../../df/d27/group___s_s_m_a_p_i_d_e_b_u_g.html" shape="rect" coords="521,461,826,488" alt="">
<area href="../../d9/d23/group___o_p_t_i_o_n_s.html" shape="rect" coords="605,512,741,539" alt="">
</map></td></tr></table></center>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h2><a class="anchor" name="SSMINTRO">
Introduction</a></h2>
Most of the SHORE Storage Manager functionality is presented to the user (server-writer) in two C++ classes, <a class="el" href="../../da/d44/classss__m.html">ss_m</a> and <a class="el" href="../../d7/d2a/classsmthread__t.html">smthread_t</a>. The <a class="el" href="../../da/d44/classss__m.html">ss_m</a> is the SHORE storage manager, a single instance of which must be constructed before any storage manager methods may be used. There cannot be more than one <a class="el" href="../../da/d44/classss__m.html">ss_m</a> instance extant. The construction of the single instance performs recovery. Deletion of the single instance shuts down the storage manager.<p>
The storage manager stores state information in per-thread variables; for this reason, storage manager methods must be called in the context of a storage manager thread, <a class="el" href="../../d7/d2a/classsmthread__t.html">smthread_t</a>. This means they must be called (directly or indirectly) by the run() method of a class derived from <a class="el" href="../../d7/d2a/classsmthread__t.html">smthread_t</a>. As a result, you must write a class to encapsulate your server functionality, and that class must derive from <a class="el" href="../../d7/d2a/classsmthread__t.html">smthread_t</a>, as described in the following pseudo-code:<p>
<div class="fragment"><pre class="fragment">main()
{
    // Marshall all the resources needed to get going:
    // "Open" the sources of work for your server, such as
    // listening on a network socket, or opening an input
    // file for reading.
    //
    // Start up a storage manager:
    your_server_thread_t *server = new your_server_thread_t(...);
    // let the server thread do its thing
    server-&gt;fork();
    // wait until it's done
    server-&gt;join();
    // clean up
    delete server;
    // un-marshall resources (close files, clean up, etc)
}

// This class creates and destroys a storage manager,
// and forks the worker threads that use the storage manager.
class \em your_server_thread_t : public smthread_t 
{
    your_server_thread_t ( ...sources... ) ;
    ~your_server_thread_t () ;
    void run(); // this is virtual in smthread_t
};

// This class performs work given to it by a source.
// It uses the given storage manager instance to perform that work.

class \em your_worker_thread_t : public smthread_t 
{
    your_worker_thread_t (ss_m *ssm, ...source... ) ;
    ~your_worker_thread_t () ;
    void run(); // this waits for work from its assigned source
    // (e.g., from terminal input or from a network connection), and
    // performs the necessary work
};

void your_server_thread_t::run() 
{
     // marshal resources neeeded for storage manager work
     // including run-time options (see discussion below).
     ss_m *ssm = new ss_m(...);

     // Fork off some number of threads 
     // worker threads that use the instance ssm.
     // Either pass ssm to these threads' constructors or
     // make ssm global.
     for(int i = 0; i &lt; num_threads; i++) {
         workers[i] = new your_worker_t(ssm, ... source ... );
     }

     // smthreads' run() method is not called until thread is forked.
     for(int i = 0; i &lt; NUM_THREADS; i++) {
         workers[i]-&gt;fork();
     }

     // Await and join worker threads. Join() returns when thread's
     // run() method returns.
     for(int i = 0; i &lt; NUM_THREADS; i++) {
         workers[i]-&gt;join();
     }
     for(int i = 0; i &lt; NUM_THREADS; i++) {
         delete workers[i];
     }

     delete ssm;
     // un-marshal (clean up) resources neeeded for storage manager work
} // a join() on this thread now returns.

 * </pre></div><p>
The storage manager relies heavily on certain programming idioms to make sure return values from all methods are checked. The idioms are encapsulated in preprocessor macros. As a user of the storage manager, you strongly encouraged to use these idioms. Although the use of the macros is optional, perusal of the storage manager source code and examples will be easier if you are aware of them. They are described in <a class="el" href="../../d0/dcf/group___i_d_i_o_m_s.html">Programming Idioms</a>, <a class="el" href="../../d6/ddf/group___m_a_c_r_o_s.html">Significant C Preprocessor Macros</a>, and <a class="el" href="../../d1/d83/w__rc_8h.html">w_rc.h</a>. Before you spend much time looking at examples, it would be worthwhile to look at the macro definitions in <a class="el" href="../../d1/d83/w__rc_8h.html">w_rc.h</a>.<p>
The storage manager is parameterized with options and their associated values. The options determine such things as the size of the buffer pool and lock table, the location of the log, lock granularity, certain caching behavior. Most of these have default values, but some options (such as a path name indicating the location of the log) do not have a default value and must be given values at run time.<p>
An options-processing package is provided for this purpose. It handles the parsing of option names and values, which may be given on the command line, or in a file or input stream. Because certain options <em>must</em> be given a value at run-time, the use of this package is <em>not</em> optional: every server must at least create a minimal set of options and give them values. In the above pseudo-code, invoking the run-time options package would be inserted in <div class="fragment"><pre class="fragment"> your_server_thread_t::run() 
</pre></div> or in <div class="fragment"><pre class="fragment"> main(). 
</pre></div><p>
The storage manager release comes with small examples illustrating how the options are to be used.<p>
See<ul>
<li><a class="el" href="../../d7/dfc/group___s_s_m_o_p_t.html">List of Run-Time Options</a> for an inventory of the storage manager's options,</li><li><a class="el" href="../../d9/d23/group___o_p_t_i_o_n_s.html">Run-Time Options</a> for a discussion of code to initialize the options,</li><li><a class="el" href="../../de/db0/group___s_s_m_i_n_i_t.html">Starting Up, Shutting Down, Thread Context</a> and <a class="el" href="../../d7/d2a/classsmthread__t.html">smthread_t</a> for discussion of how to initialize and start up a storage manager,</li><li><a class="el" href="../../d8/d8e/startstop_8cpp-example.html">startstop::cpp</a> for an example of the minimal required use of options in a server, and</li><li>the example consisting of <a class="el" href="../../df/d97/create__rec_8cpp-example.html">create_rec::cpp</a> and <a class="el" href="../../d3/d39/init__config__options_8cpp-example.html">init_config_options::cpp</a> for a more complete example.</li></ul>
<p>
With few exceptions, the storage manager does work on behalf of a <em>transaction</em> and the storage manager acquires locks for that transaction, e.g., to read a record, the storage manager acquires read locks and to update a record it acquires write locks. Rather than expect the transaction of interest to be given as an argument to every storage manager method, the storage manager assumes an <em>attachment</em> between a storage manager thread and a transaction. The attachment is not fixed and permanent; rather, a worker thread can choose which transaction it is serving, and can set aside transaction A and proceed to serve transaction B, while another thread can pick up transaction B and do work on its behalf. A thread cannot serve more than one transaction at any time, and, except under limited circumstances, a transaction cannot be served by more than one thread at a time. Through the API, a storage manager thread can :<ul>
<li>start a new transaction (implictly attaching the transaction to the thread)</li><li>detach the attached transaction</li><li>attach an arbitrary transaction</li><li>perform work on behalf of the attached transaction</li><li>prepare the attached transaction</li><li>commit or abort the attached transaction (implicitly detaching it)</li></ul>
<p>
See <a class="el" href="../../d8/d1e/group___s_s_m_x_c_t.html">Transactions, Locking and Logging</a> for details.<p>
Persistent data are contained in a variety of storage structures (files of records, indexes, etc.). All data structures reside in volumes, which are <em>mounted</em>. Identifiers for data on the volume contain that volume number. The act of mounting a volume creates the association of the volume number with the path name of a Unix file. OK, that's a lie. The original design of SHORE called for multiple volumes per Unix file, and so the file was associated with a <em>device</em>, and volumes were contained in a device. SHORE never supported multiple volumes on a device, but the device-volume distinction remains. Thus, a server mounts (and formats, if necessary) a device, which is identified by a path name. Then the server creates a volume (numbered), which resides on the device.<p>
See <a class="el" href="../../dd/d39/group___s_s_m_s_t_g.html">Storage Structures</a> for details about storage structures, and see <a class="el" href="../../d3/dc7/group___i_d_s.html">Identifiers</a> for a description of the identifiers used for storage structures and transactions.<p>
Please refer to the list of modules at the bottom of this page for more information.<h2><a class="anchor" name="COMPILE">
Compiling and Linking Server Code</a></h2>
The compiler invocation requires certain flags to ensure the use of pthreads and the LP64 data model; it also has to include the storage manager's libraries.<p>
When the storage manager is built, its "make" flags are written to a file called<ul>
<li>"makeflags" in the source root directory (or the installed include/ directory). These flags usually include (subject to platform):</li><li>-DARCH_LP64 -m64</li><li>-D_POSIX_THREAD_SEMANTICS -D_REENTRANT -pthread (Linux)</li><li>-library=stlport4 -features=extensions,zla -DSOLARIS2 -mt -D_POSIX_THREAD_SEMANTICS -D_REENTRANT -lpthread (Solaris)</li></ul>
<p>
The list of libraries must include -lrt and possibly -lnsl.<h2><a class="anchor" name="EXAMPLES">
Examples</a></h2>
Any code that uses the SHORE Storage Manager requires <div class="fragment"><pre class="fragment"><span class="preprocessor"> #include &lt;<a class="code" href="../../dd/dcd/sm__vas_8h.html">sm_vas.h</a>&gt;</span>
</pre></div> This header file encapsulates all the storage manager header files needed by a value-added server.<h3><a class="anchor" name="EXMIN">
A Minimal Example</a></h3>
For a simple example, see <a class="el" href="../../d8/d8e/startstop_8cpp-example.html">startstop::cpp</a><h3><a class="anchor" name="EXINIT_CONFIG_OPTIONS">
Setting Up Run-Time Options</a></h3>
The example <a class="el" href="../../d3/d39/init__config__options_8cpp-example.html">init_config_options::cpp</a> demonstrates a more extensive handling of run-time options, and is used in other examples, below.<h3><a class="anchor" name="EXCREATE_REC">
Creating a file of Records</a></h3>
The example <a class="el" href="../../df/d97/create__rec_8cpp-example.html">create_rec::cpp</a> shows a server that creates a file of records. Thus, it also contains code to initialize a volume and create a file.<h3><a class="anchor" name="EXLOG_EXCEED">
Use of ss_m::ss_m Arguments</a></h3>
The example <a class="el" href="../../d0/d88/log__exceed_8cpp-example.html">log_exceed::cpp</a> demonstrates the use of the arguments to the storage manager constructor (<a class="el" href="../../de/db0/group___s_s_m_i_n_i_t.html#g4b4479aa4533cf55b6baccc3758d08b2">ss_m::ss_m</a>). It is an extension of the above example that generates enough log to run out of log space. 
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Modules</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/dcf/group___i_d_i_o_m_s.html">Programming Idioms</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/ddf/group___m_a_c_r_o_s.html">Significant C Preprocessor Macros</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dc7/group___i_d_s.html">Identifiers</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db0/group___s_s_m_i_n_i_t.html">Starting Up, Shutting Down, Thread Context</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d23/group___o_p_t_i_o_n_s.html">Run-Time Options</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d39/group___s_s_m_s_t_g.html">Storage Structures</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d1e/group___s_s_m_x_c_t.html">Transactions, Locking and Logging</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d76/group___s_s_m_s_t_a_t_s.html">Storage Manager Statistics</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d38/group___s_s_m_v_t_a_b_l_e.html">Virtual Tables</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/db7/group___m_i_s_c.html">Miscellaneous</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d27/group___s_s_m_a_p_i_d_e_b_u_g.html">Storage Manager API Methods for Debugging</a></td></tr>

</table>
<hr size="1"><address style="align: right;"><small>Generated on Mon Jan 2 15:14:00 2012 for Shore Storage Manager by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
