<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Shore Storage Manager: B+-Tree Indexes</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
<link href="../../tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="../../main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="../../modules.html"><span>Modules</span></a></li>
    <li><a href="../../namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="../../classes.html"><span>Classes</span></a></li>
    <li><a href="../../files.html"><span>Files</span></a></li>
    <li><a href="../../dirs.html"><span>Directories</span></a></li>
    <li><a href="../../pages.html"><span>Related&nbsp;Pages</span></a></li>
    <li><a href="../../examples.html"><span>Examples</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
  </ul></div>
<h1>B+-Tree Indexes<br>
<small>
[<a class="el" href="../../dd/d39/group___s_s_m_s_t_g.html">Storage Structures</a>]</small>
</h1>
<p>
Collaboration diagram for B+-Tree Indexes:<center><table><tr><td><img src="../../d4/df6/group___s_s_m_b_t_r_e_e.png" border="0" alt="" usemap="#d6/d9a/d4_2df6_2group______s__s__m__b__t__r__e__e_map">
<map name="d6/d9a/d4_2df6_2group______s__s__m__b__t__r__e__e_map">
<area href="../../dd/d39/group___s_s_m_s_t_g.html" shape="rect" coords="6,5,146,32" alt="">
</map></td></tr></table></center>
<hr><a name="_details"></a><h2>Detailed Description</h2>
The storage manager supports B+-Tree indexes provide associative access to data by associating keys with values in 1:1 or many:1 relationships. Keys may be composed of any of the basic C-language types (integer, unsigned, floating-point of several sizes) or variable-length character strings (wide characters are <b>not</b> supported).<p>
The number of key-value pairs that an index can hold is limited by the space available on the volume containing the index. <a class="anchor" name="max_entry_size"></a> The combined sizes of the key and value must be less than or equal to <a class="el" href="../../d4/df6/group___s_s_m_b_t_r_e_e.html#max_entry_size">max_entry_size</a>, which is a function of the page size, and is such that two entries of this size fit on a page along with all the page and entry metadata. See <a class="el" href="../../db/d3e/structsm__config__info__t.html">sm_config_info_t</a> and <a class="el" href="../../d5/d46/group___o_p_t.html#g5d712983ca1189ce8e7f81a8116962e8">ss_m::config_info</a>.<p>
The minimum size of a B-Tree index is 8 pages (1 extent).<p>
A variety of locking protocols is supported:<ul>
<li>none : acquire no locks on the {key,value} pairs in the index, although an intention lock might be acquired on the index.</li><li>kvl : key-value locking See <a class="el" href="../../references.html#MOH1">[MOH1]</a>. The key or key-value pair is hashed into a 4-byte value and used with the given store id to make a lock id.</li><li>im : index-management locking See <a class="el" href="../../references.html#MOH1">[MOH1]</a>. The "value" portion of the key-value lock is taken to be a record id, which is used for the lock id.</li><li>modified kvl : an ad-hoc protocol used by the Paradise project. See <a class="el" href="../../d2/dc8/classscan__index__i.html#MODKVL">the scan_index_i constructor</a>. As with index-management locking, the "value" portion of the key-value lock is taken to be a record id, which is used for the lock id.</li><li>file : full-index locking.</li></ul>
<h2><a class="anchor" name="key_description">
Key Types</a></h2>
A B+-Tree index key has a type determined when the index is created. All keys are stored in lexicographic format based on an interpretation of the key determined by the key description given when the index is created. Lookups on the B+-Tree then involve a single byte-by-byte comparison of two byte-strings, each composed of its concatenated sub-keys.<p>
The key description is a null-terminated string as follows: <div class="fragment"><pre class="fragment">     &lt;key_decription&gt;     ::=  &lt;fixed_len_part&gt;*  &lt;variable_len_part&gt;  |
                               &lt;fixed_len_part&gt;+ 
     &lt;fixed_len_part&gt;     ::=  &lt;type&gt; &lt;len&gt; 
     &lt;variable_len_part&gt;  ::=  &lt;type&gt; '*' &lt;len&gt;
     &lt;type&gt;               ::=  'i' | 'u' | 'f' | 'b' | 'I' | 'U' | 'F' | 'B'
     &lt;len&gt;                ::=   [1-9][0-9]*
     </pre></div> Thus, a key may have any number of fixed-length parts followed by at most one variable-length part.<p>
The fixed-length parts (if present) consist of a type and a length.<p>
The variable-length part (if present) consists of a type and a length separated by an asterisk, which is what distinguishes a variable-length from a fixed-length part.<p>
Types and permissible lengths are:<ul>
<li>integer (1,2,4,8)</li><li>unsigned (1,2,4,8)</li><li>floating (4,8)</li><li>uninterpreted byte (any length greater than zero)</li></ul>
<p>
A capital letter indicates that the key part may be compressed. Only prefix compression is implemented, so it makes sense to compress if the first part of the key is compressible.<p>
Examples:<ul>
<li>"B40u4u2u2" : 40-byte character string followed by a 4-byte integer, a 2-byte integer and a 2-byte integer, such as one might use for name.year.mo.day. The character string is prefix-compressed.</li><li>"f8" : an 8-byte floating-point number (double)</li><li>"I8B*1000" : An 8-byte integer followed by an uninterpreted string of up to 1000 bytes, all prefix-compressed.</li></ul>
<p>
<dl compact><dt><b>Note:</b></dt><dd>Wide characters are not supported.</dd></dl>
This key descriptor is stored in the <a class="el" href="../../d3/d8b/classsm__store__info__t.html">sm_store_info_t</a>, which is stored on the volume and is available with the method <a class="el" href="../../d2/dc6/group___s_s_m_s_t_o_r_e.html#g9dccea70316f63f876c29aa44098388e">ss_m::get_store_info</a>. Keys are stored in <a class="el" href="../../d6/d82/group___s_s_m_b_u_l_k_l_d.html#LEXICOFORMAT">lexicographic format</a>. The storage manager knows how to convert all the key types listed above. When duplicates are permitted, the index assumes that the elements are in lexicographic order when searching for a &lt;key,element&gt; pair.<h2><a class="anchor" name="XXXX1">
Bulk Loading</a></h2>
Bulk-loading of all index types is supported. See <a class="el" href="../../d6/d82/group___s_s_m_b_u_l_k_l_d.html">Bulk-Loading Indexes</a>. 
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="../../db/dc7/classw__rc__t.html">rc_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df6/group___s_s_m_b_t_r_e_e.html#g03630884ad995c97b819482a41b9edce">ss_m::create_index</a> (<a class="el" href="../../d3/d3f/structvid__t.html">vid_t</a> vid, <a class="el" href="../../de/d81/sm__base_8h.html#18b9ecf3181582ef59abfd9c0b377594">ndx_t</a> ntype, store_property_t property, const char *key_desc, <a class="el" href="../../de/d81/sm__base_8h.html#8a4ace36542f82f7a5e908a7df721a57">concurrency_t</a> cc, <a class="el" href="../../da/d5b/structstid__t.html">stid_t</a> &amp;stid)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a B+-Tree index.  <a href="#g03630884ad995c97b819482a41b9edce"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="../../db/dc7/classw__rc__t.html">rc_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df6/group___s_s_m_b_t_r_e_e.html#ge7c49e0d9c920a9ffa8f9694915dddb0">ss_m::create_index</a> (<a class="el" href="../../d3/d3f/structvid__t.html">vid_t</a> vid, <a class="el" href="../../de/d81/sm__base_8h.html#18b9ecf3181582ef59abfd9c0b377594">ndx_t</a> ntype, store_property_t property, const char *key_desc, <a class="el" href="../../da/d5b/structstid__t.html">stid_t</a> &amp;stid)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a B+-Tree or R*-Tree index.  <a href="#ge7c49e0d9c920a9ffa8f9694915dddb0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="../../db/dc7/classw__rc__t.html">rc_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df6/group___s_s_m_b_t_r_e_e.html#g06b024a25161b482b5a0c462abb9fd2e">ss_m::destroy_index</a> (const <a class="el" href="../../da/d5b/structstid__t.html">stid_t</a> &amp;iid)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroy a B+-Tree index.  <a href="#g06b024a25161b482b5a0c462abb9fd2e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="../../db/dc7/classw__rc__t.html">rc_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df6/group___s_s_m_b_t_r_e_e.html#geb4a23f372a7aa3acf3e37cb7af8f1c6">ss_m::create_assoc</a> (<a class="el" href="../../da/d5b/structstid__t.html">stid_t</a> stid, const <a class="el" href="../../d8/ddb/classvec__t.html">vec_t</a> &amp;key, const <a class="el" href="../../d8/ddb/classvec__t.html">vec_t</a> &amp;el)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an entry in a B+-Tree index.  <a href="#geb4a23f372a7aa3acf3e37cb7af8f1c6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="../../db/dc7/classw__rc__t.html">rc_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df6/group___s_s_m_b_t_r_e_e.html#g693ae9e22e6ff19608c737427f37c3e7">ss_m::destroy_assoc</a> (<a class="el" href="../../da/d5b/structstid__t.html">stid_t</a> stid, const <a class="el" href="../../d8/ddb/classvec__t.html">vec_t</a> &amp;key, const <a class="el" href="../../d8/ddb/classvec__t.html">vec_t</a> &amp;el)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove an entry from a B+-Tree index. If your index is non-unique (i.e., it may contain multiple entries per key), use destroy_all_assoc.  <a href="#g693ae9e22e6ff19608c737427f37c3e7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="../../db/dc7/classw__rc__t.html">rc_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df6/group___s_s_m_b_t_r_e_e.html#ge2cd584f6f96cdda4d5f1f9698f11c87">ss_m::destroy_all_assoc</a> (<a class="el" href="../../da/d5b/structstid__t.html">stid_t</a> stid, const <a class="el" href="../../d8/ddb/classvec__t.html">vec_t</a> &amp;key, int &amp;num_removed)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroy all entries associated with a key in a B+-Tree index.  <a href="#ge2cd584f6f96cdda4d5f1f9698f11c87"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="../../db/dc7/classw__rc__t.html">rc_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df6/group___s_s_m_b_t_r_e_e.html#g53f904bc1820680bdd05640ec4224d76">ss_m::find_assoc</a> (<a class="el" href="../../da/d5b/structstid__t.html">stid_t</a> stid, const <a class="el" href="../../d8/ddb/classvec__t.html">vec_t</a> &amp;key, void *el, smsize_t &amp;elen, bool &amp;found)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find an entry associated with a key in a B+-Tree index.  <a href="#g53f904bc1820680bdd05640ec4224d76"></a><br></td></tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="g03630884ad995c97b819482a41b9edce"></a><!-- doxytag: member="ss_m::create_index" ref="g03630884ad995c97b819482a41b9edce" args="(vid_t vid, ndx_t ntype, store_property_t property, const char *key_desc, concurrency_t cc, stid_t &amp;stid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../db/dc7/classw__rc__t.html">rc_t</a> ss_m::create_index           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/d3f/structvid__t.html">vid_t</a>&nbsp;</td>
          <td class="paramname"> <em>vid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../da/d44/classss__m.html#901caa62fd2c03e33bec050c30dd828b">ndx_t</a>&nbsp;</td>
          <td class="paramname"> <em>ntype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../da/d44/classss__m.html#a7a0a9b5677337b6d5a4e3f42d9fa149">store_property_t</a>&nbsp;</td>
          <td class="paramname"> <em>property</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>key_desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../da/d44/classss__m.html#50662c89c6fd0f384a655ca11e78b861">concurrency_t</a>&nbsp;</td>
          <td class="paramname"> <em>cc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../da/d5b/structstid__t.html">stid_t</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>stid</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a B+-Tree index. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>vid</em>&nbsp;</td><td>Volume on which to create the index. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ntype</em>&nbsp;</td><td>Type of index. Legitimate values are:<ul>
<li>t_btree : B+-Tree with duplicate keys allowed</li><li>t_uni_btree : B+-Tree without duplicate keys </li></ul>
</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>property</em>&nbsp;</td><td>Logging level of store. Legitimate values are:<ul>
<li>t_regular</li><li>t_load_file</li><li>t_insert_file See sm_store_property_t for details. </li></ul>
</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>key_desc</em>&nbsp;</td><td>Description of key type. See <a class="el" href="../../d4/df6/group___s_s_m_b_t_r_e_e.html#key_description">Key Types</a> for details. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>cc</em>&nbsp;</td><td>The locking protocol to use with this index. See <a class="el" href="../../de/d81/sm__base_8h.html#8a4ace36542f82f7a5e908a7df721a57">smlevel_0::concurrency_t</a> and <a class="el" href="../../d4/df6/group___s_s_m_b_t_r_e_e.html">B+-Tree Indexes</a>. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>stid</em>&nbsp;</td><td>New store ID will be returned here. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ge7c49e0d9c920a9ffa8f9694915dddb0"></a><!-- doxytag: member="ss_m::create_index" ref="ge7c49e0d9c920a9ffa8f9694915dddb0" args="(vid_t vid, ndx_t ntype, store_property_t property, const char *key_desc, stid_t &amp;stid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../db/dc7/classw__rc__t.html">rc_t</a> ss_m::create_index           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/d3f/structvid__t.html">vid_t</a>&nbsp;</td>
          <td class="paramname"> <em>vid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../da/d44/classss__m.html#901caa62fd2c03e33bec050c30dd828b">ndx_t</a>&nbsp;</td>
          <td class="paramname"> <em>ntype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../da/d44/classss__m.html#a7a0a9b5677337b6d5a4e3f42d9fa149">store_property_t</a>&nbsp;</td>
          <td class="paramname"> <em>property</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>key_desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../da/d5b/structstid__t.html">stid_t</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>stid</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a B+-Tree or R*-Tree index. 
<p>
<dl compact><dt><b>Attention:</b></dt><dd>For backward compatibility. Will be deprecated later. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g06b024a25161b482b5a0c462abb9fd2e"></a><!-- doxytag: member="ss_m::destroy_index" ref="g06b024a25161b482b5a0c462abb9fd2e" args="(const stid_t &amp;iid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../db/dc7/classw__rc__t.html">rc_t</a> ss_m::destroy_index           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/d5b/structstid__t.html">stid_t</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>iid</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destroy a B+-Tree index. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>iid</em>&nbsp;</td><td>ID of the index to be destroyed. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="geb4a23f372a7aa3acf3e37cb7af8f1c6"></a><!-- doxytag: member="ss_m::create_assoc" ref="geb4a23f372a7aa3acf3e37cb7af8f1c6" args="(stid_t stid, const vec_t &amp;key, const vec_t &amp;el)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../db/dc7/classw__rc__t.html">rc_t</a> ss_m::create_assoc           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../da/d5b/structstid__t.html">stid_t</a>&nbsp;</td>
          <td class="paramname"> <em>stid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d8/ddb/classvec__t.html">vec_t</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d8/ddb/classvec__t.html">vec_t</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>el</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create an entry in a B+-Tree index. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>stid</em>&nbsp;</td><td>ID of the index. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>key</em>&nbsp;</td><td>Key for the association to be created. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>el</em>&nbsp;</td><td>Element for the association to be created.</td></tr>
  </table>
</dl>
The combined sizes of the key and element vectors must be less than or equal to <a class="el" href="../../d4/df6/group___s_s_m_b_t_r_e_e.html#max_entry_size">max_entry_size</a>. <dl compact><dt><b>Examples: </b></dt><dd>
<a class="el" href="../../df/d97/create__rec_8cpp-example.html#a31">create_rec.cpp</a>.</dl>
</div>
</div><p>
<a class="anchor" name="g693ae9e22e6ff19608c737427f37c3e7"></a><!-- doxytag: member="ss_m::destroy_assoc" ref="g693ae9e22e6ff19608c737427f37c3e7" args="(stid_t stid, const vec_t &amp;key, const vec_t &amp;el)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../db/dc7/classw__rc__t.html">rc_t</a> ss_m::destroy_assoc           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../da/d5b/structstid__t.html">stid_t</a>&nbsp;</td>
          <td class="paramname"> <em>stid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d8/ddb/classvec__t.html">vec_t</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d8/ddb/classvec__t.html">vec_t</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>el</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Remove an entry from a B+-Tree index. If your index is non-unique (i.e., it may contain multiple entries per key), use destroy_all_assoc. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>stid</em>&nbsp;</td><td>ID of the index. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>key</em>&nbsp;</td><td>Key of the entry to be removed. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>el</em>&nbsp;</td><td>Element (value) of the entry to be removed. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ge2cd584f6f96cdda4d5f1f9698f11c87"></a><!-- doxytag: member="ss_m::destroy_all_assoc" ref="ge2cd584f6f96cdda4d5f1f9698f11c87" args="(stid_t stid, const vec_t &amp;key, int &amp;num_removed)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../db/dc7/classw__rc__t.html">rc_t</a> ss_m::destroy_all_assoc           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../da/d5b/structstid__t.html">stid_t</a>&nbsp;</td>
          <td class="paramname"> <em>stid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d8/ddb/classvec__t.html">vec_t</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>num_removed</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destroy all entries associated with a key in a B+-Tree index. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>stid</em>&nbsp;</td><td>ID of the index. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>key</em>&nbsp;</td><td>Key of the entries to be removed. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>num_removed</em>&nbsp;</td><td>The number of entries removed is returned here. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g53f904bc1820680bdd05640ec4224d76"></a><!-- doxytag: member="ss_m::find_assoc" ref="g53f904bc1820680bdd05640ec4224d76" args="(stid_t stid, const vec_t &amp;key, void *el, smsize_t &amp;elen, bool &amp;found)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../db/dc7/classw__rc__t.html">rc_t</a> ss_m::find_assoc           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../da/d5b/structstid__t.html">stid_t</a>&nbsp;</td>
          <td class="paramname"> <em>stid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d8/ddb/classvec__t.html">vec_t</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>el</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">smsize_t &amp;&nbsp;</td>
          <td class="paramname"> <em>elen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&nbsp;</td>
          <td class="paramname"> <em>found</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find an entry associated with a key in a B+-Tree index. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>stid</em>&nbsp;</td><td>ID of the index. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>key</em>&nbsp;</td><td>Key of the entries to be removed. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>el</em>&nbsp;</td><td>Element associated with the given key will be copied into this buffer. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>elen</em>&nbsp;</td><td>Length of buffer into which the result will be written. If too small, eRECWONTFIT will be returned. Length of result will be returned here. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>found</em>&nbsp;</td><td>True if an entry is found.</td></tr>
  </table>
</dl>
If the index is not unique (allows duplicates), the first element found with the given key will be returned.<p>
To locate all entries associated with a non-unique key, you must use <a class="el" href="../../d2/dc8/classscan__index__i.html">scan_index_i</a>, q.v.. <dl compact><dt><b>Examples: </b></dt><dd>
<a class="el" href="../../df/d97/create__rec_8cpp-example.html#a26">create_rec.cpp</a>.</dl>
</div>
</div><p>
<hr size="1"><address style="align: right;"><small>Generated on Mon Jan 2 15:14:01 2012 for Shore Storage Manager by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
