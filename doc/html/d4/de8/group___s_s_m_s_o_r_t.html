<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Shore Storage Manager: Sorting</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
<link href="../../tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="../../main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="../../modules.html"><span>Modules</span></a></li>
    <li><a href="../../namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="../../classes.html"><span>Classes</span></a></li>
    <li><a href="../../files.html"><span>Files</span></a></li>
    <li><a href="../../dirs.html"><span>Directories</span></a></li>
    <li><a href="../../pages.html"><span>Related&nbsp;Pages</span></a></li>
    <li><a href="../../examples.html"><span>Examples</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
  </ul></div>
<h1>Sorting<br>
<small>
[<a class="el" href="../../dd/d39/group___s_s_m_s_t_g.html">Storage Structures</a>]</small>
</h1>
<p>
Collaboration diagram for Sorting:<center><table><tr><td><img src="../../d4/de8/group___s_s_m_s_o_r_t.png" border="0" alt="" usemap="#d7/dec/d4_2de8_2group______s__s__m__s__o__r__t_map">
<map name="d7/dec/d4_2de8_2group______s__s__m__s__o__r__t_map">
<area href="../../dd/d39/group___s_s_m_s_t_g.html" shape="rect" coords="6,5,146,32" alt="">
</map></td></tr></table></center>
<hr><a name="_details"></a><h2>Detailed Description</h2>
The storage manager provides two tools for sorting, the class <a class="el" href="../../da/d1c/classsort__stream__i.html">sort_stream_i</a> and the method <a class="el" href="../../d4/de8/group___s_s_m_s_o_r_t.html#gaff9edeb900d2b62af637138849d08aa">ss_m::sort_file</a>.<p>
The class <a class="el" href="../../da/d1c/classsort__stream__i.html">sort_stream_i</a> implements sorting of &lt;key,elem&gt; pairs with a simple interface. It is an adjunct of bulk-loading indexes. One inserts &lt;key,elem&gt; pairs into the stream, and then iterates over the stream with its <a class="el" href="../../da/d1c/classsort__stream__i.html#912549730adfcf5235ef72ac37bf9d95">sort_stream_i::get_next</a> method to retrieve the pairs in order. The <a class="el" href="../../da/d1c/classsort__stream__i.html">sort_stream_i</a> uses temporary files as necessary to store the data stream.<p>
The storage manager function <a class="el" href="../../d4/de8/group___s_s_m_s_o_r_t.html#gaff9edeb900d2b62af637138849d08aa">ss_m::sort_file</a> implements a polyphase merge-sort.<p>
Both methods offer a variety of run-time options. The options are specified with different APIs:<ul>
<li>The <a class="el" href="../../da/d1c/classsort__stream__i.html">sort_stream_i</a> uses <a class="el" href="../../d1/dbb/structssm__sort_1_1key__info__t.html">ssm_sort::key_info_t</a> to describe keys and <a class="el" href="../../db/d66/structssm__sort_1_1sort__parm__t.html">ssm_sort::sort_parm_t</a> to describe behavior options.</li><li>The <a class="el" href="../../d4/de8/group___s_s_m_s_o_r_t.html#gaff9edeb900d2b62af637138849d08aa">ss_m::sort_file</a> uses <a class="el" href="../../d7/d50/classssm__sort_1_1sort__keys__t.html">ssm_sort::sort_keys_t</a> to describe keys and behavior options.</li></ul>
<p>
<dl compact><dt><b>Note:</b></dt><dd>Historical note: The original implementation of the sort_file method used the same APIs (for specifying sort behavior and describing keys) as <a class="el" href="../../da/d1c/classsort__stream__i.html">sort_stream_i</a>, but that implementation for sort_file was inadequate for the needs of the projects using the storage manager at the time (viz user-defined key types, marshalling and unmarshalling, etc.). The new implementation is more general, but the <a class="el" href="../../da/d1c/classsort__stream__i.html">sort_stream_i</a> has not been rewritten to use the new options- and key- descriptor classes.</dd></dl>
See <a class="el" href="../../da/d1c/classsort__stream__i.html">sort_stream_i</a> for details and sort_stream::cpp for an example of its use. The balance of this section describes the use of <a class="el" href="../../d4/de8/group___s_s_m_s_o_r_t.html#gaff9edeb900d2b62af637138849d08aa">ss_m::sort_file</a> and its application to bulk-loading.<p>
Sort_file supports:<ul>
<li>sorting on one or more keys</li><li>key types may be<ul>
<li>fundamental (predefined) or user-defined</li><li>derived or embedded (subject to certain limitations - see <a class="el" href="../../d4/de8/group___s_s_m_s_o_r_t.html#SORTKEYS">Keys</a> )</li></ul>
</li><li>records being sorted may require marshalling when read from disk to memory and unmarshalling when written back to disk</li><li>the result of the sort can be<ul>
<li>a sorted copy of the input file</li><li>a file ready for bulk-loading an index to the original file</li></ul>
</li></ul>
<p>
For all this generality, the sort uses <a class="el" href="../../d4/de8/group___s_s_m_s_o_r_t.html#SORTCALLBACK">callbacks</a> to the server for such things as<ul>
<li>key comparisons</li><li>key derivation</li><li>object marshalling and unmarshalling</li><li>producing the final form of keys for output, when the sort key is not the key to be loaded into the index (for example consider R-trees: a polygon is the index key, but the records are sorted on the polygon's Hilbert value)</li></ul>
<h2><a class="anchor" name="SORTRUN">
Runs</a></h2>
The sort takes as many runs as required to read and sort the entire input file, while limiting the amount of memory used. The run size is given as an argument to sort_file.<p>
The sort uses temporary files when the input file contains more records than can fit in one run (determined by the run size). These temporary files may be spread across multiple volumes, which is useful if the volumes reside on different spindles.<p>
If the entire input file fits into the buffer pool pages of one run, much of the complexity of the sort is eliminated, because the copying of objects and metadata to scratch files is unnecessary, but for the general (polyphase) case, behavioral options describe how the writing to scratch files is handled, and these options depend on the kind of output desired (see <a class="el" href="../../d4/de8/group___s_s_m_s_o_r_t.html#SORTOUTPUT">Behavior and Results of Sort</a>).<h2><a class="anchor" name="SORTCALLBACK">
Callbacks</a></h2>
The sort has to call back to the server for<p>
<ul>
<li>marshalling a record (<a class="el" href="../../d4/de8/group___s_s_m_s_o_r_t.html#gf75f6def6e04b87958c17d733cd5a7ed">ssm_sort::MOF</a>): When a record is first encountered in the input file, it may be marshalled to produce an in-memory version of the entire object (presumably byte-swapped, pointer-swizzled, etc.). This copy of the record (in the form of an object_t, which is a handle for the record or in-memory representation) is passed to the next callback function (<a class="el" href="../../d4/de8/group___s_s_m_s_o_r_t.html#g7f3d8ea3eb5546e42d9c8052400721fb">ssm_sort::CSKF</a>). If a marshal function is supplied it is called at least once on every record.</li></ul>
<p>
<ul>
<li>creating or locating a key (<a class="el" href="../../d4/de8/group___s_s_m_s_o_r_t.html#g7f3d8ea3eb5546e42d9c8052400721fb">ssm_sort::CSKF</a>): This callback locates or derives a key for the object. Its result is an skey_t, which is a handle for the derived or embedded key. This function might have to allocate heap space for the derived keys, in which case sort_file has to deallocate such space, so this callback takes a factory_t for heap management.</li></ul>
<p>
<ul>
<li>comparing two keys (<a class="el" href="../../d4/de8/group___s_s_m_s_o_r_t.html#g40808c8e7a7cc9d2ad468f267d822b34">ssm_sort::CF</a>): The server provides this function to compare two byte streams of some given length each.</li></ul>
<p>
<ul>
<li>unmarshalling an object (<a class="el" href="../../d4/de8/group___s_s_m_s_o_r_t.html#g56849d598a114b537d3931de756dcaa1">ssm_sort::UMOF</a>): Before the object is written to the output file after the last run, it may be unmarshalled to produce an on-disk version of the object. The unmarshal function need not be called on every record. When the output is to be a bulk-loadable file for indexes, unmarshal is not needed. When the output is a copy of the input file, it is sometimes needed:<ul>
<li>Case 1, Large object, not deep copy (large-object store will be transferred to the output file so carrying the object has no effect here) : No need to unmarshal; the large object was marshaled in the first place only for the purpose of locating or deriving a sort key.</li><li>Case 2, Large object with deep copy or small object<ul>
<li>Case 2a, Carrying object : Call unmarshal function (UMOF), write its result to the output file.</li><li>Case 2b, Not carrying object : No need to unmarshal; pin the original object and copy it to the output file.</li></ul>
</li></ul>
</li></ul>
<h2><a class="anchor" name="SORTOUTPUT">
Behavior and Results of Sort</a></h2>
Behaviors that can be controlled are the following; these behaviors are determined by the contents of the sort_keys_t argument to sort_file:<ul>
<li>The kind of output the sort produces, which can be<ul>
<li>a sorted copy of the input file (<a class="el" href="../../d7/d50/classssm__sort_1_1sort__keys__t.html#ca45750b361e4afe1435100bef70b5af">ssm_sort::sort_keys_t::set_for_file</a>), or</li><li>a file suitable for bulk-loading an index (sort_keys_t::set_for_index), the format of which is:<ul>
<li>header contains key in lexicographic format</li><li>body contains element</li></ul>
</li></ul>
</li><li>whether the original file is to be retained or deleted by the sort (sort_keys_t::set_keep_orig), with variations on these choices</li><li>how the key is to be located or derived (sort_keys_t::set_sortkey_fixed, sort_keys_t::set_sortkey_derived, and other attributes of sort_keys_t)</li><li>whether the sort is to be stable (sort_keys_t::set_stable)</li><li>whether the sort is ascending or descending (sort_keys_t::set_ascending)</li><li>whether the sort is to eliminate duplicate nulls (sort_keys_t::set_null_unique)</li><li>whether the sort is to eliminate all duplicates (sort_keys_t::set_unique)</li><li>whether the sort is to call user-defined marshal and unmarshal functions to get/put the resulting data from/to disk</li></ul>
<p>
Many behavioral options depend on other options, as discussed below.<h3><a class="anchor" name="SORTOUTPUTFILE">
Result is Sorted Copy of Input File</a></h3>
Use <a class="el" href="../../d7/d50/classssm__sort_1_1sort__keys__t.html#ca45750b361e4afe1435100bef70b5af">ssm_sort::sort_keys_t::set_for_file</a> to create a sorted copy of the input file.<p>
Applicable key description data:<ul>
<li>number of keys : &gt;= 1</li><li>key access (for each key):<ul>
<li>in header or body : a key or its source data may reside in either header or body of the original record</li><li>at fixed location (<a class="el" href="../../d7/d50/classssm__sort_1_1sort__keys__t.html#62555ded4564d04e91108133cd921a41">ssm_sort::sort_keys_t::set_sortkey_fixed</a>): In all records this key is at the same location in the record (header or body). User may not provide a <a class="el" href="../../d4/de8/group___s_s_m_s_o_r_t.html#g7f3d8ea3eb5546e42d9c8052400721fb">ssm_sort::CSKF</a> for the key (it will not be used, so it is rejected).<ul>
<li>aligned : By indicating that a key is adequately aligned in the original record for its key-comparison function (<a class="el" href="../../d4/de8/group___s_s_m_s_o_r_t.html#g40808c8e7a7cc9d2ad468f267d822b34">ssm_sort::CF</a>) to operate on it, the sort function can avoid the work of copying to an aligned and contiguous buffer before calling the comparison function (<a class="el" href="../../d4/de8/group___s_s_m_s_o_r_t.html#g40808c8e7a7cc9d2ad468f267d822b34">ssm_sort::CF</a>). (The sort function determines if the key resides entirely on one page; the user does not have to indicate this.) If the key is in lexicographic format in the original record (after marshalling, if marshalling is used), alignment is immaterial.</li></ul>
</li><li>derived (<a class="el" href="../../d7/d50/classssm__sort_1_1sort__keys__t.html#13e99e6c8af501c3ea209680f944583c">ssm_sort::sort_keys_t::set_sortkey_derived</a>) : User must provide a <a class="el" href="../../d4/de8/group___s_s_m_s_o_r_t.html#g7f3d8ea3eb5546e42d9c8052400721fb">ssm_sort::CSKF</a> callback function to derive the key. The source data may be in the header or body of the record. The <a class="el" href="../../d4/de8/group___s_s_m_s_o_r_t.html#g7f3d8ea3eb5546e42d9c8052400721fb">ssm_sort::CSKF</a> "knows" the key's offset from the header or body, or receives that information from an argument (key_cookie_t) passed to the callback function.</li></ul>
</li><li>lexicographic format: <a class="el" href="../../d7/d50/classssm__sort_1_1sort__keys__t.html#e6a57b0362bdf2817fe42b712633842b">ssm_sort::sort_keys_t::is_lexico</a> indicates that the key is in <a class="el" href="../../d6/d82/group___s_s_m_b_u_l_k_l_d.html#LEXICOFORMAT">lexigographic format</a> in the original record, so it can be compared in segments (if, say, it is spread across page boundaries) and its alignment is immaterial.</li></ul>
<p>
Applicable sort behavior options:<ul>
<li>marshalling : A callback marshal function (MOF) will be called to reformat records from which keys are created. This will be done before the <a class="el" href="../../d4/de8/group___s_s_m_s_o_r_t.html#g7f3d8ea3eb5546e42d9c8052400721fb">ssm_sort::CSKF</a> is called.</li><li>ascending : sort in ascending or descending order</li><li>stable : optionally ensure stable sort</li><li>unique : eliminate records with duplicate keys</li><li>null_unique : eliminate records with duplicate null keys</li><li>keep_orig : optionally delete the original file</li><li>carry_obj : optionally duplicate the entire object in the runs</li><li>deep_copy : optionally copy the large objects</li></ul>
<h3><a class="anchor" name="SORTOUTPUTINDEX">
Result is Input to Bulk-Load</a></h3>
Applicable key description data:<ul>
<li>number of sort keys : only one-key sort is supported</li><li>index key derivation: the index key may differ from the sort key, in which case the user provides a callback (<a class="el" href="../../d4/de8/group___s_s_m_s_o_r_t.html#g7f3d8ea3eb5546e42d9c8052400721fb">ssm_sort::CSKF</a>) function to produce the index key. It must be produced in <a class="el" href="../../d6/d82/group___s_s_m_b_u_l_k_l_d.html#LEXICOFORMAT">lexigographic format</a>.</li><li>sort key access:<ul>
<li>in header or body : a key or its source data may reside in either header or body of the original record</li><li>at fixed location (<a class="el" href="../../d7/d50/classssm__sort_1_1sort__keys__t.html#62555ded4564d04e91108133cd921a41">ssm_sort::sort_keys_t::set_sortkey_fixed</a>): In all records the key is at the same location in the record (header or body). User may not provide a <a class="el" href="../../d4/de8/group___s_s_m_s_o_r_t.html#g7f3d8ea3eb5546e42d9c8052400721fb">ssm_sort::CSKF</a> for the key (it will not be used, so it is rejected).<ul>
<li>aligned : By indicating that a key is adequately aligned in the original record for its key-comparison function (<a class="el" href="../../d4/de8/group___s_s_m_s_o_r_t.html#g40808c8e7a7cc9d2ad468f267d822b34">ssm_sort::CF</a>) to operate on it, the sort function can avoid the work of copying to an aligned and contiguous buffer before calling the comparison function (<a class="el" href="../../d4/de8/group___s_s_m_s_o_r_t.html#g40808c8e7a7cc9d2ad468f267d822b34">ssm_sort::CF</a>). (The sort function determines if the key resides entirely on one page; the user does not have to indicate this.) If the key is in lexicographic format in the original record (after marshalling, if marshalling is used), alignment is immaterial.</li></ul>
</li><li>derived (<a class="el" href="../../d7/d50/classssm__sort_1_1sort__keys__t.html#13e99e6c8af501c3ea209680f944583c">ssm_sort::sort_keys_t::set_sortkey_derived</a>) : User must provide a <a class="el" href="../../d4/de8/group___s_s_m_s_o_r_t.html#g7f3d8ea3eb5546e42d9c8052400721fb">ssm_sort::CSKF</a> callback function to derive the key. The source data may be in the header or body of the record. The <a class="el" href="../../d4/de8/group___s_s_m_s_o_r_t.html#g7f3d8ea3eb5546e42d9c8052400721fb">ssm_sort::CSKF</a> "knows" the key's offset from the header or body, or receives that information from an argument (key_cookie_t) passed to the callback function.<ul>
<li>lexicographic format: if the key is in <a class="el" href="../../d6/d82/group___s_s_m_b_u_l_k_l_d.html#LEXICOFORMAT">lexigographic format</a> in the original record, it can be compared in segments (if, say, it is spread across page boundaries) and its alignment is immaterial. <b>NOTE</b> If it is <b>not</b> in lexicographic format, a <a class="el" href="../../d4/de8/group___s_s_m_s_o_r_t.html#g7f3d8ea3eb5546e42d9c8052400721fb">ssm_sort::CSKF</a> callback must put it in lexicographic format for the purpose of loading into a B+-Tree (should the sort key be used as the index key), so the sort key must therefore be derived in this case.</li></ul>
</li></ul>
</li></ul>
<p>
Applicable sort behavior options:<ul>
<li>marshalling : use callback marshal function (MOF) to reformat records from which keys are created</li><li>ascending : sort in ascending or descending order</li><li>stable : may not be set because it might violate RID order in the event of duplicates (the elements for the pairs with the same key are sorted on the element in the B+-Tree). If stability is needed, the key should be derived from two keys, or should be a concatenation of multiple keys (either suitable colocated in the object or derived) that would ensure the stability.</li><li>unique : eliminate records with duplicate keys</li><li>null_unique : eliminate records with duplicate null keys</li><li>keep_orig : n/a</li><li>carry_obj : n/a</li><li>deep_copy : n/a</li></ul>
<h2><a class="anchor" name="SORTKEYS">
Keys</a></h2>
Sort keys may be located in the input records or derived from the input records. Index keys that are different from the sort key are derived. <dl compact><dt><b>Note:</b></dt><dd>Keys that are located in the input records may not span pages. The complexity to do key-comparisons (in parts, across pages) is not implemented. To get around this, you may put the keys in the record headers or use marshalling to collect the keys from the records.</dd></dl>
When the output is to be a sorted copy of the input file, the keys do not appear in the output file except inasmuch as they are embedded in the original input records. The sort keys in this case may be derived from the record contents, in which case they truly do not appear in the output. Multiple keys may be used for the sort, and they may be a combination of fixed-location keys and derived keys. See <a class="el" href="../../d4/de8/group___s_s_m_s_o_r_t.html#SORTOUTPUTFILE">Result is Sorted Copy of Input File</a>.<p>
When the output is to be a bulk-loadable file, its records takes the form header = key, body = element, and sort-file gives the caller no control over the elements' contents: they are the record-IDs of the original records. If something other than the record-ID is desired for bulk-loading an index, the output can be made to be a sorted copy of the original file, with a suitable unmarshal (UMOF) applied.<p>
Only one sort key can be used in this case, but the index key can differ differ from the sort key. See <a class="el" href="../../d4/de8/group___s_s_m_s_o_r_t.html#SORTOUTPUTINDEX">Result is Input to Bulk-Load</a>. 
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/de4/classssm__sort_1_1key__cookie__t.html">ssm_sort::key_cookie_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Input, output argument to CSKF, MOF, UMOF callbacks.  <a href="../../dc/de4/classssm__sort_1_1key__cookie__t.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d2a/classssm__sort_1_1factory__t.html">ssm_sort::factory_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A memory allocator (abstract base class) used by <a class="el" href="../../d4/de8/group___s_s_m_s_o_r_t.html#gaff9edeb900d2b62af637138849d08aa">ss_m::sort_file</a> and its adjuncts.  <a href="../../de/d2a/classssm__sort_1_1factory__t.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d14/classssm__sort_1_1key__location__t.html">ssm_sort::key_location_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Descriptor for fixed-location keys.  <a href="../../d7/d14/classssm__sort_1_1key__location__t.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d45/classssm__sort_1_1object__t.html">ssm_sort::object_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Handle on a record in the buffer pool or in scratch memory.  <a href="../../d4/d45/classssm__sort_1_1object__t.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d1c/classssm__sort_1_1skey__t.html">ssm_sort::skey_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The result of a CSKF function.  <a href="../../d2/d1c/classssm__sort_1_1skey__t.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dcd/structssm__sort_1_1generic___c_s_k_f__cookie.html">ssm_sort::generic_CSKF_cookie</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A cookie passed to generic_CSKF callback must point to one of these.  <a href="../../db/dcd/structssm__sort_1_1generic___c_s_k_f__cookie.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d50/classssm__sort_1_1sort__keys__t.html">ssm_sort::sort_keys_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parameter to control behavior of sort_file.  <a href="../../d7/d50/classssm__sort_1_1sort__keys__t.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d1c/classsort__stream__i.html">sort_stream_i</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sorting tool.  <a href="../../da/d1c/classsort__stream__i.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="../../db/dc7/classw__rc__t.html">w_rc_t</a>(*)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/de8/group___s_s_m_s_o_r_t.html#g7f3d8ea3eb5546e42d9c8052400721fb">ssm_sort::CSKF</a> (const <a class="el" href="../../d7/df5/classrid__t.html">rid_t</a> &amp;rid, const object_t &amp;in_obj, key_cookie_t cookie, factory_t &amp;f, skey_t *out)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create-Sort-Key Function.  <a href="#g7f3d8ea3eb5546e42d9c8052400721fb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="../../db/dc7/classw__rc__t.html">w_rc_t</a>(*)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/de8/group___s_s_m_s_o_r_t.html#gf75f6def6e04b87958c17d733cd5a7ed">ssm_sort::MOF</a> (const <a class="el" href="../../d7/df5/classrid__t.html">rid_t</a> &amp;rid, const object_t &amp;obj_in, key_cookie_t cookie, object_t *obj_out)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Marshal Object Function.  <a href="#gf75f6def6e04b87958c17d733cd5a7ed"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="../../db/dc7/classw__rc__t.html">w_rc_t</a>(*)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/de8/group___s_s_m_s_o_r_t.html#g56849d598a114b537d3931de756dcaa1">ssm_sort::UMOF</a> (const <a class="el" href="../../d7/df5/classrid__t.html">rid_t</a> &amp;rid, const object_t &amp;obj_in, key_cookie_t cookie, object_t *obj_out)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Un-marshal Object Function.  <a href="#g56849d598a114b537d3931de756dcaa1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef int(*)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/de8/group___s_s_m_s_o_r_t.html#g40808c8e7a7cc9d2ad468f267d822b34">ssm_sort::CF</a> (<a class="el" href="../../d9/da0/classw__base__t.html#7d1c7ae407200662fd16b64de4dcde46">w_base_t::uint4_t</a> length1, const void *key1, <a class="el" href="../../d9/da0/classw__base__t.html#7d1c7ae407200662fd16b64de4dcde46">w_base_t::uint4_t</a> length2, const void *key2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">key Comparison Function  <a href="#g40808c8e7a7cc9d2ad468f267d822b34"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="../../db/dc7/classw__rc__t.html">w_rc_t</a>(*)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/de8/group___s_s_m_s_o_r_t.html#gfeba47001dfdfa7561b77abfb5b52665">ssm_sort::LEXFUNC</a> (const void *source, smsize_t len, void *sink)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lexify key function.  <a href="#gfeba47001dfdfa7561b77abfb5b52665"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="../../db/dc7/classw__rc__t.html">rc_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/de8/group___s_s_m_s_o_r_t.html#gaff9edeb900d2b62af637138849d08aa">ss_m::sort_file</a> (const <a class="el" href="../../da/d5b/structstid__t.html">stid_t</a> &amp;fid, const <a class="el" href="../../da/d5b/structstid__t.html">stid_t</a> &amp;sorted_fid, int nvids, const <a class="el" href="../../d3/d3f/structvid__t.html">vid_t</a> *vid, sort_keys_t &amp;kl, smsize_t min_rec_sz, int run_size, int temp_space)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sort a file.  <a href="#gaff9edeb900d2b62af637138849d08aa"></a><br></td></tr>
</table>
<hr><h2>Typedef Documentation</h2>
<a class="anchor" name="g7f3d8ea3eb5546e42d9c8052400721fb"></a><!-- doxytag: member="ssm_sort::CSKF" ref="g7f3d8ea3eb5546e42d9c8052400721fb" args="(const rid_t &amp;rid, const object_t &amp;in_obj, key_cookie_t cookie, factory_t &amp;f, skey_t *out)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/de8/group___s_s_m_s_o_r_t.html#g7f3d8ea3eb5546e42d9c8052400721fb">ssm_sort::CSKF</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create-Sort-Key Function. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>rid</em>&nbsp;</td><td>Record ID of the record containing the key. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>in_obj</em>&nbsp;</td><td>Handle (<a class="el" href="../../d4/d45/classssm__sort_1_1object__t.html">object_t</a>) on the record whose key we need. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>cookie</em>&nbsp;</td><td>Describes the location and type of key in the source record. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>f</em>&nbsp;</td><td>Class for managing allocated space. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>out</em>&nbsp;</td><td>Result is written to this <a class="el" href="../../d4/d45/classssm__sort_1_1object__t.html">object_t</a>.</td></tr>
  </table>
</dl>
This type of callback function fills in the <a class="el" href="../../d2/d1c/classssm__sort_1_1skey__t.html">skey_t</a> <em>out</em> for a key in an object (record). It is called only when the object is first encountered in its run in a sort.<p>
A set of predefined callbacks are provided, q.v.:<ul>
<li><a class="el" href="../../d7/d50/classssm__sort_1_1sort__keys__t.html#dea54cdc9367401f0c91870a1c2ca162">sort_keys_t::noCSKF</a> : vacuous - does nothing</li><li><a class="el" href="../../d7/d50/classssm__sort_1_1sort__keys__t.html#b6713f7899450dd247b97a05d5fc0368">sort_keys_t::generic_CSKF</a> : copies or lexifies a key based on its <a class="el" href="../../dc/de4/classssm__sort_1_1key__cookie__t.html">key_cookie_t</a> argument.</li></ul>
<p>
See <a class="el" href="../../db/dcd/structssm__sort_1_1generic___c_s_k_f__cookie.html">generic_CSKF_cookie</a> for an example of a simple user-defined CSKF.<p>
The <a class="el" href="../../d2/d1c/classssm__sort_1_1skey__t.html">skey_t</a> <em>out</em> is pre-allocated and must be populated by this callback function. The <a class="el" href="../../de/d2a/classssm__sort_1_1factory__t.html">factory_t</a> <em>f</em> may be used for this allocation, or a user-defined <a class="el" href="../../de/d2a/classssm__sort_1_1factory__t.html">factory_t</a> may be used instead. Whatever factory is used to allocate the buffer to hold a key, that same factory must be placed in the <a class="el" href="../../d2/d1c/classssm__sort_1_1skey__t.html">skey_t</a> via the placement-new constructor call. Examples are given in the description for <a class="el" href="../../d2/d1c/classssm__sort_1_1skey__t.html">skey_t</a>.<p>
This callback must not free any space for <em>in_obj</em>. 
<p>
Definition at line <a class="el" href="../../d1/dfc/sort__s_8h-source.html#l00663">663</a> of file <a class="el" href="../../d1/dfc/sort__s_8h-source.html">sort_s.h</a>.
</div>
</div><p>
<a class="anchor" name="gf75f6def6e04b87958c17d733cd5a7ed"></a><!-- doxytag: member="ssm_sort::MOF" ref="gf75f6def6e04b87958c17d733cd5a7ed" args="(const rid_t &amp;rid, const object_t &amp;obj_in, key_cookie_t cookie, object_t *obj_out)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/de8/group___s_s_m_s_o_r_t.html#gf75f6def6e04b87958c17d733cd5a7ed">ssm_sort::MOF</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Marshal Object Function. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>rid</em>&nbsp;</td><td>Record id of the source record to marshal </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>obj_in</em>&nbsp;</td><td>Handle on the source record (<a class="el" href="../../d4/d45/classssm__sort_1_1object__t.html">object_t</a>) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>cookie</em>&nbsp;</td><td>Describes location and type of key in the source record </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>obj_out</em>&nbsp;</td><td>Result is to be written to this <a class="el" href="../../d4/d45/classssm__sort_1_1object__t.html">object_t</a>.</td></tr>
  </table>
</dl>
The <em>obj_out</em> is already allocated; this function must populate it. The <em>obj_out</em> has no buffers or factory associated with it. The MOF must populate the <em>obj_out</em> from its own factory (it may use <a class="el" href="../../de/d2a/classssm__sort_1_1factory__t.html#353c265290ca0fd79bf010e2a95a8d9c">factory_t::cpp_vector</a>, which uses the global heap, or it may use the factory from the <em>obj_in</em>, but ONLY if that factory is <b>not</b> <a class="el" href="../../de/d2a/classssm__sort_1_1factory__t.html#e61f0108a5954c9f4e584ec8700b48ce">factory_t::none</a>. The <em>obj_out</em> object carries its factory along with it throughout the sort process.<p>
This callback must not free any space for <em>obj_in</em>.<p>
This type of callback is used<ul>
<li>when a record is first encountered in the input file</li><li>if <a class="el" href="../../d7/d50/classssm__sort_1_1sort__keys__t.html#6cec79b5c364219f4f0a9960e517115e">sort_keys_t::carry_obj()</a> is true, it's also called when the object is read back from a temporary file.</li></ul>
<p>
A predefined callback is provided:<ul>
<li><a class="el" href="../../d7/d50/classssm__sort_1_1sort__keys__t.html#0c88847854a953776d9cf62e8e48a887">ssm_sort::sort_keys_t::noMOF</a> : vacuous - does nothing</li></ul>
<p>
The sort code checks for <div class="fragment"><pre class="fragment"> <a class="code" href="../../d7/d50/classssm__sort_1_1sort__keys__t.html#8bd637e40a1752e879005bbda377543a">sort_keys_t::marshal_func</a>() == <a class="code" href="../../d7/d50/classssm__sort_1_1sort__keys__t.html#0c88847854a953776d9cf62e8e48a887">sort_keys_t::noMOF</a>
</pre></div> in which case, it does not call a marshal function at all. (This is less work than allocating the output <a class="el" href="../../d4/d45/classssm__sort_1_1object__t.html">object_t</a> to call a vacuous function.) 
<p>
Definition at line <a class="el" href="../../d1/dfc/sort__s_8h-source.html#l00707">707</a> of file <a class="el" href="../../d1/dfc/sort__s_8h-source.html">sort_s.h</a>.
</div>
</div><p>
<a class="anchor" name="g56849d598a114b537d3931de756dcaa1"></a><!-- doxytag: member="ssm_sort::UMOF" ref="g56849d598a114b537d3931de756dcaa1" args="(const rid_t &amp;rid, const object_t &amp;obj_in, key_cookie_t cookie, object_t *obj_out)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/de8/group___s_s_m_s_o_r_t.html#g56849d598a114b537d3931de756dcaa1">ssm_sort::UMOF</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Un-marshal Object Function. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>rid</em>&nbsp;</td><td>Record id of the source record to marshal </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>obj_in</em>&nbsp;</td><td>Handle on the source record (<a class="el" href="../../d4/d45/classssm__sort_1_1object__t.html">object_t</a>) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>cookie</em>&nbsp;</td><td>Describes location and type of key in the destination record </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>obj_out</em>&nbsp;</td><td>Result is to be written to this <a class="el" href="../../d4/d45/classssm__sort_1_1object__t.html">object_t</a>.</td></tr>
  </table>
</dl>
The <em>obj_out</em> is already allocated; this function must populate it. The <em>obj_out</em> has no buffers or factory associated with it. The MOF must populate the <em>obj_out</em> from its own factory (it may use <a class="el" href="../../de/d2a/classssm__sort_1_1factory__t.html#353c265290ca0fd79bf010e2a95a8d9c">factory_t::cpp_vector</a>, which uses the global heap, or it may use the factory from the <em>obj_in</em>, but ONLY if that factory is <b>not</b> <a class="el" href="../../de/d2a/classssm__sort_1_1factory__t.html#e61f0108a5954c9f4e584ec8700b48ce">factory_t::none</a>. The <em>obj_out</em> object carries its factory along with it throughout the sort process.<p>
This callback must not free any space for <em>obj_in</em>.<p>
This type of callback is used<ul>
<li>when an object is written to a temp file</li><li>when the final object is written to the result file (if the output is a copy of the input file).</li></ul>
<p>
A predefined callback is provided:<ul>
<li><a class="el" href="../../d7/d50/classssm__sort_1_1sort__keys__t.html#446edb603a3889592f192f1b2619c2a0">ssm_sort::sort_keys_t::noUMOF</a> : vacuous - does nothing</li></ul>
<p>
The sort code checks for <div class="fragment"><pre class="fragment"> <a class="code" href="../../d7/d50/classssm__sort_1_1sort__keys__t.html#6f45d94da3090c444b698ce8ef6274e3">sort_keys_t::unmarshal_func</a>() == <a class="code" href="../../d7/d50/classssm__sort_1_1sort__keys__t.html#446edb603a3889592f192f1b2619c2a0">sort_keys_t::noUMOF</a>
</pre></div> in which case, it does not call a marshal function at all. (This is less work than allocating the output <a class="el" href="../../d4/d45/classssm__sort_1_1object__t.html">object_t</a> to call a vacuous function.) 
<p>
Definition at line <a class="el" href="../../d1/dfc/sort__s_8h-source.html#l00755">755</a> of file <a class="el" href="../../d1/dfc/sort__s_8h-source.html">sort_s.h</a>.
</div>
</div><p>
<a class="anchor" name="g40808c8e7a7cc9d2ad468f267d822b34"></a><!-- doxytag: member="ssm_sort::CF" ref="g40808c8e7a7cc9d2ad468f267d822b34" args="(w_base_t::uint4_t length1, const void *key1, w_base_t::uint4_t length2, const void *key2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/de8/group___s_s_m_s_o_r_t.html#g40808c8e7a7cc9d2ad468f267d822b34">ssm_sort::CF</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
key Comparison Function 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>length1</em>&nbsp;</td><td>Length of first key in bytes </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>key1</em>&nbsp;</td><td>Pointer to start of first key </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>length2</em>&nbsp;</td><td>Length of second key in bytes </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>key2</em>&nbsp;</td><td>Pointer to start of second key </td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>int</em>&nbsp;</td><td>Negative if key1 &lt; key2, 0 if equal, Positive if key1 &gt; key2</td></tr>
  </table>
</dl>
Used on every key comparison. <dl compact><dt><b>Note:</b></dt><dd>It is up to the server to determine if the keys are properly aligned for comparison as fundamental types. Alignment is determined by the combined behavior of the CSKF and MOF callbacks, as well as of the location of the keys in the original records. </dd></dl>

<p>
Definition at line <a class="el" href="../../d1/dfc/sort__s_8h-source.html#l00778">778</a> of file <a class="el" href="../../d1/dfc/sort__s_8h-source.html">sort_s.h</a>.
</div>
</div><p>
<a class="anchor" name="gfeba47001dfdfa7561b77abfb5b52665"></a><!-- doxytag: member="ssm_sort::LEXFUNC" ref="gfeba47001dfdfa7561b77abfb5b52665" args="(const void *source, smsize_t len, void *sink)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/de8/group___s_s_m_s_o_r_t.html#gfeba47001dfdfa7561b77abfb5b52665">ssm_sort::LEXFUNC</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Lexify key function. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>source</em>&nbsp;</td><td>Pointer to start of key </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>len</em>&nbsp;</td><td>Length of key </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>sink</em>&nbsp;</td><td>Pointer to output buffer (preallocated, of length len)</td></tr>
  </table>
</dl>
This type of function is called by the generic_CSKF. It may be useful for user-defined CKSF callbacks. Its purpose is to reformat keys into lexicographic form so that simple string-type (byte-by-byte) comparisons yield the same results as typed comparisons would. An alternative to lexifying keys and using string comparisons is to use typed comparisons, however, that has its disadvantages, particularly for keys that might be spread across page boundaries or are not aligned. 
<p>
Definition at line <a class="el" href="../../d1/dfc/sort__s_8h-source.html#l00801">801</a> of file <a class="el" href="../../d1/dfc/sort__s_8h-source.html">sort_s.h</a>.
</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="gaff9edeb900d2b62af637138849d08aa"></a><!-- doxytag: member="ss_m::sort_file" ref="gaff9edeb900d2b62af637138849d08aa" args="(const stid_t &amp;fid, const stid_t &amp;sorted_fid, int nvids, const vid_t *vid, sort_keys_t &amp;kl, smsize_t min_rec_sz, int run_size, int temp_space)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../db/dc7/classw__rc__t.html">rc_t</a> ss_m::sort_file           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/d5b/structstid__t.html">stid_t</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>fid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../da/d5b/structstid__t.html">stid_t</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>sorted_fid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nvids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d3/d3f/structvid__t.html">vid_t</a> *&nbsp;</td>
          <td class="paramname"> <em>vid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d7/d50/classssm__sort_1_1sort__keys__t.html">sort_keys_t</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>kl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">smsize_t&nbsp;</td>
          <td class="paramname"> <em>min_rec_sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>run_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>temp_space</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sort a file. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>fid</em>&nbsp;</td><td>File to sort. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>sorted_fid</em>&nbsp;</td><td>File to which to write the results. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nvids</em>&nbsp;</td><td>Size of array <em>vid</em>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>vid</em>&nbsp;</td><td>Array of IDs of scratch files created by the caller. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>kl</em>&nbsp;</td><td>See sort_keys_t. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>min_rec_sz</em>&nbsp;</td><td>Hint of minimum record size in input file. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>run_size</em>&nbsp;</td><td>Number of pages in buffer pool to use for a run. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>temp_space</em>&nbsp;</td><td>Number of pages to use for scratch space. (This limits the amount of memory used by the sort).</td></tr>
  </table>
</dl>
Before you call sort_file, you must create an output file <em>sorted_fid</em> into which sort_file will write the results.<p>
The sort uses temporary files when the input file contains more records than can fit in one run (determined by <em>run_size</em>). These temporary files may be spread across multiple volumes, which is useful if the volumes reside on different spindles. The arguments <em>nvids</em> and <em>vid</em> are for indicating the volumes to use for these scratch files.<p>
The caller can provide a clue in <em>min_rec_size</em> about the minimum record size of the input file, which can help the sort's efficiency.<p>
The <em>run_size</em> indicates how many buffer-pool pages to use for each run. Since at all times one page is fixed for output, while the rest are for reading the input in runs, the real run size is <em>run_size-1</em>. 
</div>
</div><p>
<hr size="1"><address style="align: right;"><small>Generated on Mon Jan 2 15:14:01 2012 for Shore Storage Manager by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
