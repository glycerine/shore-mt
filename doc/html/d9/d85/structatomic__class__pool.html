<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Shore Storage Manager: atomic_class_pool&lt; T &gt; Struct Template Reference</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
<link href="../../tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="../../main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="../../modules.html"><span>Modules</span></a></li>
    <li><a href="../../namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="../../classes.html"><span>Classes</span></a></li>
    <li><a href="../../files.html"><span>Files</span></a></li>
    <li><a href="../../dirs.html"><span>Directories</span></a></li>
    <li><a href="../../pages.html"><span>Related&nbsp;Pages</span></a></li>
    <li><a href="../../examples.html"><span>Examples</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="../../classes.html"><span>Alphabetical&nbsp;List</span></a></li>
    <li><a href="../../annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="../../hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="../../functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<h1>atomic_class_pool&lt; T &gt; Struct Template Reference</h1><!-- doxytag: class="atomic_class_pool" --><!-- doxytag: inherits="atomic_preallocated_pool" -->Inherits <a class="el" href="../../dd/d01/structatomic__preallocated__pool.html">atomic_preallocated_pool</a>.
<p>
Inheritance diagram for atomic_class_pool&lt; T &gt;:<p><center><img src="../../d1/d4b/structatomic__class__pool__inherit__graph.png" border="0" usemap="#df/d1f/atomic__class__pool_3_01_t_01_4__inherit__map" alt="Inheritance graph"></center>
<map name="df/d1f/atomic__class__pool_3_01_t_01_4__inherit__map">
<area href="../../dd/d01/structatomic__preallocated__pool.html" shape="rect" coords="5,80,189,107" alt="">
<area href="../../d8/dc5/classatomic__container.html" shape="rect" coords="31,5,164,32" alt="">
</map>
<center><font size="2">[<a target="top" href="../../graph_legend.html">legend</a>]</font></center>Collaboration diagram for atomic_class_pool&lt; T &gt;:<p><center><img src="../../dc/d51/structatomic__class__pool__coll__graph.png" border="0" usemap="#db/dfd/atomic__class__pool_3_01_t_01_4__coll__map" alt="Collaboration graph"></center>
<map name="db/dfd/atomic__class__pool_3_01_t_01_4__coll__map">
<area href="../../dd/d01/structatomic__preallocated__pool.html" shape="rect" coords="5,80,189,107" alt="">
<area href="../../d8/dc5/classatomic__container.html" shape="rect" coords="31,5,164,32" alt="">
</map>
<center><font size="2">[<a target="top" href="../../graph_legend.html">legend</a>]</font></center><a href="../../d3/dd7/structatomic__class__pool-members.html">List of all members.</a><hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;class T&gt;<br>
 struct atomic_class_pool&lt; T &gt;</h3>

A thread-safe memory pool for typed objects, based on <a class="el" href="../../dd/d01/structatomic__preallocated__pool.html">atomic_preallocated_pool</a>. 
<p>
<dl compact><dt><b>Note:</b></dt><dd>this code is <em>not</em> used by the storage manager (or maintained) anymore. The code is still distributed with releases only because it is used by an important client, the "kits" distributed by DIAS.</dd></dl>
Provides a replacement for new/delete on the specific class. Note that there's actually no way to prevent the user from allocating whatever they want, but they will be unable to destroy anything but the specified class (and its subclasses).<p>
<div class="fragment"><pre class="fragment"> Example:

        <span class="keyword">class </span>foo { };
        <a class="code" href="../../d9/d85/structatomic__class__pool.html">atomic_class_pool&lt;foo&gt;</a> pool;
        foo* f = <span class="keyword">new</span>(pool) foo;
        pool.<a class="code" href="../../d9/d85/structatomic__class__pool.html#43c7982e85c90b9a0b8f405b3a59dcd2">destroy</a>(f);
</pre></div> 
<p>

<p>
Definition at line <a class="el" href="../../d1/d21/atomic__class__pool_8h-source.html#l00122">122</a> of file <a class="el" href="../../d1/d21/atomic__class__pool_8h-source.html">atomic_class_pool.h</a>.<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d85/structatomic__class__pool.html#44b6152c28c43e05e21f5e3eb07068cb">atomic_class_pool</a> (long nbytes=sizeof(T), long seed=128)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a pool for class T.  <a href="#44b6152c28c43e05e21f5e3eb07068cb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d85/structatomic__class__pool.html#43c7982e85c90b9a0b8f405b3a59dcd2">destroy</a> (T *tptr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroys an object (by calling its destructor) and returns its memory to the pool.  <a href="#43c7982e85c90b9a0b8f405b3a59dcd2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b8fb7a6a0ba7a33574aa2ef3a7caa772"></a><!-- doxytag: member="atomic_class_pool::nbytes" ref="b8fb7a6a0ba7a33574aa2ef3a7caa772" args="()" -->
uint&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d85/structatomic__class__pool.html#b8fb7a6a0ba7a33574aa2ef3a7caa772">nbytes</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the object size given to the constructor. <br></td></tr>
<tr><td colspan="2"><br><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d85/structatomic__class__pool.html#70630484428d9420961b6362c18eaf1b">operator new</a> (size_t, <a class="el" href="../../d9/d85/structatomic__class__pool.html">atomic_class_pool</a>&lt; T &gt; &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">WARNING: When finished, call pool.destroy(t) instead of delete.  <a href="#70630484428d9420961b6362c18eaf1b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d85/structatomic__class__pool.html#55eb97b64f43fccf349f87e37356bf66">operator delete</a> (void *, <a class="el" href="../../d9/d85/structatomic__class__pool.html">atomic_class_pool</a>&lt; T &gt; &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called automatically by the compiler if T's constructor throws (otherwise memory would leak).  <a href="#55eb97b64f43fccf349f87e37356bf66"></a><br></td></tr>
</table>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="44b6152c28c43e05e21f5e3eb07068cb"></a><!-- doxytag: member="atomic_class_pool::atomic_class_pool" ref="44b6152c28c43e05e21f5e3eb07068cb" args="(long nbytes=sizeof(T), long seed=128)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d85/structatomic__class__pool.html">atomic_class_pool</a>&lt; T &gt;::<a class="el" href="../../d9/d85/structatomic__class__pool.html">atomic_class_pool</a>           </td>
          <td>(</td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>nbytes</em> = <code>sizeof(T)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>seed</em> = <code>128</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a pool for class T. 
<p>
By default the pool will hand out sizeof(T) bytes at a time; if T is a base class and this pool is to be used with subclasses, nbytes must be set at least as large as the largest class. Oversized allocations will assert().<p>
<dl compact><dt><b>Note:</b></dt><dd>this code is <em>not</em> used by the storage manager (or maintained) anymore. The code is still distributed with releases only because it is used by an important client, the "kits" distributed by DIAS. </dd></dl>

<p>
Definition at line <a class="el" href="../../d1/d21/atomic__class__pool_8h-source.html#l00136">136</a> of file <a class="el" href="../../d1/d21/atomic__class__pool_8h-source.html">atomic_class_pool.h</a>.
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="43c7982e85c90b9a0b8f405b3a59dcd2"></a><!-- doxytag: member="atomic_class_pool::destroy" ref="43c7982e85c90b9a0b8f405b3a59dcd2" args="(T *tptr)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d9/d85/structatomic__class__pool.html">atomic_class_pool</a>&lt; T &gt;::destroy           </td>
          <td>(</td>
          <td class="paramtype">T *&nbsp;</td>
          <td class="paramname"> <em>tptr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destroys an object (by calling its destructor) and returns its memory to the pool. 
<p>
Undefined behavior results if the object did not come from this pool.<p>
<dl compact><dt><b>Note:</b></dt><dd>this code is <em>not</em> used by the storage manager (or maintained) anymore. The code is still distributed with releases only because it is used by an important client, the "kits" distributed by DIAS. </dd></dl>

<p>
Definition at line <a class="el" href="../../d1/d21/atomic__class__pool_8h-source.html#l00152">152</a> of file <a class="el" href="../../d1/d21/atomic__class__pool_8h-source.html">atomic_class_pool.h</a>.
<p>
References <a class="el" href="../../dd/d01/structatomic__preallocated__pool.html#639725f6839ffea293cd081272af92e0">atomic_preallocated_pool::dealloc()</a>.
<p>
Here is the call graph for this function:<p><center><img src="../../d9/d85/structatomic__class__pool_43c7982e85c90b9a0b8f405b3a59dcd2_cgraph.png" border="0" usemap="#d9/d85/structatomic__class__pool_43c7982e85c90b9a0b8f405b3a59dcd2_cgraph_map" alt=""></center>
<map name="d9/d85/structatomic__class__pool_43c7982e85c90b9a0b8f405b3a59dcd2_cgraph_map">
<area href="../../dd/d01/structatomic__preallocated__pool.html#639725f6839ffea293cd081272af92e0" shape="rect" coords="251,5,493,32" alt="">
<area href="../../d8/dc5/classatomic__container.html#d4a69ccb9d0f0133ad0efcdb40c5f513" shape="rect" coords="541,5,715,32" alt="">
</map>

</div>
</div><p>
<hr><h2>Friends And Related Function Documentation</h2>
<a class="anchor" name="70630484428d9420961b6362c18eaf1b"></a><!-- doxytag: member="atomic_class_pool::operator new" ref="70630484428d9420961b6362c18eaf1b" args="(size_t, atomic_class_pool&lt; T &gt; &amp;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void* operator new           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>nbytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/d85/structatomic__class__pool.html">atomic_class_pool</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
WARNING: When finished, call pool.destroy(t) instead of delete. 
<p>
<dl compact><dt><b>Note:</b></dt><dd>this code is <em>not</em> used by the storage manager (or maintained) anymore. The code is still distributed with releases only because it is used by an important client, the "kits" distributed by DIAS.<p>
use placement-style new with the pool. <div class="fragment"><pre class="fragment"> usage: T* t = <span class="keyword">new</span>(pool) T(...)
</pre></div> </dd></dl>

</div>
</div><p>
<a class="anchor" name="55eb97b64f43fccf349f87e37356bf66"></a><!-- doxytag: member="atomic_class_pool::operator delete" ref="55eb97b64f43fccf349f87e37356bf66" args="(void *, atomic_class_pool&lt; T &gt; &amp;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void operator delete           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/d85/structatomic__class__pool.html">atomic_class_pool</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Called automatically by the compiler if T's constructor throws (otherwise memory would leak). 
<p>
<dl compact><dt><b>Note:</b></dt><dd>this code is <em>not</em> used by the storage manager (or maintained) anymore. The code is still distributed with releases only because it is used by an important client, the "kits" distributed by DIAS.</dd></dl>
Unfortunately, there is no "delete(pool)" syntax in C++ so the user must still call pool.destroy() 
</div>
</div><p>
<hr>The documentation for this struct was generated from the following file:<ul>
<li>src/fc/<a class="el" href="../../d1/d21/atomic__class__pool_8h-source.html">atomic_class_pool.h</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on Mon Jan 2 15:14:03 2012 for Shore Storage Manager by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
