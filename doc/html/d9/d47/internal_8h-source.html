<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Shore Storage Manager: src/internal.h Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
<link href="../../tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="../../main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="../../modules.html"><span>Modules</span></a></li>
    <li><a href="../../namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="../../classes.html"><span>Classes</span></a></li>
    <li id="current"><a href="../../files.html"><span>Files</span></a></li>
    <li><a href="../../dirs.html"><span>Directories</span></a></li>
    <li><a href="../../pages.html"><span>Related&nbsp;Pages</span></a></li>
    <li><a href="../../examples.html"><span>Examples</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="../../files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="../../globals.html"><span>File&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="../../dir_ff5597eff5bf2afe4bf6bec877c08348.html">src</a></div>
<h1>internal.h</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">// -*- mode:c++; c-basic-offset:4 -*-</span>
<a name="l00002"></a>00002 <span class="comment">/*&lt;std-header orig-src='shore' incl-file-exclusion='INTERNAL_H'&gt;</span>
<a name="l00003"></a>00003 <span class="comment"></span>
<a name="l00004"></a>00004 <span class="comment"> $Id: internal.h,v 1.13 2011/09/08 18:10:53 nhall Exp $</span>
<a name="l00005"></a>00005 <span class="comment"></span>
<a name="l00006"></a>00006 <span class="comment">SHORE -- Scalable Heterogeneous Object REpository</span>
<a name="l00007"></a>00007 <span class="comment"></span>
<a name="l00008"></a>00008 <span class="comment">Copyright (c) 1994-99 Computer Sciences Department, University of</span>
<a name="l00009"></a>00009 <span class="comment">                      Wisconsin -- Madison</span>
<a name="l00010"></a>00010 <span class="comment">All Rights Reserved.</span>
<a name="l00011"></a>00011 <span class="comment"></span>
<a name="l00012"></a>00012 <span class="comment">Permission to use, copy, modify and distribute this software and its</span>
<a name="l00013"></a>00013 <span class="comment">documentation is hereby granted, provided that both the copyright</span>
<a name="l00014"></a>00014 <span class="comment">notice and this permission notice appear in all copies of the</span>
<a name="l00015"></a>00015 <span class="comment">software, derivative works or modified versions, and any portions</span>
<a name="l00016"></a>00016 <span class="comment">thereof, and that both notices appear in supporting documentation.</span>
<a name="l00017"></a>00017 <span class="comment"></span>
<a name="l00018"></a>00018 <span class="comment">THE AUTHORS AND THE COMPUTER SCIENCES DEPARTMENT OF THE UNIVERSITY</span>
<a name="l00019"></a>00019 <span class="comment">OF WISCONSIN - MADISON ALLOW FREE USE OF THIS SOFTWARE IN ITS</span>
<a name="l00020"></a>00020 <span class="comment">"AS IS" CONDITION, AND THEY DISCLAIM ANY LIABILITY OF ANY KIND</span>
<a name="l00021"></a>00021 <span class="comment">FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.</span>
<a name="l00022"></a>00022 <span class="comment"></span>
<a name="l00023"></a>00023 <span class="comment">This software was developed with support by the Advanced Research</span>
<a name="l00024"></a>00024 <span class="comment">Project Agency, ARPA order number 018 (formerly 8230), monitored by</span>
<a name="l00025"></a>00025 <span class="comment">the U.S. Army Research Laboratory under contract DAAB07-91-C-Q518.</span>
<a name="l00026"></a>00026 <span class="comment">Further funding for this work was provided by DARPA through</span>
<a name="l00027"></a>00027 <span class="comment">Rome Research Laboratory Contract No. F30602-97-2-0247.</span>
<a name="l00028"></a>00028 <span class="comment"></span>
<a name="l00029"></a>00029 <span class="comment">*/</span>
<a name="l00030"></a>00030 
<a name="l00031"></a>00031 <span class="comment">/*  -- do not edit anything above this line --   &lt;/std-header&gt;*/</span>
<a name="l00032"></a>00032 
<a name="l00033"></a>00033 <span class="comment">/* This file contains doxygen documentation only */</span>
<a name="l00034"></a>00034 <span class="comment"></span>
<a name="l00035"></a>00035 <span class="comment">/**\page IMPLNOTES Implementation Notes</span>
<a name="l00036"></a>00036 <span class="comment"> *</span>
<a name="l00037"></a>00037 <span class="comment"> * \section MODULES Storage Manager Modules</span>
<a name="l00038"></a>00038 <span class="comment"> * The storage manager code contains the following modules (with related C++ classes):</span>
<a name="l00039"></a>00039 <span class="comment"> *</span>
<a name="l00040"></a>00040 <span class="comment"> * - \ref SSMAPI (ss_m) </span>
<a name="l00041"></a>00041 <span class="comment"> *   Most of the programming interface to the storage manager is encapsulated</span>
<a name="l00042"></a>00042 <span class="comment"> *   in the ss_m class. </span>
<a name="l00043"></a>00043 <span class="comment"> * - \ref VOL_M (vol_m) and \ref DIR_M (dir_m)</span>
<a name="l00044"></a>00044 <span class="comment"> *   These managers handle volumes, page allocation and stores, which are the</span>
<a name="l00045"></a>00045 <span class="comment"> *   structures underlying files of records, B+-Tree indexes, and</span>
<a name="l00046"></a>00046 <span class="comment"> *   spatial indexes (R*-Trees).</span>
<a name="l00047"></a>00047 <span class="comment"> * - \ref FILE_M (file_m), \ref BTREE_M (btree_m), and \ref RTREE_M (rtree_m)</span>
<a name="l00048"></a>00048 <span class="comment"> *   handle the storage structures available to servers.</span>
<a name="l00049"></a>00049 <span class="comment"> * - \ref LOCK_M (lock_m) </span>
<a name="l00050"></a>00050 <span class="comment"> *   The lock manager is quasi-stand-alone.</span>
<a name="l00051"></a>00051 <span class="comment"> * - \ref XCT_M (xct_t) and * \ref LOG_M (log_m) handle transactions,</span>
<a name="l00052"></a>00052 <span class="comment"> *   logging, and recovery.</span>
<a name="l00053"></a>00053 <span class="comment"> * - \ref BF_M (bf_m)</span>
<a name="l00054"></a>00054 <span class="comment"> *   The buffer manager works closely with \ref XCT_M and \ref LOG_M.</span>
<a name="l00055"></a>00055 <span class="comment"> *</span>
<a name="l00056"></a>00056 <span class="comment"> * \attention</span>
<a name="l00057"></a>00057 <span class="comment"> * \anchor ATSIGN </span>
<a name="l00058"></a>00058 <span class="comment"> * \htmlonly</span>
<a name="l00059"></a>00059 <span class="comment"> * &lt;b&gt;&lt;font color=#B2222&gt;</span>
<a name="l00060"></a>00060 <span class="comment"> * In the storage manager, fixing a page in the buffer pool acquires</span>
<a name="l00061"></a>00061 <span class="comment"> a latch</span>
<a name="l00062"></a>00062 <span class="comment"> and the verbs "fix" and "latch" are used interchangeably here.</span>
<a name="l00063"></a>00063 <span class="comment"> For searching convenience, where latching/fixing occurs the symbol @</span>
<a name="l00064"></a>00064 <span class="comment"> has been inserted.</span>
<a name="l00065"></a>00065 <span class="comment"> * &lt;/b&gt;&lt;/font&gt; </span>
<a name="l00066"></a>00066 <span class="comment"> * \endhtmlonly</span>
<a name="l00067"></a>00067 <span class="comment"> *</span>
<a name="l00068"></a>00068 <span class="comment"> * \section VOL_M I/O Manager and Volume Manager</span>
<a name="l00069"></a>00069 <span class="comment"> * The I/O manager was, in the early days of SHORE, expected to</span>
<a name="l00070"></a>00070 <span class="comment"> * have more responsibility than it now has; now it is little more</span>
<a name="l00071"></a>00071 <span class="comment"> * than a wrapper for the \ref VOL_M.   </span>
<a name="l00072"></a>00072 <span class="comment"> * For the purpose of this discussion, </span>
<a name="l00073"></a>00073 <span class="comment"> * the I/O Manager and the volume manager are the same entity.</span>
<a name="l00074"></a>00074 <span class="comment"> * There is a single read-write lock associated </span>
<a name="l00075"></a>00075 <span class="comment"> * with the I/O-Volume manager to serialize access.  </span>
<a name="l00076"></a>00076 <span class="comment"> * Read-only functions acquire the lock in read mode; updating </span>
<a name="l00077"></a>00077 <span class="comment"> * functions acquire the lock in write mode.</span>
<a name="l00078"></a>00078 <span class="comment"> *</span>
<a name="l00079"></a>00079 <span class="comment"> * \note</span>
<a name="l00080"></a>00080 <span class="comment"> * Much of the page- and extent-allocation code relies on the fact that</span>
<a name="l00081"></a>00081 <span class="comment"> * access to the manager is serialized, and this lock is a major source of</span>
<a name="l00082"></a>00082 <span class="comment"> * contention.</span>
<a name="l00083"></a>00083 <span class="comment"> *</span>
<a name="l00084"></a>00084 <span class="comment"> * The volume manager handles formatting of volumes,</span>
<a name="l00085"></a>00085 <span class="comment"> * allocation and deallocation of pages and extents in stores.</span>
<a name="l00086"></a>00086 <span class="comment"> * Within a page, allocation of space is up to the manager of the</span>
<a name="l00087"></a>00087 <span class="comment"> * storage structure (btree, rtree, or file).</span>
<a name="l00088"></a>00088 <span class="comment"> *</span>
<a name="l00089"></a>00089 <span class="comment"> * The following sections describe the \ref VOL_M:</span>
<a name="l00090"></a>00090 <span class="comment"> * - \ref EXTENTSTORE </span>
<a name="l00091"></a>00091 <span class="comment"> * - \ref STORENODE </span>
<a name="l00092"></a>00092 <span class="comment"> * - \ref OBJIDS </span>
<a name="l00093"></a>00093 <span class="comment"> * - \ref STONUMS </span>
<a name="l00094"></a>00094 <span class="comment"> * - \ref ALLOCEXT </span>
<a name="l00095"></a>00095 <span class="comment"> * - \ref XAFTERXCT </span>
<a name="l00096"></a>00096 <span class="comment"> * - \ref IMPLICAT </span>
<a name="l00097"></a>00097 <span class="comment"> * - \ref ALLOCST </span>
<a name="l00098"></a>00098 <span class="comment"> * - \ref SAFTERXCT </span>
<a name="l00099"></a>00099 <span class="comment"> * - \ref ALLOCPG </span>
<a name="l00100"></a>00100 <span class="comment"> * - \ref VOLCACHES </span>
<a name="l00101"></a>00101 <span class="comment"> * - \ref PAGES </span>
<a name="l00102"></a>00102 <span class="comment"> * - \ref RSVD_MODE </span>
<a name="l00103"></a>00103 <span class="comment"> *</span>
<a name="l00104"></a>00104 <span class="comment"> * \subsection EXTENTSTORE Extents and Stores</span>
<a name="l00105"></a>00105 <span class="comment"> *</span>
<a name="l00106"></a>00106 <span class="comment"> * Files and indexes are types of \e stores. A store is a persistent</span>
<a name="l00107"></a>00107 <span class="comment"> * data structure to which pages are allocated and deallocated, but which</span>
<a name="l00108"></a>00108 <span class="comment"> * is independent of the purpose for which it is used (index or file).</span>
<a name="l00109"></a>00109 <span class="comment"> *</span>
<a name="l00110"></a>00110 <span class="comment"> * Pages are reserved and allocated for a store in units of ss_m::ext_sz </span>
<a name="l00111"></a>00111 <span class="comment"> * (enumeration value smlevel_0::ext_sz, found in sm_base.h), </span>
<a name="l00112"></a>00112 <span class="comment"> * a compile-time constant that indicates the size of an extent.</span>
<a name="l00113"></a>00113 <span class="comment"> *</span>
<a name="l00114"></a>00114 <span class="comment"> * An extent is a set of contiguous pages, represented </span>
<a name="l00115"></a>00115 <span class="comment"> * by a persistent data structure \ref extlink_t.  Extents are</span>
<a name="l00116"></a>00116 <span class="comment"> * linked together to form the entire structure of a store.  </span>
<a name="l00117"></a>00117 <span class="comment"> * The head of this list has a reference to it from a store-node</span>
<a name="l00118"></a>00118 <span class="comment"> * (\ref stnode_t), described below.</span>
<a name="l00119"></a>00119 <span class="comment"> * Extents (extlink_t) are co-located on extent-map pages at </span>
<a name="l00120"></a>00120 <span class="comment"> * the beginning of the volume. </span>
<a name="l00121"></a>00121 <span class="comment"> *</span>
<a name="l00122"></a>00122 <span class="comment"> * Each extent has an owner, </span>
<a name="l00123"></a>00123 <span class="comment"> * which is the store id (\ref snum_t) of the store to which it belongs.</span>
<a name="l00124"></a>00124 <span class="comment"> * Free extents are not linked together; </span>
<a name="l00125"></a>00125 <span class="comment"> * they simply have no owner (signified by an  \ref extlink_t::owner == 0).</span>
<a name="l00126"></a>00126 <span class="comment"> *</span>
<a name="l00127"></a>00127 <span class="comment"> * An extent id is a number of type \ref extnum_t.  It is arithmetically</span>
<a name="l00128"></a>00128 <span class="comment"> * determined from a page number, and the pages in an extent are arithmetically derived from an extent number. </span>
<a name="l00129"></a>00129 <span class="comment"> * The \ref extnum_t is used in acquiring locks on</span>
<a name="l00130"></a>00130 <span class="comment"> * extents and it is used for locating the associated \ref extlink_t and the</span>
<a name="l00131"></a>00131 <span class="comment"> * extent-map page on which the \ref extlink_t resides.</span>
<a name="l00132"></a>00132 <span class="comment"> * Scanning the pages in a store can be accomplished by scanning the </span>
<a name="l00133"></a>00133 <span class="comment"> * list of \ref extlink_t.   </span>
<a name="l00134"></a>00134 <span class="comment"> * </span>
<a name="l00135"></a>00135 <span class="comment"> * The entire allocation metadata for a page are in its extent, which contains a</span>
<a name="l00136"></a>00136 <span class="comment"> * bitmap indicating which of its pages are allocated.</span>
<a name="l00137"></a>00137 <span class="comment"> * One cannot determine the allocation status of a page from the page </span>
<a name="l00138"></a>00138 <span class="comment"> * itself: the extent map page must be inspected.</span>
<a name="l00139"></a>00139 <span class="comment"> *</span>
<a name="l00140"></a>00140 <span class="comment"> * Extents also contain (unlogged, advisory) metadata in the form of</span>
<a name="l00141"></a>00141 <span class="comment"> * a pbucketmap; this contains a \e bucket \e number </span>
<a name="l00142"></a>00142 <span class="comment"> * for each page in the extent,</span>
<a name="l00143"></a>00143 <span class="comment"> * indicating of the amount of free space on the page.</span>
<a name="l00144"></a>00144 <span class="comment"> * The map has meaning only to the \ref FILE_M.  </span>
<a name="l00145"></a>00145 <span class="comment"> * The file manager asks the I/O layer</span>
<a name="l00146"></a>00146 <span class="comment"> * (which then descends to the volume manager for this purpose) to find the</span>
<a name="l00147"></a>00147 <span class="comment"> * next page whose advisory bucket number is sufficiently large for the</span>
<a name="l00148"></a>00148 <span class="comment"> * file manager's record-allocation needs.  Between the time this request</span>
<a name="l00149"></a>00149 <span class="comment"> * is made and the time the file manager fixes</span>
<a name="l00150"></a>00150 <span class="comment"> * and inspects the page,</span>
<a name="l00151"></a>00151 <span class="comment"> * the page might no longer have sufficient space.  Nevertheless, this</span>
<a name="l00152"></a>00152 <span class="comment"> * advisory bucket number in the extlink_t reduces the number of page-fixes</span>
<a name="l00153"></a>00153 <span class="comment"> * to find a page with the needed space, and</span>
<a name="l00154"></a>00154 <span class="comment"> * it does improve the effective fill-factor for file pages.</span>
<a name="l00155"></a>00155 <span class="comment"> *</span>
<a name="l00156"></a>00156 <span class="comment"> * Maintaining the bucket map is costly in that it fixes and dirties </span>
<a name="l00157"></a>00157 <span class="comment"> * extent-map pages,</span>
<a name="l00158"></a>00158 <span class="comment"> * even though it does not log these updates.</span>
<a name="l00159"></a>00159 <span class="comment"> *</span>
<a name="l00160"></a>00160 <span class="comment"> * The bucket map is maintained \e only for extents whose pages are </span>
<a name="l00161"></a>00161 <span class="comment"> * file_p (small-object) pages.</span>
<a name="l00162"></a>00162 <span class="comment"> *</span>
<a name="l00163"></a>00163 <span class="comment"> * \subsection STORENODE Store Nodes</span>
<a name="l00164"></a>00164 <span class="comment"> * A \ref stnode_t holds metadata for a store, including a reference to</span>
<a name="l00165"></a>00165 <span class="comment"> * the first extent in the store. </span>
<a name="l00166"></a>00166 <span class="comment"> * A store \e always contains at least one allocated extent, even if</span>
<a name="l00167"></a>00167 <span class="comment"> * no pages in that extent are allocated.</span>
<a name="l00168"></a>00168 <span class="comment"> * Scanning the pages in a store can be accomplished by scanning the </span>
<a name="l00169"></a>00169 <span class="comment"> * list of \ref extlink_t.   </span>
<a name="l00170"></a>00170 <span class="comment"> *</span>
<a name="l00171"></a>00171 <span class="comment"> * Store nodes are co-located on store-map pages at the beginning of a volume, </span>
<a name="l00172"></a>00172 <span class="comment"> * after the extent maps. The volume is formatted to allow</span>
<a name="l00173"></a>00173 <span class="comment"> * as many store nodes as there are extents.</span>
<a name="l00174"></a>00174 <span class="comment"> *</span>
<a name="l00175"></a>00175 <span class="comment"> * \subsection OBJIDS Object Identifiers, Object Location, and Locks</span>
<a name="l00176"></a>00176 <span class="comment"> *</span>
<a name="l00177"></a>00177 <span class="comment"> * There is a close interaction among various object identifiers,</span>
<a name="l00178"></a>00178 <span class="comment"> * the data structures in which the </span>
<a name="l00179"></a>00179 <span class="comment"> * objects reside, and the locks acquired on the objects.</span>
<a name="l00180"></a>00180 <span class="comment"> * </span>
<a name="l00181"></a>00181 <span class="comment"> * Simply put:</span>
<a name="l00182"></a>00182 <span class="comment"> * - a volume identifier (ID) consists of an </span>
<a name="l00183"></a>00183 <span class="comment"> *   integral number, e.g., 1, represented in an output stream as v(1).</span>
<a name="l00184"></a>00184 <span class="comment"> * - a store identifier consists of a volume ID and a store number, e.g., 3,</span>
<a name="l00185"></a>00185 <span class="comment"> *   represented s(1.3).</span>
<a name="l00186"></a>00186 <span class="comment"> * - an index ID and a file ID are merely store IDs.</span>
<a name="l00187"></a>00187 <span class="comment"> * - a page ID contains a store ID and a page number, e.g., 48, represented</span>
<a name="l00188"></a>00188 <span class="comment"> *   p(1.3.48).</span>
<a name="l00189"></a>00189 <span class="comment"> * - a record ID for a record in a file contains a </span>
<a name="l00190"></a>00190 <span class="comment"> *   page ID and a slot number, e.g., 2, represented r(1.3.48.2).</span>
<a name="l00191"></a>00191 <span class="comment"> *</span>
<a name="l00192"></a>00192 <span class="comment"> *  Clearly, from a record ID, its page and slot can </span>
<a name="l00193"></a>00193 <span class="comment"> *  be derived without consulting any indices.  It is </span>
<a name="l00194"></a>00194 <span class="comment"> *  also clear that records cannot move, which has </span>
<a name="l00195"></a>00195 <span class="comment"> *  ramifications for \ref RSVD_MODE, described below.</span>
<a name="l00196"></a>00196 <span class="comment"> *  The \ref LOCK_M understands these identifiers as well as extent</span>
<a name="l00197"></a>00197 <span class="comment"> *  IDs, and generates locks from identifiers.  </span>
<a name="l00198"></a>00198 <span class="comment"> *</span>
<a name="l00199"></a>00199 <span class="comment"> * \subsection STONUMS Predefined Stores</span>
<a name="l00200"></a>00200 <span class="comment"> *</span>
<a name="l00201"></a>00201 <span class="comment"> * A volume contains these pre-defined structures:</span>
<a name="l00202"></a>00202 <span class="comment"> * - Header: page 0 (the first page) of the volume; contains :</span>
<a name="l00203"></a>00203 <span class="comment"> *   - a format version #</span>
<a name="l00204"></a>00204 <span class="comment"> *   - the long volume id</span>
<a name="l00205"></a>00205 <span class="comment"> *   - extent size</span>
<a name="l00206"></a>00206 <span class="comment"> *   - number of extents</span>
<a name="l00207"></a>00207 <span class="comment"> *   - number of extents used for store 0 (see below)</span>
<a name="l00208"></a>00208 <span class="comment"> *   - number of pages used for store 0 (see below)</span>
<a name="l00209"></a>00209 <span class="comment"> *   - the first page of the extent map</span>
<a name="l00210"></a>00210 <span class="comment"> *   - the first page of the store map</span>
<a name="l00211"></a>00211 <span class="comment"> *   - page size</span>
<a name="l00212"></a>00212 <span class="comment"> * - store #0 : a "pseudo-store" containing the extent-map and store-map pages. This</span>
<a name="l00213"></a>00213 <span class="comment"> *   starts with page 1 (the second page) of the volume.</span>
<a name="l00214"></a>00214 <span class="comment"> * - store #1 :  directory of the stores (used by the storage manager): this is</span>
<a name="l00215"></a>00215 <span class="comment"> *   a btree index mapping store-number to metadata about the store, </span>
<a name="l00216"></a>00216 <span class="comment"> *   including (but not limited to) the store's use (btree/rtree/file-small-object-pages/file-large-object-pages), </span>
<a name="l00217"></a>00217 <span class="comment"> *   and, in the case of indices, the root page of the index,</span>
<a name="l00218"></a>00218 <span class="comment"> *   and, in the case of files, the store number of the associated large-object-page store. </span>
<a name="l00219"></a>00219 <span class="comment"> * - store #2 :  root index (for use by the server)</span>
<a name="l00220"></a>00220 <span class="comment"> *</span>
<a name="l00221"></a>00221 <span class="comment"> * \subsection ALLOCEXT Allocation and Deallocation of Extents </span>
<a name="l00222"></a>00222 <span class="comment"> *</span>
<a name="l00223"></a>00223 <span class="comment"> * \anchor ALLOCEXTA </span>
<a name="l00224"></a>00224 <span class="comment"> * Finding an extent to allocate to a store requires</span>
<a name="l00225"></a>00225 <span class="comment"> * searching through the </span>
<a name="l00226"></a>00226 <span class="comment"> *   extent-map pages for an extent that is both </span>
<a name="l00227"></a>00227 <span class="comment"> *   unallocated (owner is zero) and not locked. </span>
<a name="l00228"></a>00228 <span class="comment"> *  - The storage </span>
<a name="l00229"></a>00229 <span class="comment"> *   manager caches the minimum free extent number with which to start a</span>
<a name="l00230"></a>00230 <span class="comment"> *   search; this number is reset to its static lower bound when the</span>
<a name="l00231"></a>00231 <span class="comment"> *   volume is mounted, meaning that the first extent operation after a</span>
<a name="l00232"></a>00232 <span class="comment"> *   mount starts its search at the head of the volume.</span>
<a name="l00233"></a>00233 <span class="comment"> * - Subsequent searches start the search with the lowest free extent</span>
<a name="l00234"></a>00234 <span class="comment"> *   number.</span>
<a name="l00235"></a>00235 <span class="comment"> * - Extent-map pages are latched as needed for this linear search </span>
<a name="l00236"></a>00236 <span class="comment"> *   \ref ATSIGN "\@".</span>
<a name="l00237"></a>00237 <span class="comment"> * - The first appropriate extent found is IX-locked.</span>
<a name="l00238"></a>00238 <span class="comment"> *   These locks are explicitly acquired by the lock manager; </span>
<a name="l00239"></a>00239 <span class="comment"> *   extent locks are not in the lock hierarchy;</span>
<a name="l00240"></a>00240 <span class="comment"> *</span>
<a name="l00241"></a>00241 <span class="comment"> * \anchor ALLOCEXTA2 </span>
<a name="l00242"></a>00242 <span class="comment"> * Allocating a set of extents to a store is a matter of linking</span>
<a name="l00243"></a>00243 <span class="comment"> * them together and then appending the list to the </span>
<a name="l00244"></a>00244 <span class="comment"> * tail of the store's linked list:</span>
<a name="l00245"></a>00245 <span class="comment"> *  - Locks are \e not acquired for previous and next extents in the list; </span>
<a name="l00246"></a>00246 <span class="comment"> *    EX-latches protect these structures;</span>
<a name="l00247"></a>00247 <span class="comment"> *  - New extents are always linked in at the tail of the list.</span>
<a name="l00248"></a>00248 <span class="comment"> *  - One extent-map page is fixed at a time </span>
<a name="l00249"></a>00249 <span class="comment"> *   \ref ATSIGN "\@".  Entire portions of the</span>
<a name="l00250"></a>00250 <span class="comment"> *   extent list that reside on the same extent-map page are </span>
<a name="l00251"></a>00251 <span class="comment"> *   linked while holding the page latched, and </span>
<a name="l00252"></a>00252 <span class="comment"> *   logged in a single log record. This is useful only for creating</span>
<a name="l00253"></a>00253 <span class="comment"> *   large objects; all other page-allocations result in allocation of</span>
<a name="l00254"></a>00254 <span class="comment"> *   one or zero extents.</span>
<a name="l00255"></a>00255 <span class="comment"> *</span>
<a name="l00256"></a>00256 <span class="comment"> * Allocation is handled slightly differently in the two contexts </span>
<a name="l00257"></a>00257 <span class="comment"> * in which it is performed: </span>
<a name="l00258"></a>00258 <span class="comment"> * - creating a store (see \ref ALLOCST), and </span>
<a name="l00259"></a>00259 <span class="comment"> * - inserting new pages into an existing store (see \ref ALLOCPG ).</span>
<a name="l00260"></a>00260 <span class="comment"> * These two cases are described in more detail below.</span>
<a name="l00261"></a>00261 <span class="comment"> *</span>
<a name="l00262"></a>00262 <span class="comment"> * Extents are freed:</span>
<a name="l00263"></a>00263 <span class="comment"> * - when a transaction deletes a store and commits, and</span>
<a name="l00264"></a>00264 <span class="comment"> * - when a transaction has deleted the last page in the extent; this involves acquiring an IX lock on the extent, but does not</span>
<a name="l00265"></a>00265 <span class="comment"> * preclude other transactions from allocating pages in the same extent. </span>
<a name="l00266"></a>00266 <span class="comment"> * Also, since the transaction might abort, the extent must not be re-used </span>
<a name="l00267"></a>00267 <span class="comment"> * for another store by another transaction. Furthermore, the page-deleting </span>
<a name="l00268"></a>00268 <span class="comment"> * transaction could re-use the pages.  For these reasons, extents are left</span>
<a name="l00269"></a>00269 <span class="comment"> * in a store until the transaction commits (see \ref XCT_M and \ref XAFTERXCT,</span>
<a name="l00270"></a>00270 <span class="comment"> * and \ref SAFTERXCT). </span>
<a name="l00271"></a>00271 <span class="comment"> * \anchor ALLOCEXTD1 </span>
<a name="l00272"></a>00272 <span class="comment"> * Thus, deallocating an extent \e before a transaction commits comprises:</span>
<a name="l00273"></a>00273 <span class="comment"> *  - clearing the extent-has-allocated-page bit in the already-held</span>
<a name="l00274"></a>00274 <span class="comment"> *   extent IX lock, and does not involve any page-fixes.</span>
<a name="l00275"></a>00275 <span class="comment"> *</span>
<a name="l00276"></a>00276 <span class="comment"> * \subsection XAFTERXCT Commit-Time Handling of Extent-Deallocation</span>
<a name="l00277"></a>00277 <span class="comment"> * At commit time, the transaction deallocates extents in two contexts:</span>
<a name="l00278"></a>00278 <span class="comment"> * - When destroying stores that were marked for deletion by the transaction,and</span>
<a name="l00279"></a>00279 <span class="comment"> * - While freeing extents marked for freeing by the transaction as a result</span>
<a name="l00280"></a>00280 <span class="comment"> *   of (incremental) page-freeing.</span>
<a name="l00281"></a>00281 <span class="comment"> *</span>
<a name="l00282"></a>00282 <span class="comment"> * For the latter case, the transaction asks the transaction</span>
<a name="l00283"></a>00283 <span class="comment"> * manager to </span>
<a name="l00284"></a>00284 <span class="comment"> * identify all extents on which it has locks (lock manager's job).  </span>
<a name="l00285"></a>00285 <span class="comment"> * If </span>
<a name="l00286"></a>00286 <span class="comment"> * - the lock manager can upgrade the extent's lock to EX mode \e and </span>
<a name="l00287"></a>00287 <span class="comment"> * - the extent still contains no allocated pages, </span>
<a name="l00288"></a>00288 <span class="comment"> * the lock manager frees the extent.</span>
<a name="l00289"></a>00289 <span class="comment"> * (An optimization avoids excessive page-fixing here: the</span>
<a name="l00290"></a>00290 <span class="comment"> * extent lock contains a bit indicating whether the extent contains any</span>
<a name="l00291"></a>00291 <span class="comment"> * allocated pages.)</span>
<a name="l00292"></a>00292 <span class="comment"> *</span>
<a name="l00293"></a>00293 <span class="comment"> * \anchor ALLOCEXTD2 </span>
<a name="l00294"></a>00294 <span class="comment"> * Deallocating an extent from a store (at transaction-commit) comprises:</span>
<a name="l00295"></a>00295 <span class="comment"> * - Identifying the previous- and next- extent numbers;</span>
<a name="l00296"></a>00296 <span class="comment"> * - Identifying the pages containing the \ref extlink_t structures for the</span>
<a name="l00297"></a>00297 <span class="comment"> *   extent to be freed and for the previous- and next- extent structures,</span>
<a name="l00298"></a>00298 <span class="comment"> *   which may mean as many as three pages;</span>
<a name="l00299"></a>00299 <span class="comment"> * - Sorting the page numbers and EX-latching </span>
<a name="l00300"></a>00300 <span class="comment"> *   \ref ATSIGN "\@"</span>
<a name="l00301"></a>00301 <span class="comment"> *   the extent-map pages in </span>
<a name="l00302"></a>00302 <span class="comment"> *   ascending order to avoid latch-latch deadlocks;</span>
<a name="l00303"></a>00303 <span class="comment"> * - Ensuring that the previous- and next- extent numbers on the </span>
<a name="l00304"></a>00304 <span class="comment"> *   to-be-freed extent have not changed (so that we know that we have </span>
<a name="l00305"></a>00305 <span class="comment"> *   fixed the right pages);</span>
<a name="l00306"></a>00306 <span class="comment"> *   There should be no opportunity for these links to change since</span>
<a name="l00307"></a>00307 <span class="comment"> *   the volume manager is a monitor (protected by a read-write lock).</span>
<a name="l00308"></a>00308 <span class="comment"> * - Updating the extents and physically logging each of the updates.</span>
<a name="l00309"></a>00309 <span class="comment"> * - Updating caches related to the store.</span>
<a name="l00310"></a>00310 <span class="comment"> *</span>
<a name="l00311"></a>00311 <span class="comment"> * If the extent is in a still-allocated store, the entity freeing</span>
<a name="l00312"></a>00312 <span class="comment"> * the extent (the lock manager) will have acquired an EX lock on</span>
<a name="l00313"></a>00313 <span class="comment"> * the extent for the transaction. If the extent is part of a</span>
<a name="l00314"></a>00314 <span class="comment"> * destroyed store, the store will have an EX lock on it and this will</span>
<a name="l00315"></a>00315 <span class="comment"> * prevent any other transaction from trying to deallocate the extent.</span>
<a name="l00316"></a>00316 <span class="comment"> *</span>
<a name="l00317"></a>00317 <span class="comment"> * \subsection IMPLICAT Implications of This Design</span>
<a name="l00318"></a>00318 <span class="comment"> * This extent-based design has the following implications:</span>
<a name="l00319"></a>00319 <span class="comment"> * - Before it can be used, a volume must be formatted for a given size </span>
<a name="l00320"></a>00320 <span class="comment"> *   so that the number of extent map pages and store map pages can </span>
<a name="l00321"></a>00321 <span class="comment"> *   be established;</span>
<a name="l00322"></a>00322 <span class="comment"> * - Extending the volume requires reformatting, so the server is forced to</span>
<a name="l00323"></a>00323 <span class="comment"> *   perform database reorganization in this case;</span>
<a name="l00324"></a>00324 <span class="comment"> * - Location of an extlink_t can be determined arithmetically from a page</span>
<a name="l00325"></a>00325 <span class="comment"> *   number (thus also from a record ID), </span>
<a name="l00326"></a>00326 <span class="comment"> *   which is cheaper than looking in an index of any sort; however,</span>
<a name="l00327"></a>00327 <span class="comment"> *   this means that</span>
<a name="l00328"></a>00328 <span class="comment"> *   extra work is done to validate the record ID (that is, its </span>
<a name="l00329"></a>00329 <span class="comment"> *   page's store-membership);</span>
<a name="l00330"></a>00330 <span class="comment"> * - Because the store-membership of a page is immaterial in locating the page,</span>
<a name="l00331"></a>00331 <span class="comment"> *   the buffer-pool manager need not pay any attention to stores; in fact,</span>
<a name="l00332"></a>00332 <span class="comment"> *   it reduces I/O costs by sorting pages by {volume,page number} and writing </span>
<a name="l00333"></a>00333 <span class="comment"> *   contiguous pages in one system call;</span>
<a name="l00334"></a>00334 <span class="comment"> * - Because the store-membership of an extent is immaterial in locating the</span>
<a name="l00335"></a>00335 <span class="comment"> *   extent, extent locks do not contain a store number, and their locks</span>
<a name="l00336"></a>00336 <span class="comment"> *   can be aquired regardless of their allocation state.  One can</span>
<a name="l00337"></a>00337 <span class="comment"> *   test the "locked" status of an extent prior to allocating it.</span>
<a name="l00338"></a>00338 <span class="comment"> * - Extent-map pages tend to be hot (remain in the buffer pool), which </span>
<a name="l00339"></a>00339 <span class="comment"> *   minimizes I/O;</span>
<a name="l00340"></a>00340 <span class="comment"> * - Extent-map pages could be a source of latch contention, however</span>
<a name="l00341"></a>00341 <span class="comment"> *   they are only latched in the volume manager, which redirects the</span>
<a name="l00342"></a>00342 <span class="comment"> *   contention to the volume mutex;</span>
<a name="l00343"></a>00343 <span class="comment"> * - The number of page fixes required for finding free extents is bounded </span>
<a name="l00344"></a>00344 <span class="comment"> *   by the number of extent-map pages on the volume, and in some cases</span>
<a name="l00345"></a>00345 <span class="comment"> *   employs O(n) (linear) searches, as described in the item below;</span>
<a name="l00346"></a>00346 <span class="comment"> * - Pages may be reserved for allocation in a file without being allocated, </span>
<a name="l00347"></a>00347 <span class="comment"> *   so optimal use of the volume requires that the allocated extents </span>
<a name="l00348"></a>00348 <span class="comment"> *   be searched before new extents are allocated; </span>
<a name="l00349"></a>00349 <span class="comment"> * - Deallocating a page and changing store flags (logging attributes)</span>
<a name="l00350"></a>00350 <span class="comment"> *   of a page or store does not require touching the page itself; entire</span>
<a name="l00351"></a>00351 <span class="comment"> *   stores are deallocated by latching and updating only the required</span>
<a name="l00352"></a>00352 <span class="comment"> *   extent-map pages;</span>
<a name="l00353"></a>00353 <span class="comment"> * - The high fan-out of extent-map pages to pages ensures that deallocating</span>
<a name="l00354"></a>00354 <span class="comment"> *   stores is cheap;</span>
<a name="l00355"></a>00355 <span class="comment"> * - Clustering of pages is achieved, which is useful for large objects and</span>
<a name="l00356"></a>00356 <span class="comment"> *   can be helpful for file scans;</span>
<a name="l00357"></a>00357 <span class="comment"> * - Prefetching of file pages can be achieved by inspection of extent maps;</span>
<a name="l00358"></a>00358 <span class="comment"> * - Files need not impose their own structure on top of stores: store</span>
<a name="l00359"></a>00359 <span class="comment"> *   order is file order; the fact that the storage manager avoids </span>
<a name="l00360"></a>00360 <span class="comment"> *   superimposing a file structure has \ref FILERAMIFICATIONS "ramifications of its own".</span>
<a name="l00361"></a>00361 <span class="comment"> *</span>
<a name="l00362"></a>00362 <span class="comment"> *</span>
<a name="l00363"></a>00363 <span class="comment"> * The volume layer does not contain any means of spreading out or clustering</span>
<a name="l00364"></a>00364 <span class="comment"> * extents over extent-map pages for clustering (or for latch-contention </span>
<a name="l00365"></a>00365 <span class="comment"> * mitigation).</span>
<a name="l00366"></a>00366 <span class="comment"> *</span>
<a name="l00367"></a>00367 <span class="comment"> * \subsection ALLOCST Creating and Destroying Stores</span>
<a name="l00368"></a>00368 <span class="comment"> *</span>
<a name="l00369"></a>00369 <span class="comment"> * For each store  the storage manager keeps certain metadata about the store</span>
<a name="l00370"></a>00370 <span class="comment"> * in a \e directory, which is an index maintained by the \ref DIR_M.</span>
<a name="l00371"></a>00371 <span class="comment"> * </span>
<a name="l00372"></a>00372 <span class="comment"> * \anchor STORECREATE</span>
<a name="l00373"></a>00373 <span class="comment"> * Creating a store comprises:</span>
<a name="l00374"></a>00374 <span class="comment"> * - Finding an unused store number. This is a linear search through the</span>
<a name="l00375"></a>00375 <span class="comment"> *   store node map pages for a stnode_t (one with no associated extent list)</span>
<a name="l00376"></a>00376 <span class="comment"> *   that is not locked. The linear search starts at a revolving location.</span>
<a name="l00377"></a>00377 <span class="comment"> *   In the worst case, it will search all the stnode_t and therefore</span>
<a name="l00378"></a>00378 <span class="comment"> *   fix </span>
<a name="l00379"></a>00379 <span class="comment"> *   \ref ATSIGN "\@"</span>
<a name="l00380"></a>00380 <span class="comment"> *   all the store map pages;</span>
<a name="l00381"></a>00381 <span class="comment"> * - Aquiring a store lock in EX mode, long-duration;</span>
<a name="l00382"></a>00382 <span class="comment"> * - Finding an extent for the store (details \ref ALLOCEXTA "here");</span>
<a name="l00383"></a>00383 <span class="comment"> * - Updating the stnode_t </span>
<a name="l00384"></a>00384 <span class="comment"> *   \ref ATSIGN "\@"</span>
<a name="l00385"></a>00385 <span class="comment"> *   to reserve it (legitimize the store number);</span>
<a name="l00386"></a>00386 <span class="comment"> * - Logging the creation store operation without the first extent;</span>
<a name="l00387"></a>00387 <span class="comment"> * - Allocating the extent to the store (details \ref ALLOCEXTA2 "here")</span>
<a name="l00388"></a>00388 <span class="comment"> *   (we cannot allocate an extent without a legitimate owning store to which</span>
<a name="l00389"></a>00389 <span class="comment"> *   to allocate it);</span>
<a name="l00390"></a>00390 <span class="comment"> * - Updating the stnode_t to add the first extent </span>
<a name="l00391"></a>00391 <span class="comment"> *   \ref ATSIGN "\@";</span>
<a name="l00392"></a>00392 <span class="comment"> * - Logging the store operation to add the first exent to the store.</span>
<a name="l00393"></a>00393 <span class="comment"> *</span>
<a name="l00394"></a>00394 <span class="comment"> * Destroying a store before transaction-commit comprises these steps:</span>
<a name="l00395"></a>00395 <span class="comment"> * - Verify that the store number is a valid number (no latches required);</span>
<a name="l00396"></a>00396 <span class="comment"> * - Mark the store as deleted:</span>
<a name="l00397"></a>00397 <span class="comment"> *   - Latch the store map page (that holds the stnode_t) for the store </span>
<a name="l00398"></a>00398 <span class="comment"> *   \ref ATSIGN "\@";</span>
<a name="l00399"></a>00399 <span class="comment"> *   - EX-lock the store (long duration);</span>
<a name="l00400"></a>00400 <span class="comment"> *   - Mark the stnode_t as "t_deleting_store" </span>
<a name="l00401"></a>00401 <span class="comment"> *   \ref ATSIGN "\@"</span>
<a name="l00402"></a>00402 <span class="comment"> *   (meaning it is to be</span>
<a name="l00403"></a>00403 <span class="comment"> *   deleted at end-of-transaction, see \ref XCT_M);</span>
<a name="l00404"></a>00404 <span class="comment"> *   - Log this marking store operation;</span>
<a name="l00405"></a>00405 <span class="comment"> *   - Add the store to a list of stores to free when the transaction </span>
<a name="l00406"></a>00406 <span class="comment"> *   commits (See \ref XCT_M);</span>
<a name="l00407"></a>00407 <span class="comment"> * - Clear caches related to the store.</span>
<a name="l00408"></a>00408 <span class="comment"> *</span>
<a name="l00409"></a>00409 <span class="comment"> * \subsection SAFTERXCT Commit-Time Handling of Store-Destruction</span>
<a name="l00410"></a>00410 <span class="comment"> * Removing a store (at commit time) marked for deletion comprises these steps:</span>
<a name="l00411"></a>00411 <span class="comment"> * - Verify that the store is still marked for deletion (partial rollback</span>
<a name="l00412"></a>00412 <span class="comment"> *   does not inspect the list of stores to delete, and in any case, this</span>
<a name="l00413"></a>00413 <span class="comment"> *   has to be one on restart because the list is transient) </span>
<a name="l00414"></a>00414 <span class="comment"> *   \ref ATSIGN "\@",</span>
<a name="l00415"></a>00415 <span class="comment"> * - Update the stnode_t to indicate that the store's extents are about to</span>
<a name="l00416"></a>00416 <span class="comment"> *   be deallocated </span>
<a name="l00417"></a>00417 <span class="comment"> *   \ref ATSIGN "\@";</span>
<a name="l00418"></a>00418 <span class="comment"> * - Log the above store operation for crash recovery;</span>
<a name="l00419"></a>00419 <span class="comment"> * - Free (really) the extents in the store </span>
<a name="l00420"></a>00420 <span class="comment"> *   \ref ATSIGN "\@";</span>
<a name="l00421"></a>00421 <span class="comment"> * - Update the stnode_t to clear its first extent </span>
<a name="l00422"></a>00422 <span class="comment"> *   \ref ATSIGN "\@";</span>
<a name="l00423"></a>00423 <span class="comment"> * - Log the store as having been deleted in toto;</span>
<a name="l00424"></a>00424 <span class="comment"> * - Clear cached information for this store.</span>
<a name="l00425"></a>00425 <span class="comment"> *</span>
<a name="l00426"></a>00426 <span class="comment"> * \subsection ALLOCPG Allocation and Deallocation of Pages</span>
<a name="l00427"></a>00427 <span class="comment"> *</span>
<a name="l00428"></a>00428 <span class="comment"> * Allocating an extent to a store does not make its pages "visible" to the</span>
<a name="l00429"></a>00429 <span class="comment"> * server. They are considered "reserved".</span>
<a name="l00430"></a>00430 <span class="comment"> * Pages within the extent have to be allocated </span>
<a name="l00431"></a>00431 <span class="comment"> * (their bits in the extent's bitmap must be set).  </span>
<a name="l00432"></a>00432 <span class="comment"> *</span>
<a name="l00433"></a>00433 <span class="comment"> * When the store is used for an index, the page is not </span>
<a name="l00434"></a>00434 <span class="comment"> * visible until it has been formatted</span>
<a name="l00435"></a>00435 <span class="comment"> * and inserted (linked) into the index.  </span>
<a name="l00436"></a>00436 <span class="comment"> * In the case of files, however,</span>
<a name="l00437"></a>00437 <span class="comment"> * the situation is complicated by the lack of linkage of file pages by</span>
<a name="l00438"></a>00438 <span class="comment"> * another means.  Pages used for large objects are referenced through an</span>
<a name="l00439"></a>00439 <span class="comment"> * index in the object's metadata, but pages used </span>
<a name="l00440"></a>00440 <span class="comment"> * for small objects become part of the</span>
<a name="l00441"></a>00441 <span class="comment"> * file when the </span>
<a name="l00442"></a>00442 <span class="comment"> * page's extent bitmap indicates that it is</span>
<a name="l00443"></a>00443 <span class="comment"> * allocated. </span>
<a name="l00444"></a>00444 <span class="comment"> * \anchor FILERAMIFICATIONS</span>
<a name="l00445"></a>00445 <span class="comment"> * This has some significant ramifications:</span>
<a name="l00446"></a>00446 <span class="comment"> * - neither deallocation nor allocation of file pages requires latching of</span>
<a name="l00447"></a>00447 <span class="comment"> *   previous and next pages for linking purposes;</span>
<a name="l00448"></a>00448 <span class="comment"> * - the file manager and index managers handle page allocation somewhat</span>
<a name="l00449"></a>00449 <span class="comment"> *   differently;</span>
<a name="l00450"></a>00450 <span class="comment"> * - the file manager must go to great lengths to ensure that the</span>
<a name="l00451"></a>00451 <span class="comment"> *   page is not accessible until both allocated and formatted, and</span>
<a name="l00452"></a>00452 <span class="comment"> *   to ensure the safety of</span>
<a name="l00453"></a>00453 <span class="comment"> *   the file structure in event of error or crash.</span>
<a name="l00454"></a>00454 <span class="comment"> *</span>
<a name="l00455"></a>00455 <span class="comment"> * Despite the fact that the intended uses of the page require different</span>
<a name="l00456"></a>00456 <span class="comment"> * handling, a significant part of page allocation is </span>
<a name="l00457"></a>00457 <span class="comment"> * generic and is handled by the volume layer.  To handle some of the</span>
<a name="l00458"></a>00458 <span class="comment"> * contextual differences, the volume layer uses a callback to the</span>
<a name="l00459"></a>00459 <span class="comment"> * calling manager.  </span>
<a name="l00460"></a>00460 <span class="comment"> *</span>
<a name="l00461"></a>00461 <span class="comment"> * \anchor ALLOCPGTOSTORE</span>
<a name="l00462"></a>00462 <span class="comment"> * Allocating a page to a store comprises these steps</span>
<a name="l00463"></a>00463 <span class="comment"> * (in fact, the code is</span>
<a name="l00464"></a>00464 <span class="comment"> * written to allocate a number of pages at once; this description is </span>
<a name="l00465"></a>00465 <span class="comment"> * simplified):</span>
<a name="l00466"></a>00466 <span class="comment"> * - Locate a reserved page in the store</span>
<a name="l00467"></a>00467 <span class="comment"> *   - if the page must be \e appended to the store, special precautions are</span>
<a name="l00468"></a>00468 <span class="comment"> *   needed to ensure that the reserved page is the next unallocated page </span>
<a name="l00469"></a>00469 <span class="comment"> *   in the last extent of the store </span>
<a name="l00470"></a>00470 <span class="comment"> *   \ref ATSIGN "\@";</span>
<a name="l00471"></a>00471 <span class="comment"> *   - if the page need not be appended, any reserved page will do</span>
<a name="l00472"></a>00472 <span class="comment"> *      - look in the cache for extents with reserved pages</span>
<a name="l00473"></a>00473 <span class="comment"> *      - if none found \e and we are not in append-only context,</span>
<a name="l00474"></a>00474 <span class="comment"> *      search the file's extents for reserved pages </span>
<a name="l00475"></a>00475 <span class="comment"> *   \ref ATSIGN "\@";</span>
<a name="l00476"></a>00476 <span class="comment"> *      (This can be disabled by changing the value </span>
<a name="l00477"></a>00477 <span class="comment"> *      of the constant \e never_search in sm_io.cpp.)</span>
<a name="l00478"></a>00478 <span class="comment"> * - If no reserved pages are found, find and allocate an extent </span>
<a name="l00479"></a>00479 <span class="comment"> *   (details \ref ALLOCEXTA "here");</span>
<a name="l00480"></a>00480 <span class="comment"> * - Acquire an IX lock on the extent in which we found reserved page(s)</span>
<a name="l00481"></a>00481 <span class="comment"> * - Find a reserved page in the given extent that has \e no \e lock on it</span>
<a name="l00482"></a>00482 <span class="comment"> *   (if no such thing exists, skip this extent and find another</span>
<a name="l00483"></a>00483 <span class="comment"> *   \ref ATSIGN "\@");</span>
<a name="l00484"></a>00484 <span class="comment"> * - Acquire a lock on the available page </span>
<a name="l00485"></a>00485 <span class="comment"> *   (mode IX or EX, and duration depend on the context)</span>
<a name="l00486"></a>00486 <span class="comment"> *   - the file manager when allocating a small-record file page</span>
<a name="l00487"></a>00487 <span class="comment"> *   uses IX mode, long(commit-) duration, </span>
<a name="l00488"></a>00488 <span class="comment"> *   which means that</span>
<a name="l00489"></a>00489 <span class="comment"> *   deallocated pages will not be reallocated until after the deallocating </span>
<a name="l00490"></a>00490 <span class="comment"> *   transaction commits (see \ref XAFTERXCT);</span>
<a name="l00491"></a>00491 <span class="comment"> *   - the file manager when allocating pages for large records </span>
<a name="l00492"></a>00492 <span class="comment"> *   uses long duration, </span>
<a name="l00493"></a>00493 <span class="comment"> *   IX or EX mode, depending on the exact use of the page for </span>
<a name="l00494"></a>00494 <span class="comment"> *   (various) large-record structures; long-duration locks mean that</span>
<a name="l00495"></a>00495 <span class="comment"> *   deallocated pages will not be reallocated until the deallocating ;</span>
<a name="l00496"></a>00496 <span class="comment"> *   - btree index manager uses EX mode, instant duration , meaning that</span>
<a name="l00497"></a>00497 <span class="comment"> *   deallocated pages can be re-used;</span>
<a name="l00498"></a>00498 <span class="comment"> *   - rtree index manager uses EX mode, instant duration, meaning that</span>
<a name="l00499"></a>00499 <span class="comment"> *   deallocated pages can be re-used;</span>
<a name="l00500"></a>00500 <span class="comment"> * - Call back to (file or index) manager to accept or reject this page:</span>
<a name="l00501"></a>00501 <span class="comment"> *   - file manager allocating a small-record file page</span>
<a name="l00502"></a>00502 <span class="comment"> *   fixes </span>
<a name="l00503"></a>00503 <span class="comment"> *   \ref ATSIGN "\@"</span>
<a name="l00504"></a>00504 <span class="comment"> *   the page (for formatting) and returns "accept";</span>
<a name="l00505"></a>00505 <span class="comment"> *   - file manager allocating a large-record page just returns "accept";</span>
<a name="l00506"></a>00506 <span class="comment"> *   - rtree and btree index managers just return "accept";</span>
<a name="l00507"></a>00507 <span class="comment"> * - Log the page allocation, </span>
<a name="l00508"></a>00508 <span class="comment"> *   set "has-page-allocated" indicator in the extent lock.</span>
<a name="l00509"></a>00509 <span class="comment"> *</span>
<a name="l00510"></a>00510 <span class="comment"> * As mentioned above, there are times when the volume manager is told to</span>
<a name="l00511"></a>00511 <span class="comment"> * allocate new pages at the end of the store (append).  This happens </span>
<a name="l00512"></a>00512 <span class="comment"> * when the file manager allocates small-object file pages unless the</span>
<a name="l00513"></a>00513 <span class="comment"> * caller passes in the policy t_compact, indicating that it should search</span>
<a name="l00514"></a>00514 <span class="comment"> * the file for available pages.</span>
<a name="l00515"></a>00515 <span class="comment"> * The server can choose its policy when calling \ref ss_m::create_rec</span>
<a name="l00516"></a>00516 <span class="comment"> * (see \ref pg_policy_t).</span>
<a name="l00517"></a>00517 <span class="comment"> * When the server uses \ref append_file_i, only the policy t_append</span>
<a name="l00518"></a>00518 <span class="comment"> * is used, which enforces append-only page allocation.</span>
<a name="l00519"></a>00519 <span class="comment"> *</span>
<a name="l00520"></a>00520 <span class="comment"> * Deallocating a page in a store comprises these steps:</span>
<a name="l00521"></a>00521 <span class="comment"> * - Acquire a long-duration EX lock on the page;</span>
<a name="l00522"></a>00522 <span class="comment"> * - Verify the store-membership of the page if required to do so (by</span>
<a name="l00523"></a>00523 <span class="comment"> *   the file manager in cases in which it was forced to  unfix</span>
<a name="l00524"></a>00524 <span class="comment"> *   and  fix </span>
<a name="l00525"></a>00525 <span class="comment"> *   \ref ATSIGN "\@"</span>
<a name="l00526"></a>00526 <span class="comment"> *   the page);</span>
<a name="l00527"></a>00527 <span class="comment"> * - Acquire a long-duration IX lock on the page's extent;</span>
<a name="l00528"></a>00528 <span class="comment"> * - Fix </span>
<a name="l00529"></a>00529 <span class="comment"> *   \ref ATSIGN "\@"</span>
<a name="l00530"></a>00530 <span class="comment"> *   the extent-map page and update the extent's bitmap, log the update. </span>
<a name="l00531"></a>00531 <span class="comment"> * - If the extent now contains only reserved pages, mark the extent as</span>
<a name="l00532"></a>00532 <span class="comment"> *   removable (clear the extent-has-allocated-page bit in the already-held</span>
<a name="l00533"></a>00533 <span class="comment"> *   IX lock).</span>
<a name="l00534"></a>00534 <span class="comment"> *</span>
<a name="l00535"></a>00535 <span class="comment"> *</span>
<a name="l00536"></a>00536 <span class="comment"> * \subsection VOLCACHES Volume Manager Caches </span>
<a name="l00537"></a>00537 <span class="comment"> * The volume manager does not contain any persistent indices to </span>
<a name="l00538"></a>00538 <span class="comment"> * assist in finding free pages in a store's allocated extents (which it</span>
<a name="l00539"></a>00539 <span class="comment"> * can do only when not forced to append to the store). </span>
<a name="l00540"></a>00540 <span class="comment"> * To minimize the need for linear searches through the store's extents,</span>
<a name="l00541"></a>00541 <span class="comment"> * the volume manager </span>
<a name="l00542"></a>00542 <span class="comment"> * caches information about reserved pages in each store, the</span>
<a name="l00543"></a>00543 <span class="comment"> * \b reserved-page \b cache.</span>
<a name="l00544"></a>00544 <span class="comment"> * This is a map (set of pairs mapping snum_t -&gt; extnum_t) to find extents</span>
<a name="l00545"></a>00545 <span class="comment"> * already allocated to a store that contain free pages. This</span>
<a name="l00546"></a>00546 <span class="comment"> * cache is consulted before new extents are allocated to a store.</span>
<a name="l00547"></a>00547 <span class="comment"> * Since after restart the cache is necessarily empty, it is primed when</span>
<a name="l00548"></a>00548 <span class="comment"> * first needed for the purpose of allocating anything for the store. </span>
<a name="l00549"></a>00549 <span class="comment"> *</span>
<a name="l00550"></a>00550 <span class="comment"> * The volume manager also keeps a \b last-page \b cache.</span>
<a name="l00551"></a>00551 <span class="comment"> * This is a map from snum_t to extnum_t; the extent number is that of</span>
<a name="l00552"></a>00552 <span class="comment"> * the last extent allocated to the store. From this one can arithmetically</span>
<a name="l00553"></a>00553 <span class="comment"> * derive the last page in (reserved or possibly allocated) the store.</span>
<a name="l00554"></a>00554 <span class="comment"> * Note that the last page \e allocated to the store might be anywhere in</span>
<a name="l00555"></a>00555 <span class="comment"> * the store's exent list; all pages after that might be \e reserved but</span>
<a name="l00556"></a>00556 <span class="comment"> * not allocated.</span>
<a name="l00557"></a>00557 <span class="comment"> *</span>
<a name="l00558"></a>00558 <span class="comment"> * Priming caches is an expensive operation.</span>
<a name="l00559"></a>00559 <span class="comment"> * It is not done on each volume mount, because volumes are mounted and</span>
<a name="l00560"></a>00560 <span class="comment"> * dismounted several times during recovery, and priming on each</span>
<a name="l00561"></a>00561 <span class="comment"> * mount would be prohibitive.</span>
<a name="l00562"></a>00562 <span class="comment"> * Every attempt to allocate a page checks the store's reserved-page </span>
<a name="l00563"></a>00563 <span class="comment"> * cache; if it is empty, it is primed.</span>
<a name="l00564"></a>00564 <span class="comment"> * Every time an extent is allocated or a last-page-in-file is located,</span>
<a name="l00565"></a>00565 <span class="comment"> * the last-page cache is updated.</span>
<a name="l00566"></a>00566 <span class="comment"> *</span>
<a name="l00567"></a>00567 <span class="comment"> * \subsection PAGES Page Types</span>
<a name="l00568"></a>00568 <span class="comment"> * Pages in a volume come in a variety of page types, all the same size.</span>
<a name="l00569"></a>00569 <span class="comment"> * The size of a page is a compile-time constant.  It is controlled by</span>
<a name="l00570"></a>00570 <span class="comment"> * a build-time configuration option (see </span>
<a name="l00571"></a>00571 <span class="comment"> * \ref CONFIGOPT). the default page size is 8192 bytes.</span>
<a name="l00572"></a>00572 <span class="comment"> *</span>
<a name="l00573"></a>00573 <span class="comment"> * All pages are \e slotted (those that don't need the slot structure</span>
<a name="l00574"></a>00574 <span class="comment"> * may use only one slot) and have the following layout:</span>
<a name="l00575"></a>00575 <span class="comment"> * - header, including</span>
<a name="l00576"></a>00576 <span class="comment"> *   - lsn_t log sequence number of last page update</span>
<a name="l00577"></a>00577 <span class="comment"> *   - page id</span>
<a name="l00578"></a>00578 <span class="comment"> *   - links to next and previous pages (used by some storage structures)</span>
<a name="l00579"></a>00579 <span class="comment"> *   - page tag (indicates type of page)</span>
<a name="l00580"></a>00580 <span class="comment"> *   - space management metadata (space_t)</span>
<a name="l00581"></a>00581 <span class="comment"> *   - store flags (logging level metadata)</span>
<a name="l00582"></a>00582 <span class="comment"> * - slots (grow down)</span>
<a name="l00583"></a>00583 <span class="comment"> * - slot table array of pointers to the slots (grows up)</span>
<a name="l00584"></a>00584 <span class="comment"> * - footer (copy of log sequence number of last page update)</span>
<a name="l00585"></a>00585 <span class="comment"> *</span>
<a name="l00586"></a>00586 <span class="comment"> * Each page type is a C++ class that derives from the base class</span>
<a name="l00587"></a>00587 <span class="comment"> * page_p.  Page_p implements functionality that is common to all</span>
<a name="l00588"></a>00588 <span class="comment"> * (or most) page types. The types are as follows:</span>
<a name="l00589"></a>00589 <span class="comment"> *</span>
<a name="l00590"></a>00590 <span class="comment"> * - extlink_p : extent-link pages, used by vol_m</span>
<a name="l00591"></a>00591 <span class="comment"> * - stnode_p  : store-node pages, used by vol_m</span>
<a name="l00592"></a>00592 <span class="comment"> * - file_p    : slotted pages of file-of-record, used by file_m</span>
<a name="l00593"></a>00593 <span class="comment"> * - lgdata_p  : pages of large records, used by file_m</span>
<a name="l00594"></a>00594 <span class="comment"> * - lgindex_p : pages of large records, used by file_m</span>
<a name="l00595"></a>00595 <span class="comment"> * - keyed_p   : slotted pages of indexes, used by btree_m</span>
<a name="l00596"></a>00596 <span class="comment"> * - zkeyed_p  : slotted pages of indexes, used by btree_m</span>
<a name="l00597"></a>00597 <span class="comment"> * - rtree_p   : slotted pages of spatial indexes, used by rtree_m</span>
<a name="l00598"></a>00598 <span class="comment"> *</span>
<a name="l00599"></a>00599 <span class="comment"> * Issues specific to the page types will be dealt with in the descriptions of the modules that use them.</span>
<a name="l00600"></a>00600 <span class="comment"> *</span>
<a name="l00601"></a>00601 <span class="comment"> *  </span>
<a name="l00602"></a>00602 <span class="comment"> * \subsection RSVD_MODE Space Reservation on a Page</span>
<a name="l00603"></a>00603 <span class="comment"> *</span>
<a name="l00604"></a>00604 <span class="comment"> * Different storage structures offer different opportunities for fine-grained </span>
<a name="l00605"></a>00605 <span class="comment"> * locking and need different means of allocation space within a page.</span>
<a name="l00606"></a>00606 <span class="comment"> * Special care is taken to reserve space on a page when slots </span>
<a name="l00607"></a>00607 <span class="comment"> * are freed (records are deleted) so that rollback can restore </span>
<a name="l00608"></a>00608 <span class="comment"> * the space on the page.  </span>
<a name="l00609"></a>00609 <span class="comment"> * Page types that use this space reservation have </span>
<a name="l00610"></a>00610 <span class="comment"> * \code page_p::rsvd_mode() == true \endcode.</span>
<a name="l00611"></a>00611 <span class="comment"> *</span>
<a name="l00612"></a>00612 <span class="comment"> * In the case of B-trees, space reservation is not used because</span>
<a name="l00613"></a>00613 <span class="comment"> * undo and redo are handled logically -- entries </span>
<a name="l00614"></a>00614 <span class="comment"> * can be re-inserted in a different page.  But in the case of files, </span>
<a name="l00615"></a>00615 <span class="comment"> * records are identified by physical ID, which includes page and slot number,</span>
<a name="l00616"></a>00616 <span class="comment"> * so records must be reinserted just where they first appeared. </span>
<a name="l00617"></a>00617 <span class="comment"> *</span>
<a name="l00618"></a>00618 <span class="comment"> * Holes in a page are coalesced (moved to the end of the page) as needed, </span>
<a name="l00619"></a>00619 <span class="comment"> * when the total free space on the page satisfies a need but the </span>
<a name="l00620"></a>00620 <span class="comment"> * contiguous free space does not.  Hence, a record truncation followed </span>
<a name="l00621"></a>00621 <span class="comment"> * by an append to the same record does not necessarily cause the </span>
<a name="l00622"></a>00622 <span class="comment"> * shifting of other records on the same page.</span>
<a name="l00623"></a>00623 <span class="comment"> *</span>
<a name="l00624"></a>00624 <span class="comment"> * A count of free bytes is maintained for all pages. Free-space</span>
<a name="l00625"></a>00625 <span class="comment"> * metadata are maintained for rsvd_mode() pages:</span>
<a name="l00626"></a>00626 <span class="comment"> * - When a transaction releases a slot on a page with rsvd_mode(), the slot </span>
<a name="l00627"></a>00627 <span class="comment"> * remains</span>
<a name="l00628"></a>00628 <span class="comment"> * "reserved" for use by the same transaction. </span>
<a name="l00629"></a>00629 <span class="comment"> * - That slot is not free to be allocated by another transaction until </span>
<a name="l00630"></a>00630 <span class="comment"> * the releasing transaction commits.  </span>
<a name="l00631"></a>00631 <span class="comment"> * This is because if the transaction aborts, the slot must</span>
<a name="l00632"></a>00632 <span class="comment"> * be restored with the same slot number.  </span>
<a name="l00633"></a>00633 <span class="comment"> * Not only must the slot number be  preserved, </span>
<a name="l00634"></a>00634 <span class="comment"> * but the number of bytes consumed by that slot must remain </span>
<a name="l00635"></a>00635 <span class="comment"> * available lest the transaction abort.</span>
<a name="l00636"></a>00636 <span class="comment"> * - The storage manager keeps track of the youngest active transaction</span>
<a name="l00637"></a>00637 <span class="comment"> * that is freeing space (i.e., "reserving" it) on the page </span>
<a name="l00638"></a>00638 <span class="comment"> * and the number of bytes freed ("reserved")</span>
<a name="l00639"></a>00639 <span class="comment"> * by the youngest transaction.  </span>
<a name="l00640"></a>00640 <span class="comment"> * - When the youngest transaction to reserve space on the page becomes</span>
<a name="l00641"></a>00641 <span class="comment"> * older than the oldest active transaction in the system, the reserved</span>
<a name="l00642"></a>00642 <span class="comment"> * space becomes free. This check for freeing up the reserved space happens</span>
<a name="l00643"></a>00643 <span class="comment"> * whenever a transaction tries to allocate space on the page.</span>
<a name="l00644"></a>00644 <span class="comment"> * - During rollback, a transaction can use \e any amount of</span>
<a name="l00645"></a>00645 <span class="comment"> * reserved space, but during forward processing, it can only use space</span>
<a name="l00646"></a>00646 <span class="comment"> * it reserved, and that is known only if the transaction in question is</span>
<a name="l00647"></a>00647 <span class="comment"> * the youngest transaction described in the above paragraph.</span>
<a name="l00648"></a>00648 <span class="comment"> * - The changes to space-reservation metadata (space_t) are not logged.</span>
<a name="l00649"></a>00649 <span class="comment"> * The actions that result in updates to this metadata are logged (as</span>
<a name="l00650"></a>00650 <span class="comment"> * page mark and page reclaim).</span>
<a name="l00651"></a>00651 <span class="comment"> *</span>
<a name="l00652"></a>00652 <span class="comment"> * \section FILE_M File Manager</span>
<a name="l00653"></a>00653 <span class="comment"> * A file is a group of variable-sized records.</span>
<a name="l00654"></a>00654 <span class="comment"> * A record is the smallest persistent datum that has identity.</span>
<a name="l00655"></a>00655 <span class="comment"> * A record may also have a "user header", whose contents are</span>
<a name="l00656"></a>00656 <span class="comment"> * for use by the server.  </span>
<a name="l00657"></a>00657 <span class="comment"> * As records vary in size, so their storage representation varies. </span>
<a name="l00658"></a>00658 <span class="comment"> * The storage manager changes the storage representation as needed.</span>
<a name="l00659"></a>00659 <span class="comment"> *</span>
<a name="l00660"></a>00660 <span class="comment"> * A file comprises two stores.  </span>
<a name="l00661"></a>00661 <span class="comment"> * One store is allocated for slotted (small-record) pages, called file_p</span>
<a name="l00662"></a>00662 <span class="comment"> * pages.  </span>
<a name="l00663"></a>00663 <span class="comment"> * One store is allocated for large records, and contains lgdata_p and</span>
<a name="l00664"></a>00664 <span class="comment"> * lgindex_p pages.</span>
<a name="l00665"></a>00665 <span class="comment"> * Small records are those whose size is less than or equal to</span>
<a name="l00666"></a>00666 <span class="comment"> * sm_config_info_t.max_small_rec.  A record larger than this</span>
<a name="l00667"></a>00667 <span class="comment"> * has a slot on a small-record page, which slot contains metadata</span>
<a name="l00668"></a>00668 <span class="comment"> * refering to pages in the large-record store.</span>
<a name="l00669"></a>00669 <span class="comment"> * The scan order of a file is the physical order of the records</span>
<a name="l00670"></a>00670 <span class="comment"> * in the small-record store.</span>
<a name="l00671"></a>00671 <span class="comment"> *</span>
<a name="l00672"></a>00672 <span class="comment"> * Every record, large or small, has the following metadata in the</span>
<a name="l00673"></a>00673 <span class="comment"> * record's slot on the file_p page; these data are held in a rectag_t</span>
<a name="l00674"></a>00674 <span class="comment"> * structure:</span>
<a name="l00675"></a>00675 <span class="comment"> * \code</span>
<a name="l00676"></a>00676 <span class="comment">struct rectag_t {</span>
<a name="l00677"></a>00677 <span class="comment">    uint2_t   hdr_len;  // length of user header, may be zero</span>
<a name="l00678"></a>00678 <span class="comment">    uint2_t   flags;    // enum recflags_t: indicates internal implementation</span>
<a name="l00679"></a>00679 <span class="comment">    smsize_t  body_len; // true length of the record </span>
<a name="l00680"></a>00680 <span class="comment">};</span>
<a name="l00681"></a>00681 <span class="comment">\endcode</span>
<a name="l00682"></a>00682 <span class="comment">  * The flags have have these values:</span>
<a name="l00683"></a>00683 <span class="comment">    - t_small   : a small record, entirely contained on the file_p</span>
<a name="l00684"></a>00684 <span class="comment">    - t_large_0 : a large record, the slot on the file_p contains the</span>
<a name="l00685"></a>00685 <span class="comment">                  user header, while the body is a list</span>
<a name="l00686"></a>00686 <span class="comment">                  of chunks (pointers to contiguous lgdata_p pages)</span>
<a name="l00687"></a>00687 <span class="comment">    - t_large_1 : a large record, the slot on the file_p contains the</span>
<a name="l00688"></a>00688 <span class="comment">                  user header, while the body is a reference to a single</span>
<a name="l00689"></a>00689 <span class="comment">                  lgindex_p page, which is the root of a 1-level index of</span>
<a name="l00690"></a>00690 <span class="comment">                  lgdata_p pages.</span>
<a name="l00691"></a>00691 <span class="comment">    - t_large_2 : like t_large_1 but the index may be two levels deep. This</span>
<a name="l00692"></a>00692 <span class="comment">                  has not been implemented.</span>
<a name="l00693"></a>00693 <span class="comment"> *</span>
<a name="l00694"></a>00694 <span class="comment"> * Internally (inside the storage manager), the class record_t is a</span>
<a name="l00695"></a>00695 <span class="comment"> * handle on the record's tag and is the class through which the</span>
<a name="l00696"></a>00696 <span class="comment"> * rectag_t is manipulated.</span>
<a name="l00697"></a>00697 <span class="comment"> *</span>
<a name="l00698"></a>00698 <span class="comment"> * A record is exposed to the server through a set </span>
<a name="l00699"></a>00699 <span class="comment"> * of ss_m methods (\ref ss_m::create_rec,</span>
<a name="l00700"></a>00700 <span class="comment"> * \ref ss_m::append_rec, etc), and through the \ref pin_i class.</span>
<a name="l00701"></a>00701 <span class="comment"> *</span>
<a name="l00702"></a>00702 <span class="comment"> * \attention</span>
<a name="l00703"></a>00703 <span class="comment"> * All updates to records are accomplished by copying out part or all of</span>
<a name="l00704"></a>00704 <span class="comment"> * the record from the buffer pool to the server's address space, performing</span>
<a name="l00705"></a>00705 <span class="comment"> * updates there, and handing the new data to the storage manager. </span>
<a name="l00706"></a>00706 <span class="comment"> * User (server) data are not updated directly in the buffer pool.</span>
<a name="l00707"></a>00707 <span class="comment"> *</span>
<a name="l00708"></a>00708 <span class="comment"> * The server may cause the file_p and at most one large data page to</span>
<a name="l00709"></a>00709 <span class="comment"> * be pinned for a given record through the pin_i class; the server must</span>
<a name="l00710"></a>00710 <span class="comment"> * take care not to create latch-latch deadlocks by holding a record pinned</span>
<a name="l00711"></a>00711 <span class="comment"> * while attempting to pin another.  An ordering protocol among the pages</span>
<a name="l00712"></a>00712 <span class="comment"> * pinned must be observed to avoid such deadlocks.</span>
<a name="l00713"></a>00713 <span class="comment"> *</span>
<a name="l00714"></a>00714 <span class="comment"> * \note The system only detects lock-lock deadlocks.  Deadlocks involving</span>
<a name="l00715"></a>00715 <span class="comment"> * mutexes or latches or other blocking mechanisms will cause the server to</span>
<a name="l00716"></a>00716 <span class="comment"> * hang.</span>
<a name="l00717"></a>00717 <span class="comment"> *</span>
<a name="l00718"></a>00718 <span class="comment"> * \subsection ALLOCFL Creating and Destroying a File of Records</span>
<a name="l00719"></a>00719 <span class="comment"> *</span>
<a name="l00720"></a>00720 <span class="comment"> * Creating a file comprises these steps:</span>
<a name="l00721"></a>00721 <span class="comment"> * - Create a store of file_p pages for the record headers and </span>
<a name="l00722"></a>00722 <span class="comment"> *   small-record bodies </span>
<a name="l00723"></a>00723 <span class="comment"> *   (details are \ref STORECREATE "here");</span>
<a name="l00724"></a>00724 <span class="comment"> * - Create a store of lgindex_p and lgdata_p pages for the </span>
<a name="l00725"></a>00725 <span class="comment"> *   large objects</span>
<a name="l00726"></a>00726 <span class="comment"> *   (details are \ref STORECREATE "here");</span>
<a name="l00727"></a>00727 <span class="comment"> * - Acquire a long-duration EX lock on the store id;</span>
<a name="l00728"></a>00728 <span class="comment"> * - Create the "file structure" on the first store. This means a</span>
<a name="l00729"></a>00729 <span class="comment"> *   single page is allocated</span>
<a name="l00730"></a>00730 <span class="comment"> *   and formatted as a file_p page with no records</span>
<a name="l00731"></a>00731 <span class="comment"> *   in use</span>
<a name="l00732"></a>00732 <span class="comment"> *   (details are \ref ALLOCPAGETOSTORE "here");</span>
<a name="l00733"></a>00733 <span class="comment"> *   ;</span>
<a name="l00734"></a>00734 <span class="comment"> * - Insert the file meta-data in the file-directory index (see \ref DIR_M).</span>
<a name="l00735"></a>00735 <span class="comment"> *   This involves several page fixes for the btree insertion </span>
<a name="l00736"></a>00736 <span class="comment"> *   \ref ATSIGN "\@".</span>
<a name="l00737"></a>00737 <span class="comment"> *</span>
<a name="l00738"></a>00738 <span class="comment"> * Destroying a file comprises these steps:</span>
<a name="l00739"></a>00739 <span class="comment"> * - Consult the directory entry for the file's small-object store, </span>
<a name="l00740"></a>00740 <span class="comment"> *   thus acquiring an EX long-duration lock on the file;</span>
<a name="l00741"></a>00741 <span class="comment"> *   This will involve page fixes for reading the btree directory.</span>
<a name="l00742"></a>00742 <span class="comment"> * - Verify that the store is really used for a file, and still exists;</span>
<a name="l00743"></a>00743 <span class="comment"> *   This requires SH-latching a store map page to inspect the stnode_t for</span>
<a name="l00744"></a>00744 <span class="comment"> *   the store </span>
<a name="l00745"></a>00745 <span class="comment"> *   \ref ATSIGN "\@";</span>
<a name="l00746"></a>00746 <span class="comment"> * - Mark the store for destruction</span>
<a name="l00747"></a>00747 <span class="comment"> *   (details are in \ref ALLOCST ).</span>
<a name="l00748"></a>00748 <span class="comment"> * - Remove transient histogram information for the store;</span>
<a name="l00749"></a>00749 <span class="comment"> * - From the store directory, determine the large-object store associated</span>
<a name="l00750"></a>00750 <span class="comment"> *   with the file;</span>
<a name="l00751"></a>00751 <span class="comment"> * - Mark the large-object store for destruction</span>
<a name="l00752"></a>00752 <span class="comment"> *   (details are in \ref ALLOCST ).</span>
<a name="l00753"></a>00753 <span class="comment"> * - Remove the file's metatdata from the directory </span>
<a name="l00754"></a>00754 <span class="comment"> *   \ref ATSIGN "\@"</span>
<a name="l00755"></a>00755 <span class="comment"> *   (\ref DIR_M).</span>
<a name="l00756"></a>00756 <span class="comment"> *</span>
<a name="l00757"></a>00757 <span class="comment"> * \subsection HISTO Finding Space for a Record</span>
<a name="l00758"></a>00758 <span class="comment"> *</span>
<a name="l00759"></a>00759 <span class="comment"> * The file manager caches information</span>
<a name="l00760"></a>00760 <span class="comment"> * about page utilization for (small-object) pages in each file so that it can</span>
<a name="l00761"></a>00761 <span class="comment"> * control fragmentation of files.</span>
<a name="l00762"></a>00762 <span class="comment"> * This cached information takes the form of a </span>
<a name="l00763"></a>00763 <span class="comment"> * histoid_t, which contains a \b heap and a \b histogram.  </span>
<a name="l00764"></a>00764 <span class="comment"> *</span>
<a name="l00765"></a>00765 <span class="comment"> * The \b heap keeps track of the amount of free space in </span>
<a name="l00766"></a>00766 <span class="comment"> * (recently-used) pages in the heap, and it is </span>
<a name="l00767"></a>00767 <span class="comment"> * searchable so that it can</span>
<a name="l00768"></a>00768 <span class="comment"> * return the page with the smallest free space that is larger than a</span>
<a name="l00769"></a>00769 <span class="comment"> * given value in bytes.</span>
<a name="l00770"></a>00770 <span class="comment"> * The free-space-on-page value that it uses for this purpose</span>
<a name="l00771"></a>00771 <span class="comment"> * is the most liberal value -- it's possible that some of the space on</span>
<a name="l00772"></a>00772 <span class="comment"> * the page is reserved for a transaction that has not yet committed</span>
<a name="l00773"></a>00773 <span class="comment"> * (if that transaction destroyed a record, it can use space that other</span>
<a name="l00774"></a>00774 <span class="comment"> * transactions cannot).</span>
<a name="l00775"></a>00775 <span class="comment"> * \bug GNATS 157 The histoid_t heap should have some size limit (number of entries).</span>
<a name="l00776"></a>00776 <span class="comment"> *</span>
<a name="l00777"></a>00777 <span class="comment"> * The  \b histogram has a small number of buckets, each of which counts</span>
<a name="l00778"></a>00778 <span class="comment"> * the number of pages in the file containing free space between </span>
<a name="l00779"></a>00779 <span class="comment"> * the bucket min and the bucket max.</span>
<a name="l00780"></a>00780 <span class="comment"> *</span>
<a name="l00781"></a>00781 <span class="comment"> *</span>
<a name="l00782"></a>00782 <span class="comment"> * When a record is created, the file manager </span>
<a name="l00783"></a>00783 <span class="comment"> * tries to use an already-allocated</span>
<a name="l00784"></a>00784 <span class="comment"> * page that has space for the record. </span>
<a name="l00785"></a>00785 <span class="comment"> * It determines what space is needed</span>
<a name="l00786"></a>00786 <span class="comment"> * for the record from the length hint and</span>
<a name="l00787"></a>00787 <span class="comment"> * the data given in the \ref ss_m::create_rec call. </span>
<a name="l00788"></a>00788 <span class="comment"> *</span>
<a name="l00789"></a>00789 <span class="comment"> * Three policies used can be used (in combination) to search for pages</span>
<a name="l00790"></a>00790 <span class="comment"> * with space in which to create a new record:</span>
<a name="l00791"></a>00791 <span class="comment"> * - t_cache : look in the \b heap for a page with space. </span>
<a name="l00792"></a>00792 <span class="comment"> * - t_compact : if the \b histograms say </span>
<a name="l00793"></a>00793 <span class="comment"> *   there are any pages with  sufficient space somewhere in the file, </span>
<a name="l00794"></a>00794 <span class="comment"> *   do a linear search of the file for such a page, updating histogram</span>
<a name="l00795"></a>00795 <span class="comment"> *   heap metadata in the process.  This is potentially</span>
<a name="l00796"></a>00796 <span class="comment"> *   costly but useful when the file has not been inspected since the</span>
<a name="l00797"></a>00797 <span class="comment"> *   last restart, because the heap has no records for the file except</span>
<a name="l00798"></a>00798 <span class="comment"> *   those inserted due to a record-update or removal.</span>
<a name="l00799"></a>00799 <span class="comment"> * - t_append : append the new record to the file</span>
<a name="l00800"></a>00800 <span class="comment"> *</span>
<a name="l00801"></a>00801 <span class="comment"> * Using append_file_t to create records means only t_append is used, </span>
<a name="l00802"></a>00802 <span class="comment"> * ensuring that the record will always be appended to the file.</span>
<a name="l00803"></a>00803 <span class="comment"> * \ref ss_m::create_rec uses t_cache | t_compact | t_append.</span>
<a name="l00804"></a>00804 <span class="comment"> *</span>
<a name="l00805"></a>00805 <span class="comment"> * The policy can be given on the \ref ss_m::create_rec call. The default</span>
<a name="l00806"></a>00806 <span class="comment"> * is t_cache | t_compact | t_append.</span>
<a name="l00807"></a>00807 <span class="comment"> *</span>
<a name="l00808"></a>00808 <span class="comment"> * If the file manager does not find a page in the file with sufficient</span>
<a name="l00809"></a>00809 <span class="comment"> * space for the record, or if it must append to the end of the file</span>
<a name="l00810"></a>00810 <span class="comment"> * and the last page hasn't the needed space, the file manager asks</span>
<a name="l00811"></a>00811 <span class="comment"> * the I/O manager to allocate a page.</span>
<a name="l00812"></a>00812 <span class="comment"> *</span>
<a name="l00813"></a>00813 <span class="comment"> * Once the file manager has located a page with sufficient space to</span>
<a name="l00814"></a>00814 <span class="comment"> * create the record, the \ref VOL_M worries about </span>
<a name="l00815"></a>00815 <span class="comment"> * \ref RSVD_MODE.</span>
<a name="l00816"></a>00816 <span class="comment"> *</span>
<a name="l00817"></a>00817 <span class="comment"> * Creating a record comprises these steps:</span>
<a name="l00818"></a>00818 <span class="comment"> * - Estimate the space required for the record, based on the sizes of </span>
<a name="l00819"></a>00819 <span class="comment"> *   the data and header vectors and the length-hint given </span>
<a name="l00820"></a>00820 <span class="comment"> *   on the ss_m::create_rec call.</span>
<a name="l00821"></a>00821 <span class="comment"> * - Choose a record implementation for the given size (</span>
<a name="l00822"></a>00822 <span class="comment"> *   a small object or a large object, which determines the amount </span>
<a name="l00823"></a>00823 <span class="comment"> *   of space needed in the slot of the file_p page)</span>
<a name="l00824"></a>00824 <span class="comment"> * - Find and lock a slot in a page:</span>
<a name="l00825"></a>00825 <span class="comment"> *   - if appending to the file, find and EX-lock (with long-duration) the next </span>
<a name="l00826"></a>00826 <span class="comment"> *   available slot in the last page of the file.</span>
<a name="l00827"></a>00827 <span class="comment"> *   Finding the last page in the file requires SH-latching extent-map </span>
<a name="l00828"></a>00828 <span class="comment"> *   pages </span>
<a name="l00829"></a>00829 <span class="comment"> *   \ref ATSIGN "\@";</span>
<a name="l00830"></a>00830 <span class="comment"> *   the storage manager caches last-page information to reduce</span>
<a name="l00831"></a>00831 <span class="comment"> *   page-fixing to find the last page of a store.</span>
<a name="l00832"></a>00832 <span class="comment"> *   Searches for the last page of a store start with the cached</span>
<a name="l00833"></a>00833 <span class="comment"> *   last-page's extent if it is still part of the store; otherwise they</span>
<a name="l00834"></a>00834 <span class="comment"> *   start with the head of the store's list, and update the cache.</span>
<a name="l00835"></a>00835 <span class="comment"> *   - If there is no such slot or if it is not large enough, </span>
<a name="l00836"></a>00836 <span class="comment"> *   allocate a new page (at the end of the file).</span>
<a name="l00837"></a>00837 <span class="comment"> *   - if not appending to the file, consult the histograms to find a </span>
<a name="l00838"></a>00838 <span class="comment"> *   page already in the file, </span>
<a name="l00839"></a>00839 <span class="comment"> *   one that contains a slot large enough for the new record.</span>
<a name="l00840"></a>00840 <span class="comment"> * - Once we have located a (potentially) suitable page, </span>
<a name="l00841"></a>00841 <span class="comment"> *   verify that the page is indeed legitimate (since we used</span>
<a name="l00842"></a>00842 <span class="comment"> *   transient, cached information to locate this page).</span>
<a name="l00843"></a>00843 <span class="comment"> *   If not, reject  the page.</span>
<a name="l00844"></a>00844 <span class="comment"> *   Note that normally we cover latches with locks to avoid</span>
<a name="l00845"></a>00845 <span class="comment"> *   deadlocks, but in this case we must latch first because</span>
<a name="l00846"></a>00846 <span class="comment"> *   we have no idea which slot to lock, nor do we know</span>
<a name="l00847"></a>00847 <span class="comment"> *   if the page is still in the expected file.</span>
<a name="l00848"></a>00848 <span class="comment"> *   We may have to try several pages before finding one </span>
<a name="l00849"></a>00849 <span class="comment"> *   that is truly suitable, so this entire protocol </span>
<a name="l00850"></a>00850 <span class="comment"> *   is handled in the histogram code. The protocol is as follows:</span>
<a name="l00851"></a>00851 <span class="comment"> *   - Conditionally EX-latch </span>
<a name="l00852"></a>00852 <span class="comment"> *   \ref ATSIGN "\@"</span>
<a name="l00853"></a>00853 <span class="comment"> *   the page. </span>
<a name="l00854"></a>00854 <span class="comment"> *   If we cannot do so, give up on  this page and try another;</span>
<a name="l00855"></a>00855 <span class="comment"> *   - Once the page is fixed, verify that its </span>
<a name="l00856"></a>00856 <span class="comment"> *   page ID contains the expected store ID (to detect a race) </span>
<a name="l00857"></a>00857 <span class="comment"> *   (if not, reject this page and find another);</span>
<a name="l00858"></a>00858 <span class="comment"> *   - Check the allocation status of the page:</span>
<a name="l00859"></a>00859 <span class="comment"> *     - try to IS-lock the page, and if we </span>
<a name="l00860"></a>00860 <span class="comment"> *     cannot do so immediately, we reject the page and try another;</span>
<a name="l00861"></a>00861 <span class="comment"> *     - verify that the page is allocated in its extent, and that </span>
<a name="l00862"></a>00862 <span class="comment"> *     the extent's owner is the expected store. This involves </span>
<a name="l00863"></a>00863 <span class="comment"> *     SH-latching </span>
<a name="l00864"></a>00864 <span class="comment"> *      \ref ATSIGN "\@"</span>
<a name="l00865"></a>00865 <span class="comment"> *     the extent map page while holding the file page latched;</span>
<a name="l00866"></a>00866 <span class="comment"> *   - Acquire an EX lock on the next available slot with enough </span>
<a name="l00867"></a>00867 <span class="comment"> *   space (space that is usable by this transaction,</span>
<a name="l00868"></a>00868 <span class="comment"> *   subject to \ref RSVD_MODE);</span>
<a name="l00869"></a>00869 <span class="comment"> * - Once we have a suitable page with an EX record lock,  </span>
<a name="l00870"></a>00870 <span class="comment"> *   create the record.</span>
<a name="l00871"></a>00871 <span class="comment"> * </span>
<a name="l00872"></a>00872 <span class="comment"> * Under the best of circumstances, creating a small record involves three page</span>
<a name="l00873"></a>00873 <span class="comment"> * latches </span>
<a name="l00874"></a>00874 <span class="comment"> *   \ref ATSIGN "\@":</span>
<a name="l00875"></a>00875 <span class="comment"> * one file page (in which to insert a record),</span>
<a name="l00876"></a>00876 <span class="comment"> * the extent map page is fixed to verify the file page's allocation status,</span>
<a name="l00877"></a>00877 <span class="comment"> * and then after the record is created, the </span>
<a name="l00878"></a>00878 <span class="comment"> * the extent map page is re-latched to update the space-utilization metadata</span>
<a name="l00879"></a>00879 <span class="comment"> * for the extent.</span>
<a name="l00880"></a>00880 <span class="comment"> *</span>
<a name="l00881"></a>00881 <span class="comment"> * Updating a record (by way of a server-provided record ID) consists </span>
<a name="l00882"></a>00882 <span class="comment"> * in these steps, which may require up to two extra page latches (besides</span>
<a name="l00883"></a>00883 <span class="comment"> * latching the page containing the record):</span>
<a name="l00884"></a>00884 <span class="comment"> * - Latch the page on which the record resides </span>
<a name="l00885"></a>00885 <span class="comment"> *   \ref ATSIGN "\@";</span>
<a name="l00886"></a>00886 <span class="comment"> * - Verify the legitimacy of the record ID (see \ref UPDATEREC);</span>
<a name="l00887"></a>00887 <span class="comment"> * - Verify that the file page still contains the record identified by the </span>
<a name="l00888"></a>00888 <span class="comment"> *   record ID;</span>
<a name="l00889"></a>00889 <span class="comment"> * - Perform the update.</span>
<a name="l00890"></a>00890 <span class="comment"> *</span>
<a name="l00891"></a>00891 <span class="comment"> * Freeing a record comprises these steps:</span>
<a name="l00892"></a>00892 <span class="comment"> * - EX-lock the record (with long duration);</span>
<a name="l00893"></a>00893 <span class="comment"> * - From the record ID, determine its containing page;</span>
<a name="l00894"></a>00894 <span class="comment"> * - EX-latch the page </span>
<a name="l00895"></a>00895 <span class="comment"> *   \ref ATSIGN "\@";</span>
<a name="l00896"></a>00896 <span class="comment"> * - Mark the slot free, releasing the space but </span>
<a name="l00897"></a>00897 <span class="comment"> *   leaving it reserved (see \ref RSVD_MODE);</span>
<a name="l00898"></a>00898 <span class="comment"> * - If the slot is the last used slot on the page, and the page is not the</span>
<a name="l00899"></a>00899 <span class="comment"> *   first allocated page in the file, </span>
<a name="l00900"></a>00900 <span class="comment"> *   free the page (finding the first page in the</span>
<a name="l00901"></a>00901 <span class="comment"> *   file requires  SH-latching </span>
<a name="l00902"></a>00902 <span class="comment"> *   a store-map page </span>
<a name="l00903"></a>00903 <span class="comment"> *   \ref ATSIGN "\@"</span>
<a name="l00904"></a>00904 <span class="comment"> *   and at least one extent-map page</span>
<a name="l00905"></a>00905 <span class="comment"> *   \ref ATSIGN "\@");</span>
<a name="l00906"></a>00906 <span class="comment"> * - Update the histograms to reflect the space on the page and whether the</span>
<a name="l00907"></a>00907 <span class="comment"> *   page is still in the file.  This may change the page's bucket and</span>
<a name="l00908"></a>00908 <span class="comment"> *   require EX-latching </span>
<a name="l00909"></a>00909 <span class="comment"> *   \ref ATSIGN "\@"</span>
<a name="l00910"></a>00910 <span class="comment"> *   the extent-map page to update the pspacemap.</span>
<a name="l00911"></a>00911 <span class="comment"> *</span>
<a name="l00912"></a>00912 <span class="comment"> *</span>
<a name="l00913"></a>00913 <span class="comment"> * \subsection UPDATEREC  Record Access by Record ID</span>
<a name="l00914"></a>00914 <span class="comment"> *</span>
<a name="l00915"></a>00915 <span class="comment"> * When a server issues a storage manager request to</span>
<a name="l00916"></a>00916 <span class="comment"> * read or update a record (using any ss_m::update_rec or pin_i::pin</span>
<a name="l00917"></a>00917 <span class="comment"> * or pin_i::repin, that is, any method that</span>
<a name="l00918"></a>00918 <span class="comment"> * takes a record identifier), the storage manager must verify</span>
<a name="l00919"></a>00919 <span class="comment"> * the legitimacy of the record identifier.  (If the storage</span>
<a name="l00920"></a>00920 <span class="comment"> * manager performs an update based on a record ID that is stale,</span>
<a name="l00921"></a>00921 <span class="comment"> * it can result in unrecoverable errors. )</span>
<a name="l00922"></a>00922 <span class="comment"> * Verifying the legitimacy of a record ID is, unfortunately,</span>
<a name="l00923"></a>00923 <span class="comment"> * an expensive operation:</span>
<a name="l00924"></a>00924 <span class="comment"> * - Verify that store id on the page matches that in the record ID;</span>
<a name="l00925"></a>00925 <span class="comment"> * - Verify that page is a file page;</span>
<a name="l00926"></a>00926 <span class="comment"> * - Verify that the store exists (inspect the stnode_t for the store</span>
<a name="l00927"></a>00927 <span class="comment"> *   \ref ATSIGN "\@"</span>
<a name="l00928"></a>00928 <span class="comment"> *   )</span>
<a name="l00929"></a>00929 <span class="comment"> * - Verify that the page is allocated to the store (fix the extlink_t</span>
<a name="l00930"></a>00930 <span class="comment"> *   \ref ATSIGN "\@"</span>
<a name="l00931"></a>00931 <span class="comment"> *   and verify that its owner is still the store in question and that</span>
<a name="l00932"></a>00932 <span class="comment"> *   the page's bit is set in the extent's page map).</span>
<a name="l00933"></a>00933 <span class="comment"> *</span>
<a name="l00934"></a>00934 <span class="comment"> * The storage manager does not inspect the store's metatdata (directory</span>
<a name="l00935"></a>00935 <span class="comment"> * index entry) to </span>
<a name="l00936"></a>00936 <span class="comment"> * see that it is a file store because if the page is still allocated</span>
<a name="l00937"></a>00937 <span class="comment"> * to the store and the page is a file page, the store must still be a file</span>
<a name="l00938"></a>00938 <span class="comment"> * store.</span>
<a name="l00939"></a>00939 <span class="comment"> *</span>
<a name="l00940"></a>00940 <span class="comment"> * \subsection FREESPACE Summary of Free-Space Management</span>
<a name="l00941"></a>00941 <span class="comment"> *</span>
<a name="l00942"></a>00942 <span class="comment"> * Free space is managed in several ways:</span>
<a name="l00943"></a>00943 <span class="comment"> * - Free extents have no owner (persistent datum in the extlink_t).</span>
<a name="l00944"></a>00944 <span class="comment"> * - Allocated extents with free pages are cached by the </span>
<a name="l00945"></a>00945 <span class="comment"> *   volume manager (transient data).</span>
<a name="l00946"></a>00946 <span class="comment"> * - Allocated extents contain a map of the free-space buckets to which its</span>
<a name="l00947"></a>00947 <span class="comment"> *   pages belong for file pages (persistent, in the extlink_t).</span>
<a name="l00948"></a>00948 <span class="comment"> * - The volume manager keeps caches the last page in a file (transient).</span>
<a name="l00949"></a>00949 <span class="comment"> * - The volume manager keeps a cache of extents in a store that</span>
<a name="l00950"></a>00950 <span class="comment"> *   contain reserved pages (transient).</span>
<a name="l00951"></a>00951 <span class="comment"> * - The volume manager caches the lowest unallocated extent in a volume (transient).</span>
<a name="l00952"></a>00952 <span class="comment"> * - The file manager maintains a heap and histograms (transient) that</span>
<a name="l00953"></a>00953 <span class="comment"> *   cache the free-space bucket data on the pages. </span>
<a name="l00954"></a>00954 <span class="comment"> *</span>
<a name="l00955"></a>00955 <span class="comment"> * \section BTREE_M B+-Tree Manager</span>
<a name="l00956"></a>00956 <span class="comment"> *</span>
<a name="l00957"></a>00957 <span class="comment"> * The values associated with the keys are opaque to the storage</span>
<a name="l00958"></a>00958 <span class="comment"> * manager, except when IM (Index Management locking protocol) is used, </span>
<a name="l00959"></a>00959 <span class="comment"> * in which case the value is</span>
<a name="l00960"></a>00960 <span class="comment"> * treated as a record ID, but no integrity checks are done.  </span>
<a name="l00961"></a>00961 <span class="comment"> * It is the responsibility of the server to see that the value is</span>
<a name="l00962"></a>00962 <span class="comment"> * legitimate in this case.</span>
<a name="l00963"></a>00963 <span class="comment"> *</span>
<a name="l00964"></a>00964 <span class="comment"> * B-trees can be bulk-loaded from files of sorted key-value pairs,</span>
<a name="l00965"></a>00965 <span class="comment"> * as long as the keys are in \ref LEXICOFORMAT "lexicographic form". </span>
<a name="l00966"></a>00966 <span class="comment"> * \bug GNATS 116 Btree doesn't sort elements for duplicate keys in bulk-load. </span>
<a name="l00967"></a>00967 <span class="comment"> * This is a problem inherited from the original SHORE storage manager.</span>
<a name="l00968"></a>00968 <span class="comment"> *</span>
<a name="l00969"></a>00969 <span class="comment"> * The implementation of B-trees is straight from the Mohan ARIES/IM</span>
<a name="l00970"></a>00970 <span class="comment"> * and ARIES/KVL papers. See \ref MOH1, which covers both topics.</span>
<a name="l00971"></a>00971 <span class="comment"> *</span>
<a name="l00972"></a>00972 <span class="comment"> * Those two papers give a thorough explanation of the arcane algorithms,</span>
<a name="l00973"></a>00973 <span class="comment"> * including logging considerations.  </span>
<a name="l00974"></a>00974 <span class="comment"> * Anyone considering changing the B-tree code is strongly encouraged </span>
<a name="l00975"></a>00975 <span class="comment"> * to read these papers carefully.  </span>
<a name="l00976"></a>00976 <span class="comment"> * Some of the performance tricks described in these papers are </span>
<a name="l00977"></a>00977 <span class="comment"> * not implemented here.  </span>
<a name="l00978"></a>00978 <span class="comment"> * For example, the ARIES/IM paper describes performance of logical </span>
<a name="l00979"></a>00979 <span class="comment"> * undo of insert operations if and only if physical undo </span>
<a name="l00980"></a>00980 <span class="comment"> * is not possible.  </span>
<a name="l00981"></a>00981 <span class="comment"> * The storage manager always undoes inserts logically.</span>
<a name="l00982"></a>00982 <span class="comment"> *</span>
<a name="l00983"></a>00983 <span class="comment"> * \bug GNATS 137 Latches can now be downgraded; btree code should use this.</span>
<a name="l00984"></a>00984 <span class="comment"> *</span>
<a name="l00985"></a>00985 <span class="comment"> * \section RTREE_M R*-Tree Manager</span>
<a name="l00986"></a>00986 <span class="comment"> *</span>
<a name="l00987"></a>00987 <span class="comment"> * The spatial indexes in the storage manager are R*-trees, a variant</span>
<a name="l00988"></a>00988 <span class="comment"> * of R-trees that perform frequent restructuring to yield higher</span>
<a name="l00989"></a>00989 <span class="comment"> * performance than normal R-trees.  The entire index is locked.</span>
<a name="l00990"></a>00990 <span class="comment"> * See \ref BKSS.</span>
<a name="l00991"></a>00991 <span class="comment"> *</span>
<a name="l00992"></a>00992 <span class="comment"> * \section DIR_M Directory Manager</span>
<a name="l00993"></a>00993 <span class="comment"> * All storage structures created by a server</span>
<a name="l00994"></a>00994 <span class="comment"> * have entries in a B+-Tree index called the </span>
<a name="l00995"></a>00995 <span class="comment"> * \e store \e directory or just \e directory.</span>
<a name="l00996"></a>00996 <span class="comment"> * This index is not exposed to the server.</span>
<a name="l00997"></a>00997 <span class="comment"> *</span>
<a name="l00998"></a>00998 <span class="comment"> * The storage manager maintains  some transient and some persistent data</span>
<a name="l00999"></a>00999 <span class="comment"> * for each store.  The directory's key is the store ID, and the value it</span>
<a name="l01000"></a>01000 <span class="comment"> * returns from a lookup is a</span>
<a name="l01001"></a>01001 <span class="comment"> * sdesc_t ("store descriptor") structure, which</span>
<a name="l01002"></a>01002 <span class="comment"> * contains both the persistent and transient information. </span>
<a name="l01003"></a>01003 <span class="comment"> *</span>
<a name="l01004"></a>01004 <span class="comment"> * The persistent information is in a sinfo_s structure; the </span>
<a name="l01005"></a>01005 <span class="comment"> * transient information is resident only in the cache of sdesc_t </span>
<a name="l01006"></a>01006 <span class="comment"> * structures that the directory manager</span>
<a name="l01007"></a>01007 <span class="comment"> * maintains.</span>
<a name="l01008"></a>01008 <span class="comment"> *</span>
<a name="l01009"></a>01009 <span class="comment"> * The metadata include:</span>
<a name="l01010"></a>01010 <span class="comment"> * - what kind of storage structure uses this store  (btree, rtree, file)</span>
<a name="l01011"></a>01011 <span class="comment"> * - if a B-tree, is it unique and what kind of locking protocol does it use?</span>
<a name="l01012"></a>01012 <span class="comment"> * - what stores compose this storage structure (e.g., if file, what is the</span>
<a name="l01013"></a>01013 <span class="comment"> *   large-object store and what is the small-record store?)</span>
<a name="l01014"></a>01014 <span class="comment"> * - what is the root page of the structure (if an index)</span>
<a name="l01015"></a>01015 <span class="comment"> * - what is the key type if this is an index</span>
<a name="l01016"></a>01016 <span class="comment"> *</span>
<a name="l01017"></a>01017 <span class="comment"> * \section LOCK_M Lock Manager</span>
<a name="l01018"></a>01018 <span class="comment"> *</span>
<a name="l01019"></a>01019 <span class="comment"> * The lock manager understands the folling kind of locks</span>
<a name="l01020"></a>01020 <span class="comment"> * - volume</span>
<a name="l01021"></a>01021 <span class="comment"> * - extent</span>
<a name="l01022"></a>01022 <span class="comment"> * - store</span>
<a name="l01023"></a>01023 <span class="comment"> * - page</span>
<a name="l01024"></a>01024 <span class="comment"> * - kvl</span>
<a name="l01025"></a>01025 <span class="comment"> * - record</span>
<a name="l01026"></a>01026 <span class="comment"> * - user1</span>
<a name="l01027"></a>01027 <span class="comment"> * - user2</span>
<a name="l01028"></a>01028 <span class="comment"> * - user3</span>
<a name="l01029"></a>01029 <span class="comment"> * - user4</span>
<a name="l01030"></a>01030 <span class="comment"> *</span>
<a name="l01031"></a>01031 <span class="comment"> * Lock requests are issued with a lock ID (lockid_t), which</span>
<a name="l01032"></a>01032 <span class="comment"> * encodes the identity of the entity being locked, the kind of</span>
<a name="l01033"></a>01033 <span class="comment"> * lock, and, by inference,  a lock hierarchy for a subset of the</span>
<a name="l01034"></a>01034 <span class="comment"> * kinds of locks above.</span>
<a name="l01035"></a>01035 <span class="comment"> * The lock manager does not insist that lock identifiers </span>
<a name="l01036"></a>01036 <span class="comment"> * refer to any existing object.  </span>
<a name="l01037"></a>01037 <span class="comment"> *</span>
<a name="l01038"></a>01038 <span class="comment"> * The lock manager enforces two lock hierarchies:</span>
<a name="l01039"></a>01039 <span class="comment"> * - Volume - store - page - record</span>
<a name="l01040"></a>01040 <span class="comment"> * - Volume - store - key-value</span>
<a name="l01041"></a>01041 <span class="comment"> *</span>
<a name="l01042"></a>01042 <span class="comment"> * Note that the following lock kinds are not in any hierarchy:</span>
<a name="l01043"></a>01043 <span class="comment"> * -extent</span>
<a name="l01044"></a>01044 <span class="comment"> * -user1, user2, user3, user4</span>
<a name="l01045"></a>01045 <span class="comment"> *</span>
<a name="l01046"></a>01046 <span class="comment"> * Other than the way the lock identifiers are inspected for the purpose </span>
<a name="l01047"></a>01047 <span class="comment"> * of enforcing the hierarchy, lock identifiers are considered opaque </span>
<a name="l01048"></a>01048 <span class="comment"> * data by the lock manager.  </span>
<a name="l01049"></a>01049 <span class="comment"> *</span>
<a name="l01050"></a>01050 <span class="comment"> * The lockid_t structure can be constructed from the IDs of the</span>
<a name="l01051"></a>01051 <span class="comment"> * various entities in (and out of ) the hierarchy; see lockid_t and</span>
<a name="l01052"></a>01052 <span class="comment"> * the example lockid_test.cpp.</span>
<a name="l01053"></a>01053 <span class="comment"> *</span>
<a name="l01054"></a>01054 <span class="comment"> * \subsection LOCK_M_IMPLICIT Implicit locks</span>
<a name="l01055"></a>01055 <span class="comment"> * The hierarchy is used for implicit acquisition of locks as follows:</span>
<a name="l01056"></a>01056 <span class="comment"> * - for each parent lock in the hierarchy, determine its lock mode </span>
<a name="l01057"></a>01057 <span class="comment"> *   based on the mode of the child:</span>
<a name="l01058"></a>01058 <span class="comment"> *   - parent_mode[child IS or SH] =  IS</span>
<a name="l01059"></a>01059 <span class="comment"> *   - parent_mode[child IX or SIX or UD or EX] =  IX</span>
<a name="l01060"></a>01060 <span class="comment"> *   - parent_mode[child none] =  none</span>
<a name="l01061"></a>01061 <span class="comment"> * - for each parent lock in the hierarchy that is not already held in</span>
<a name="l01062"></a>01062 <span class="comment"> *   sufficient mode, acquire the parent lock in the mode determined above</span>
<a name="l01063"></a>01063 <span class="comment"> *</span>
<a name="l01064"></a>01064 <span class="comment"> * \subsection LOCK_M_ESC Escalation</span>
<a name="l01065"></a>01065 <span class="comment"> * The lock manager escalates up the hierarchy by default.  </span>
<a name="l01066"></a>01066 <span class="comment"> * The escalation thresholds are based on run-time options.  </span>
<a name="l01067"></a>01067 <span class="comment"> * They can be controlled (set, disabled) on a per-object level.  </span>
<a name="l01068"></a>01068 <span class="comment"> * For example, escalation to the store level can be disabled when </span>
<a name="l01069"></a>01069 <span class="comment"> * increased concurrency is desired.  </span>
<a name="l01070"></a>01070 <span class="comment"> * Escalation can also be controlled on a per-transaction or per-server basis.</span>
<a name="l01071"></a>01071 <span class="comment"> *</span>
<a name="l01072"></a>01072 <span class="comment"> * \subsection LOCK_M_SM Lock Acquisition and Release by Storage Manager</span>
<a name="l01073"></a>01073 <span class="comment"> * Locks are acquired by storage manager operations as appropriate to the</span>
<a name="l01074"></a>01074 <span class="comment"> * use of the data (read/write). (Update locks are not acquired by the</span>
<a name="l01075"></a>01075 <span class="comment"> * storage manager.)</span>
<a name="l01076"></a>01076 <span class="comment"> *</span>
<a name="l01077"></a>01077 <span class="comment"> * The storage manager's API allows explicit acquisition </span>
<a name="l01078"></a>01078 <span class="comment"> * of locks by a server.    User modes user1, user2, user3 and user4 are provided for that purpose.</span>
<a name="l01079"></a>01079 <span class="comment"> *</span>
<a name="l01080"></a>01080 <span class="comment"> * Freeing locks is automatic at transaction commit and rollback.  </span>
<a name="l01081"></a>01081 <span class="comment"> *</span>
<a name="l01082"></a>01082 <span class="comment"> * There is limited support for freeing locks in the middle of </span>
<a name="l01083"></a>01083 <span class="comment"> * a transaction:</span>
<a name="l01084"></a>01084 <span class="comment"> * - locks of duration less than t_long can be unlocked with unlock(), and</span>
<a name="l01085"></a>01085 <span class="comment"> * - quarks (sm_quark_t) simplify acquiring and freeing locks mid-transaction:</span>
<a name="l01086"></a>01086 <span class="comment"> *</span>
<a name="l01087"></a>01087 <span class="comment"> * \subsubsection QUARK Quarks</span>
<a name="l01088"></a>01088 <span class="comment"> * A quark is a marker in the list of locks held by a transaction.  </span>
<a name="l01089"></a>01089 <span class="comment"> * When the quark is destroyed, all locks acquired since the </span>
<a name="l01090"></a>01090 <span class="comment"> * creation of the quark are freed.  Quarks cannot be used while more than</span>
<a name="l01091"></a>01091 <span class="comment"> * one thread is attached to the transaction, although the storage </span>
<a name="l01092"></a>01092 <span class="comment"> * manager does not strictly enforce this (due to the cost).</span>
<a name="l01093"></a>01093 <span class="comment"> * When a quark is in use for a transaction, the locks acquired</span>
<a name="l01094"></a>01094 <span class="comment"> * will be of short duration, the assumption being that the quark</span>
<a name="l01095"></a>01095 <span class="comment"> * will be closed before commit-time.  </span>
<a name="l01096"></a>01096 <span class="comment"> *</span>
<a name="l01097"></a>01097 <span class="comment"> * Extent locks are an exception; they must be held long-term for</span>
<a name="l01098"></a>01098 <span class="comment"> * page allocation and deallocation to work, so even in the context</span>
<a name="l01099"></a>01099 <span class="comment"> * of an open quark, extent locks will be held until end-of-transaction.</span>
<a name="l01100"></a>01100 <span class="comment"> *</span>
<a name="l01101"></a>01101 <span class="comment"> * The lock manager uses a hash table whose size is determined by</span>
<a name="l01102"></a>01102 <span class="comment"> * a configuration option.  </span>
<a name="l01103"></a>01103 <span class="comment"> * The hash function used by the lock manager is known not </span>
<a name="l01104"></a>01104 <span class="comment"> * to distribute locks evenly among buckets.</span>
<a name="l01105"></a>01105 <span class="comment"> * This is partly due to the nature of lock IDs.</span>
<a name="l01106"></a>01106 <span class="comment"> *</span>
<a name="l01107"></a>01107 <span class="comment"> * \subsection LCACHE Lock Cache</span>
<a name="l01108"></a>01108 <span class="comment"> * To avoid expensive lock manager queries, each transaction </span>
<a name="l01109"></a>01109 <span class="comment"> * keeps a cache of the last &lt;N&gt; locks acquired (the number</span>
<a name="l01110"></a>01110 <span class="comment"> * &lt;N&gt; is a compile-time constant).</span>
<a name="l01111"></a>01111 <span class="comment"> * This close association between the transaction manager and</span>
<a name="l01112"></a>01112 <span class="comment"> * the lock manager is encapsulated in several classes in the file lock_x.</span>
<a name="l01113"></a>01113 <span class="comment"> *</span>
<a name="l01114"></a>01114 <span class="comment"> * \subsection DLD Deadlock Detection</span>
<a name="l01115"></a>01115 <span class="comment"> * The lock manager uses a statistical deadlock-detection scheme</span>
<a name="l01116"></a>01116 <span class="comment"> * known as "Dreadlocks" [KH1].</span>
<a name="l01117"></a>01117 <span class="comment"> * Each storage manager thread (smthread_t) has a unique fingerprint, which is</span>
<a name="l01118"></a>01118 <span class="comment"> * a set of bits; the deadlock detector ORs together the bits of the</span>
<a name="l01119"></a>01119 <span class="comment"> * elements in a waits-for-dependency-list; each thread, when </span>
<a name="l01120"></a>01120 <span class="comment"> * blocking, holds a  digest (the ORed bitmap).  </span>
<a name="l01121"></a>01121 <span class="comment"> * It is therefore cheap for a thread to detect a cycle when it needs to </span>
<a name="l01122"></a>01122 <span class="comment"> * block awaiting a lock: look at the holders</span>
<a name="l01123"></a>01123 <span class="comment"> * of the lock and if it finds itself in any of their digests, a</span>
<a name="l01124"></a>01124 <span class="comment"> * cycle will result.</span>
<a name="l01125"></a>01125 <span class="comment"> * This works well when the total number of threads relative to the bitmap</span>
<a name="l01126"></a>01126 <span class="comment"> * size is such that it is possible to assign a unique bitmap to each</span>
<a name="l01127"></a>01127 <span class="comment"> * thread.   </span>
<a name="l01128"></a>01128 <span class="comment"> * If you cannot do so, you will have false-positive deadlocks</span>
<a name="l01129"></a>01129 <span class="comment"> * "detected".</span>
<a name="l01130"></a>01130 <span class="comment"> * The storage manager counts, in its statistics, the number of times</span>
<a name="l01131"></a>01131 <span class="comment"> * it could not assign a unique fingerprint to a thread.  </span>
<a name="l01132"></a>01132 <span class="comment"> * If you notice excessive transaction-aborts due to false-positive</span>
<a name="l01133"></a>01133 <span class="comment"> * deadlocks,</span>
<a name="l01134"></a>01134 <span class="comment"> * you can compile the storage manager to use a larger</span>
<a name="l01135"></a>01135 <span class="comment"> * number bits in the </span>
<a name="l01136"></a>01136 <span class="comment"> * \code sm_thread_map_t \endcode</span>
<a name="l01137"></a>01137 <span class="comment"> * found in </span>
<a name="l01138"></a>01138 <span class="comment"> * \code smthread.h \endcode.</span>
<a name="l01139"></a>01139 <span class="comment"> *</span>
<a name="l01140"></a>01140 <span class="comment"> * \section XCT_M Transaction Manager</span>
<a name="l01141"></a>01141 <span class="comment"> * When a transaction commits, these steps are taken to</span>
<a name="l01142"></a>01142 <span class="comment"> * manage stores:</span>
<a name="l01143"></a>01143 <span class="comment"> * - Stores that were given sm_store_property_t t_load_file or </span>
<a name="l01144"></a>01144 <span class="comment"> *   t_insert_file are turned * into t_regular stores;</span>
<a name="l01145"></a>01145 <span class="comment"> * - The transaction enters a state called "freeing space" so that</span>
<a name="l01146"></a>01146 <span class="comment"> *   stores marked for deletion can be handled properly in event of</span>
<a name="l01147"></a>01147 <span class="comment"> *   a crash/restart before the transaction logs it commit-completion;</span>
<a name="l01148"></a>01148 <span class="comment"> * - Stores marked for deletion are removed (see \ref SAFTERXCT);</span>
<a name="l01149"></a>01149 <span class="comment"> * - Extents marked for freeing are freed. These are extents marked for</span>
<a name="l01150"></a>01150 <span class="comment"> *   freeing in stores that were not marked for deletion; rather,</span>
<a name="l01151"></a>01151 <span class="comment"> *   these are extents that are marked for deletion due to </span>
<a name="l01152"></a>01152 <span class="comment"> *   incremental freeing of their pages.</span>
<a name="l01153"></a>01153 <span class="comment"> *</span>
<a name="l01154"></a>01154 <span class="comment"> * Because these are logged actions, and they occur if and only if the </span>
<a name="l01155"></a>01155 <span class="comment"> * transaction commits, the storage manager guarantees that the ending</span>
<a name="l01156"></a>01156 <span class="comment"> * of the transaction and re-marking and deletion of stores is atomic.</span>
<a name="l01157"></a>01157 <span class="comment"> * This is accomplished by putting the transaction into a state</span>
<a name="l01158"></a>01158 <span class="comment"> * xct_freeing_space, and writing a log record to that effect.</span>
<a name="l01159"></a>01159 <span class="comment"> * The space is freed, the stores are converted, and a final log record is written before the transaction is truly ended.</span>
<a name="l01160"></a>01160 <span class="comment"> * In the event of a crash while a transaction is freeing space, </span>
<a name="l01161"></a>01161 <span class="comment"> * recovery searches all the </span>
<a name="l01162"></a>01162 <span class="comment"> * store metadata for stores marked for deletion</span>
<a name="l01163"></a>01163 <span class="comment"> * and deletes those that would otherwise have been missed in redo.</span>
<a name="l01164"></a>01164 <span class="comment"> *</span>
<a name="l01165"></a>01165 <span class="comment"> * \section LOG_M Log Manager</span>
<a name="l01166"></a>01166 <span class="comment"> *</span>
<a name="l01167"></a>01167 <span class="comment"> * \subsection LOG_M_USAGE How the Server Uses the Log Manager</span>
<a name="l01168"></a>01168 <span class="comment"> *</span>
<a name="l01169"></a>01169 <span class="comment"> * Log records for redoable-undoable operations contain both the </span>
<a name="l01170"></a>01170 <span class="comment"> * redo- and undo- data, hence an operation never causes two </span>
<a name="l01171"></a>01171 <span class="comment"> * different log records to be written for redo and for undo.  </span>
<a name="l01172"></a>01172 <span class="comment"> * This, too, controls logging overhead.  </span>
<a name="l01173"></a>01173 <span class="comment"> *</span>
<a name="l01174"></a>01174 <span class="comment"> * The protocol for applying an operation to an object is as follows:</span>
<a name="l01175"></a>01175 <span class="comment"> * - Lock the object.</span>
<a name="l01176"></a>01176 <span class="comment"> * - Fix the page(s) affected in exclusive mode.</span>
<a name="l01177"></a>01177 <span class="comment"> * - Apply the operation.</span>
<a name="l01178"></a>01178 <span class="comment"> * - Write the log record(s) for the operation.</span>
<a name="l01179"></a>01179 <span class="comment"> * - Unfix the page(s).</span>
<a name="l01180"></a>01180 <span class="comment"> *</span>
<a name="l01181"></a>01181 <span class="comment"> * The protocol for writing log records is as follows:</span>
<a name="l01182"></a>01182 <span class="comment"> * - Grab the transaction's log buffer in which the last log record is to be </span>
<a name="l01183"></a>01183 <span class="comment"> *   cached by calling xct_t::get_logbuf()</span>
<a name="l01184"></a>01184 <span class="comment"> *   - Ensure that we have reserved enough log space for this transaction </span>
<a name="l01185"></a>01185 <span class="comment"> *   to insert the desired log record an to undo it. This is done by</span>
<a name="l01186"></a>01186 <span class="comment"> *   by passing in </span>
<a name="l01187"></a>01187 <span class="comment"> *   the type of the log record we are about to insert, and by using a</span>
<a name="l01188"></a>01188 <span class="comment"> *   "fudge factor" (multiplier) associated with the given log record type.</span>
<a name="l01189"></a>01189 <span class="comment"> *   The fudge factor indicates on average, how many bytes tend to be needed to undo the action being logged.</span>
<a name="l01190"></a>01190 <span class="comment"> * - Write the log record into the buffer (the idiom is to construct it</span>
<a name="l01191"></a>01191 <span class="comment"> *      there using C++ placement-new).</span>
<a name="l01192"></a>01192 <span class="comment"> * - Release the buffer with xct_t::give_logbuf(),</span>
<a name="l01193"></a>01193 <span class="comment"> *    passing in as an argument the fixed page that was affected</span>
<a name="l01194"></a>01194 <span class="comment"> *    by the update being logged.  This does several things: </span>
<a name="l01195"></a>01195 <span class="comment"> *    - writes the transaction ID, previous LSN for this transaction </span>
<a name="l01196"></a>01196 <span class="comment"> *      into the log record</span>
<a name="l01197"></a>01197 <span class="comment"> *    - inserts the record into the log and remembers this record's LSN</span>
<a name="l01198"></a>01198 <span class="comment"> *    - marks the given page dirty.</span>
<a name="l01199"></a>01199 <span class="comment"> *</span>
<a name="l01200"></a>01200 <span class="comment"> * Between the time the xct log buffer is grabbed and the time it is</span>
<a name="l01201"></a>01201 <span class="comment"> * released, the buffer is held exclusively by the one thread that</span>
<a name="l01202"></a>01202 <span class="comment"> * grabbed it, and updates to the xct log buffer can be made freely.</span>
<a name="l01203"></a>01203 <span class="comment"> * (Note that this per-transaction log buffer is unrelated to the log buffer</span>
<a name="l01204"></a>01204 <span class="comment"> * internal to the log manager.)</span>
<a name="l01205"></a>01205 <span class="comment"> *</span>
<a name="l01206"></a>01206 <span class="comment"> * During recovery, no logging is done in analysis or redo phases; only during</span>
<a name="l01207"></a>01207 <span class="comment"> * the undo phase are log records inserted.  Log-space reservation is not</span>
<a name="l01208"></a>01208 <span class="comment"> * needed until recovery is complete; the assumption is that if the</span>
<a name="l01209"></a>01209 <span class="comment"> * transaction had enough log space prior to recovery, it has enough space</span>
<a name="l01210"></a>01210 <span class="comment"> * during recovery.</span>
<a name="l01211"></a>01211 <span class="comment"> * Prepared transactions pose a challenge, in that they are not resolved until</span>
<a name="l01212"></a>01212 <span class="comment"> * after recovery is complete. Thus, when a transaction-prepare is logged,</span>
<a name="l01213"></a>01213 <span class="comment"> * the log-space-reservations of that transaction are logged along with the rest of the transaction state (locks, coordinator, etc.) and before </span>
<a name="l01214"></a>01214 <span class="comment"> * recovery is complete, these transactions acquire their prior log-space</span>
<a name="l01215"></a>01215 <span class="comment"> * reservations.</span>
<a name="l01216"></a>01216 <span class="comment"> *</span>
<a name="l01217"></a>01217 <span class="comment"> * The above protocol is enforced by the storage manager in helper</span>
<a name="l01218"></a>01218 <span class="comment"> * functions that create log records; these functions are generated</span>
<a name="l01219"></a>01219 <span class="comment"> * by Perl scripts from the source file logdef.dat.  (See \ref LOGRECS.)</span>
<a name="l01220"></a>01220 <span class="comment"> *</span>
<a name="l01221"></a>01221 <span class="comment"> * The file logdef.dat also contains the fudge factors for log-space</span>
<a name="l01222"></a>01222 <span class="comment"> * reservation. These factors were experimentally determined.</span>
<a name="l01223"></a>01223 <span class="comment"> * There are corner cases involving btree page SMOs (structure-modification operations), in which the</span>
<a name="l01224"></a>01224 <span class="comment"> * fudge factors will fail.  [An example is when a transaction aborts after</span>
<a name="l01225"></a>01225 <span class="comment"> * having removed entries, and after other transactions have inserted</span>
<a name="l01226"></a>01226 <span class="comment"> * entries; the aborting transaction needs to re-insert its entries, which </span>
<a name="l01227"></a>01227 <span class="comment"> * now require splits.]</span>
<a name="l01228"></a>01228 <span class="comment"> * The storage manager has no resolution for this.</span>
<a name="l01229"></a>01229 <span class="comment"> * The fudge factors handle the majority of cases without reserving excessive</span>
<a name="l01230"></a>01230 <span class="comment"> * log-space.</span>
<a name="l01231"></a>01231 <span class="comment"> * \bug GNATS 156  Btree SMOs during rollback can cause problems.</span>
<a name="l01232"></a>01232 <span class="comment"> *</span>
<a name="l01233"></a>01233 <span class="comment"> *\subsection LOGRECS Log Record Types</span>
<a name="l01234"></a>01234 <span class="comment"> * The input to the above-mentioned Perl script is the source of all</span>
<a name="l01235"></a>01235 <span class="comment"> * log record types.  Each log record type is listed in the  file</span>
<a name="l01236"></a>01236 <span class="comment"> * \code logdef.dat \endcode</span>
<a name="l01237"></a>01237 <span class="comment"> * which is fairly self-explanatory, reproduced here:</span>
<a name="l01238"></a>01238 <span class="comment"> * \include logdef.dat</span>
<a name="l01239"></a>01239 <span class="comment"> *</span>
<a name="l01240"></a>01240 <span class="comment"> * The bodies of the methods of the class &lt;log-rec-name&gt;_log</span>
<a name="l01241"></a>01241 <span class="comment"> * are hand-written and reside in \code logrec.cpp \endcode.</span>
<a name="l01242"></a>01242 <span class="comment"> *</span>
<a name="l01243"></a>01243 <span class="comment"> * Adding a new log record type consists in adding a line to</span>
<a name="l01244"></a>01244 <span class="comment"> * \code logdef.dat, \endcode</span>
<a name="l01245"></a>01245 <span class="comment"> * adding method definitions to </span>
<a name="l01246"></a>01246 <span class="comment"> * \code logrec.cpp, \endcode</span>
<a name="l01247"></a>01247 <span class="comment"> * and adding the calls to the free function log_&lt;log-rec-name&gt;(args)</span>
<a name="l01248"></a>01248 <span class="comment"> * in the storage manager.</span>
<a name="l01249"></a>01249 <span class="comment"> * The base class for every log record is logrec_t, which is worth study</span>
<a name="l01250"></a>01250 <span class="comment"> * but is not documented here.</span>
<a name="l01251"></a>01251 <span class="comment"> *</span>
<a name="l01252"></a>01252 <span class="comment"> * Some logging records are \e compensated, meaning that the </span>
<a name="l01253"></a>01253 <span class="comment"> * log records are skipped during rollback. </span>
<a name="l01254"></a>01254 <span class="comment"> * Compensations may be needed because some operation simply cannot</span>
<a name="l01255"></a>01255 <span class="comment"> * be undone.  The protocol for compensating actions is as follows:</span>
<a name="l01256"></a>01256 <span class="comment"> * - Fix the needed pages.</span>
<a name="l01257"></a>01257 <span class="comment"> * - Grab an \e anchor in the log.  </span>
<a name="l01258"></a>01258 <span class="comment"> *   This is an LSN for the last log record written for this transaction.</span>
<a name="l01259"></a>01259 <span class="comment"> * - Update the pages and log the updates as usual.</span>
<a name="l01260"></a>01260 <span class="comment"> * - Write a compensation log record (or piggy-back the compensation on</span>
<a name="l01261"></a>01261 <span class="comment"> *   the last-written log record for this transaction to reduce </span>
<a name="l01262"></a>01262 <span class="comment"> *   logging overhead) and free the anchor.</span>
<a name="l01263"></a>01263 <span class="comment"> *</span>
<a name="l01264"></a>01264 <span class="comment"> * \note Grabbing an anchor prevents all other threads in a multi-threaded</span>
<a name="l01265"></a>01265 <span class="comment"> * transaction from gaining access to the transaction manager.  Be careful</span>
<a name="l01266"></a>01266 <span class="comment"> * with this, as it can cause mutex-latch deadlocks where multi-threaded</span>
<a name="l01267"></a>01267 <span class="comment"> * transactions are concerned.  In other words, two threads cannot concurrently</span>
<a name="l01268"></a>01268 <span class="comment"> * update in the same transaction.</span>
<a name="l01269"></a>01269 <span class="comment"> *</span>
<a name="l01270"></a>01270 <span class="comment"> * In some cases, the following protocol is used to avoid excessive</span>
<a name="l01271"></a>01271 <span class="comment"> * logging by general update functions that, if logging were turned</span>
<a name="l01272"></a>01272 <span class="comment"> * on, would generate log records of their own.</span>
<a name="l01273"></a>01273 <span class="comment"> * - Fix the pages needed in exclusive mode.</span>
<a name="l01274"></a>01274 <span class="comment"> * - Turn off logging for the transaction.</span>
<a name="l01275"></a>01275 <span class="comment"> * - Perform the updates by calling some general functions.  If an error occurs, undo the updates explicitly.</span>
<a name="l01276"></a>01276 <span class="comment"> * - Turn on logging for the transaction.</span>
<a name="l01277"></a>01277 <span class="comment"> * - Log the operation.  If an error occurs, undo the updates with logging turned off..</span>
<a name="l01278"></a>01278 <span class="comment"> * - Unfix the pages.</span>
<a name="l01279"></a>01279 <span class="comment"> *</span>
<a name="l01280"></a>01280 <span class="comment"> * The mechanism for turning off logging for a transaction is to</span>
<a name="l01281"></a>01281 <span class="comment"> * construct an instance of xct_log_switch_t.</span>
<a name="l01282"></a>01282 <span class="comment"> *</span>
<a name="l01283"></a>01283 <span class="comment"> * When the instance is destroyed, the original logging state</span>
<a name="l01284"></a>01284 <span class="comment"> * is restored.  The switch applies only to the transaction that is </span>
<a name="l01285"></a>01285 <span class="comment"> * attached to the thread at the time the switch instance is constructed, </span>
<a name="l01286"></a>01286 <span class="comment"> * and it prevents other threads of the transaction from using </span>
<a name="l01287"></a>01287 <span class="comment"> * the log (or doing much else in the transaction manager) </span>
<a name="l01288"></a>01288 <span class="comment"> * while the switch exists.</span>
<a name="l01289"></a>01289 <span class="comment"> *</span>
<a name="l01290"></a>01290 <span class="comment"> * \subsection LOG_M_INTERNAL Log Manager Internals</span>
<a name="l01291"></a>01291 <span class="comment"> *</span>
<a name="l01292"></a>01292 <span class="comment"> * The log is a collection of files, all in the same directory, whose</span>
<a name="l01293"></a>01293 <span class="comment"> * path is determined by a run-time option.</span>
<a name="l01294"></a>01294 <span class="comment"> * Each file in the directory is called a "log file" and represents a</span>
<a name="l01295"></a>01295 <span class="comment"> * "partition" of the log. The log is partitioned into files to make it </span>
<a name="l01296"></a>01296 <span class="comment"> * possible to archive portions of the log to free up disk space.</span>
<a name="l01297"></a>01297 <span class="comment"> * A log file has the name \e log.&lt;n&gt; where &lt;n&gt; is a positive integer.</span>
<a name="l01298"></a>01298 <span class="comment"> * The log file name indicates the set of logical sequence numbers (lsn_t)</span>
<a name="l01299"></a>01299 <span class="comment"> * of log records (logrec_t) that are contained in the file.  An</span>
<a name="l01300"></a>01300 <span class="comment"> * lsn_t has a \e high part and a \e low part, and the</span>
<a name="l01301"></a>01301 <span class="comment"> * \e high part (a.k.a., \e file part) is the &lt;n&gt; in the log file name.</span>
<a name="l01302"></a>01302 <span class="comment"> *</span>
<a name="l01303"></a>01303 <span class="comment"> * The user-settable run-time option sm_logsize indicates the maximum </span>
<a name="l01304"></a>01304 <span class="comment"> * number of KB that may be opened at once; this, in turn, determines the</span>
<a name="l01305"></a>01305 <span class="comment"> * size of a partition file, since the number of partition files is</span>
<a name="l01306"></a>01306 <span class="comment"> * a compile-time constant.</span>
<a name="l01307"></a>01307 <span class="comment"> * The storage manager computes partition sizes based on the user-provided</span>
<a name="l01308"></a>01308 <span class="comment"> * log size, such that partitions sizes are a convenient multiple of blocks</span>
<a name="l01309"></a>01309 <span class="comment"> * (more about which, below).</span>
<a name="l01310"></a>01310 <span class="comment"> *</span>
<a name="l01311"></a>01311 <span class="comment"> * A new partition is opened when the tail of the log approaches the end</span>
<a name="l01312"></a>01312 <span class="comment"> * of a partition, that is, when the next insertion into the log</span>
<a name="l01313"></a>01313 <span class="comment"> * is at an offset larger than the maximum partition size.  (There is a</span>
<a name="l01314"></a>01314 <span class="comment"> * fudge factor of BLOCK_SIZE in here for convenience in implementation.)</span>
<a name="l01315"></a>01315 <span class="comment"> * </span>
<a name="l01316"></a>01316 <span class="comment"> * The \e low part of an lsn_t represents the byte-offset into the log file</span>
<a name="l01317"></a>01317 <span class="comment"> * at which the log record with that lsn_t sits.</span>
<a name="l01318"></a>01318 <span class="comment"> *</span>
<a name="l01319"></a>01319 <span class="comment"> * Thus, the total file size of a log file \e log.&lt;n&gt;</span>
<a name="l01320"></a>01320 <span class="comment"> * is the size of all log records in the file, </span>
<a name="l01321"></a>01321 <span class="comment"> * and the lsn_t of each log record in the file is</span>
<a name="l01322"></a>01322 <span class="comment"> * lsn_t(&lt;n&gt;, &lt;byte-offset&gt;) of the log record within the file.</span>
<a name="l01323"></a>01323 <span class="comment"> *</span>
<a name="l01324"></a>01324 <span class="comment"> * The log is, conceptually, a forever-expanding set of files. The log </span>
<a name="l01325"></a>01325 <span class="comment"> * manager will open at most PARTITION_COUNT log files at any one time.</span>
<a name="l01326"></a>01326 <span class="comment"> * - PARTITION_COUNT = smlevel_0::max_openlog</span>
<a name="l01327"></a>01327 <span class="comment"> * - smlevel_0::max_openlog (sm_base.h) = SM_LOG_PARTITIONS</span>
<a name="l01328"></a>01328 <span class="comment"> * - SM_LOG_PARTITIONS a compile-time constant (which can be overridden in </span>
<a name="l01329"></a>01329 <span class="comment"> *   config/shore.def).</span>
<a name="l01330"></a>01330 <span class="comment"> *</span>
<a name="l01331"></a>01331 <span class="comment"> * The log is considered to have run out of space if logging requires that</span>
<a name="l01332"></a>01332 <span class="comment"> * more than smlevel_0::max_openlog partitions are needed.</span>
<a name="l01333"></a>01333 <span class="comment"> * Partitions are needed only as long as they contain log records </span>
<a name="l01334"></a>01334 <span class="comment"> * needed for recovery, which means:</span>
<a name="l01335"></a>01335 <span class="comment"> * - log records for pages not yet made durable (min recovery lsn)</span>
<a name="l01336"></a>01336 <span class="comment"> * - log records for uncommitted transactions (min xct lsn)</span>
<a name="l01337"></a>01337 <span class="comment"> * - log records belonging to the last complete checkpoint</span>
<a name="l01338"></a>01338 <span class="comment"> *</span>
<a name="l01339"></a>01339 <span class="comment"> * Afer a checkpoint is taken and its log records are durable,</span>
<a name="l01340"></a>01340 <span class="comment"> * the storage manager tries to scavenge all partitions that do not</span>
<a name="l01341"></a>01341 <span class="comment"> * contain necessary log records.  The buffer manager provides the</span>
<a name="l01342"></a>01342 <span class="comment"> * min recovery lsn; the transaction manager provides the min xct lsn,</span>
<a name="l01343"></a>01343 <span class="comment"> * and the log manager keeps track of the location of the last </span>
<a name="l01344"></a>01344 <span class="comment"> * completed checkpoint in its master_lsn.  Thus the minimum of the</span>
<a name="l01345"></a>01345 <span class="comment"> * </span>
<a name="l01346"></a>01346 <span class="comment"> * \e file part of the minmum of these lsns indicates the lowest partition </span>
<a name="l01347"></a>01347 <span class="comment"> * that cannot be scavenged; all the rest are removed.</span>
<a name="l01348"></a>01348 <span class="comment"> *</span>
<a name="l01349"></a>01349 <span class="comment"> * When the log is in danger of runing out of space </span>
<a name="l01350"></a>01350 <span class="comment"> * (because there are long-running  transactions, for example) </span>
<a name="l01351"></a>01351 <span class="comment"> * the server may be called via the</span>
<a name="l01352"></a>01352 <span class="comment"> * LOG_WARN_CALLBACK_FUNC argument to ss_m::ss_m.  This callback may</span>
<a name="l01353"></a>01353 <span class="comment"> * abort a transaction to free up log space, but the act of aborting</span>
<a name="l01354"></a>01354 <span class="comment"> * consumes log space. It may also archive a log file and remove it.</span>
<a name="l01355"></a>01355 <span class="comment"> * If the server provided a</span>
<a name="l01356"></a>01356 <span class="comment"> * LOG_ARCHIVED_CALLBACK_FUNC argument to ss_m::ss_m, this callback</span>
<a name="l01357"></a>01357 <span class="comment"> * can be used to retrieve archived log files when needed for</span>
<a name="l01358"></a>01358 <span class="comment"> * rollback.</span>
<a name="l01359"></a>01359 <span class="comment"> * \warning This functionality is not complete and has not been</span>
<a name="l01360"></a>01360 <span class="comment"> * well-tested.</span>
<a name="l01361"></a>01361 <span class="comment"> *</span>
<a name="l01362"></a>01362 <span class="comment"> * Log files (partitions) are written in fixed-sized blocks.  The log</span>
<a name="l01363"></a>01363 <span class="comment"> * manager pads writes, if necessary, to make them BLOCK_SIZE. </span>
<a name="l01364"></a>01364 <span class="comment"> * - BLOCK_SIZE = 8192, a compile-time constant.</span>
<a name="l01365"></a>01365 <span class="comment"> *</span>
<a name="l01366"></a>01366 <span class="comment"> * A skip_log record indicates the logical end of a partition.</span>
<a name="l01367"></a>01367 <span class="comment"> * The log manager ensures that the last log record in a file </span>
<a name="l01368"></a>01368 <span class="comment"> * is always a skip_log record. </span>
<a name="l01369"></a>01369 <span class="comment"> *</span>
<a name="l01370"></a>01370 <span class="comment"> * Log files (partitions) are composed of segments. A segment is</span>
<a name="l01371"></a>01371 <span class="comment"> * an integral number of blocks.</span>
<a name="l01372"></a>01372 <span class="comment"> * - SEGMENT_SIZE = 128*BLOCK_SIZE, a compile-time constant.</span>
<a name="l01373"></a>01373 <span class="comment"> *</span>
<a name="l01374"></a>01374 <span class="comment"> * The smallest partition is one segment plus one block, </span>
<a name="l01375"></a>01375 <span class="comment"> * but may be many segments plus one block. The last block enables</span>
<a name="l01376"></a>01376 <span class="comment"> * the log manager to write the skip_log record to indicate the</span>
<a name="l01377"></a>01377 <span class="comment"> * end of the file.</span>
<a name="l01378"></a>01378 <span class="comment"> *</span>
<a name="l01379"></a>01379 <span class="comment"> * The partition size is determined by the storage manager run-time option,</span>
<a name="l01380"></a>01380 <span class="comment"> * sm_logsize, which determines how much log can be open at any time,</span>
<a name="l01381"></a>01381 <span class="comment"> * i.e., the combined sizes of the PARTITION_COUNT partitions.</span>
<a name="l01382"></a>01382 <span class="comment"> *</span>
<a name="l01383"></a>01383 <span class="comment"> * The maximum size of a log record (logrec_t) is 3 storage manager pages.</span>
<a name="l01384"></a>01384 <span class="comment"> * A page happens to match the block size but the two compile-time</span>
<a name="l01385"></a>01385 <span class="comment"> * constants are not inter-dependent. </span>
<a name="l01386"></a>01386 <span class="comment"> * A segment is substantially larger than a block, so it can hold at least</span>
<a name="l01387"></a>01387 <span class="comment"> * several maximum-sized log records, preferably many.</span>
<a name="l01388"></a>01388 <span class="comment"> * </span>
<a name="l01389"></a>01389 <span class="comment"> * Inserting a log record consists of copying it into the log manager's</span>
<a name="l01390"></a>01390 <span class="comment"> * log buffer (1 segment in size).  The buffer wraps so long as there</span>
<a name="l01391"></a>01391 <span class="comment"> * is room in the partition.  Meanwhile, a log-flush daemon thread</span>
<a name="l01392"></a>01392 <span class="comment"> * writes out unflushed portions of the log buffer. </span>
<a name="l01393"></a>01393 <span class="comment"> * The log daemon can lag behind insertions, so each insertion checks for</span>
<a name="l01394"></a>01394 <span class="comment"> * space in the log buffer before it performs the insert. If there isn't</span>
<a name="l01395"></a>01395 <span class="comment"> * enough space, it waits until the log flush daemon has made room.</span>
<a name="l01396"></a>01396 <span class="comment"> *</span>
<a name="l01397"></a>01397 <span class="comment"> * When insertion of a log record would wrap around the buffer and the</span>
<a name="l01398"></a>01398 <span class="comment"> * partition has no room for more segments, a new partition is opened,</span>
<a name="l01399"></a>01399 <span class="comment"> * and the entire newly-inserted log record will go into that new partition.</span>
<a name="l01400"></a>01400 <span class="comment"> * Meanwhile, the log-flush daemon will see that the rest of the log</span>
<a name="l01401"></a>01401 <span class="comment"> * buffer is written to the old partition, and the next time the</span>
<a name="l01402"></a>01402 <span class="comment"> * log flush daemon performs a flush, it will be flushing to the</span>
<a name="l01403"></a>01403 <span class="comment"> * new partition.</span>
<a name="l01404"></a>01404 <span class="comment"> *</span>
<a name="l01405"></a>01405 <span class="comment"> * The bookkeeping of the log buffer's free and used space is handled</span>
<a name="l01406"></a>01406 <span class="comment"> * by the notion of \e epochs.</span>
<a name="l01407"></a>01407 <span class="comment"> * An epoch keeps track of the start and end of the unflushed portion</span>
<a name="l01408"></a>01408 <span class="comment"> * of the segment (log buffer).  Thus, an epoch refers to only one</span>
<a name="l01409"></a>01409 <span class="comment"> * segment (logically, log buffer copy within a partition).</span>
<a name="l01410"></a>01410 <span class="comment"> * When an insertion fills the log buffer and causes it to wrap, a new</span>
<a name="l01411"></a>01411 <span class="comment"> * epoch is created for the portion of the log buffer representing</span>
<a name="l01412"></a>01412 <span class="comment"> * the new segment, and the old epoch keeps track of the portion of the </span>
<a name="l01413"></a>01413 <span class="comment"> * log buffer representing the old segment.  The inserted log record</span>
<a name="l01414"></a>01414 <span class="comment"> * usually spans the two segements, as the segments are written contiguously</span>
<a name="l01415"></a>01415 <span class="comment"> * to the same log file (partition).</span>
<a name="l01416"></a>01416 <span class="comment"> *</span>
<a name="l01417"></a>01417 <span class="comment"> * When an insertion causes a wrap and there is no more room in the</span>
<a name="l01418"></a>01418 <span class="comment"> * partition to hold the new segment, a new </span>
<a name="l01419"></a>01419 <span class="comment"> * epoch is created for the portion of the log buffer representing</span>
<a name="l01420"></a>01420 <span class="comment"> * the new segment, and the old epoch keeps track of the portion of the </span>
<a name="l01421"></a>01421 <span class="comment"> * log buffer representing the old segment, as before.  </span>
<a name="l01422"></a>01422 <span class="comment"> * Now, however, the inserted log record is inserted, in its entirety,</span>
<a name="l01423"></a>01423 <span class="comment"> * in the new segment.  Thus, no log record spans partitions.</span>
<a name="l01424"></a>01424 <span class="comment"> *</span>
<a name="l01425"></a>01425 <span class="comment"> * Meanwhile, the log-flush buffer knows about the possible existence of</span>
<a name="l01426"></a>01426 <span class="comment"> * two epochs.  When an old epoch is valid, it flushes that epoch.</span>
<a name="l01427"></a>01427 <span class="comment"> * When a new epoch is also valid, it flushes that new one as well.</span>
<a name="l01428"></a>01428 <span class="comment"> * If the two epochs have the same target partition, the two flushes are</span>
<a name="l01429"></a>01429 <span class="comment"> * done with a single write.</span>
<a name="l01430"></a>01430 <span class="comment"> *</span>
<a name="l01431"></a>01431 <span class="comment"> * The act of flushing an epoch to a partition consists in a single</span>
<a name="l01432"></a>01432 <span class="comment"> * write of a size that is an even multiple of BLOCK_SIZE.  The</span>
<a name="l01433"></a>01433 <span class="comment"> * flush appends a skip_log record, and zeroes as needed, to round out the</span>
<a name="l01434"></a>01434 <span class="comment"> * size of the write.  Writes re-write portions of the log already</span>
<a name="l01435"></a>01435 <span class="comment"> * written, in order to overwrite the skip_log record at the tail of the</span>
<a name="l01436"></a>01436 <span class="comment"> * log (and put a new one at the new tail).</span>
<a name="l01437"></a>01437 <span class="comment"> *</span>
<a name="l01438"></a>01438 <span class="comment"> *</span>
<a name="l01439"></a>01439 <span class="comment"> *\subsection RECOV Recovery</span>
<a name="l01440"></a>01440 <span class="comment"> * The storage manager performs ARIES-style logging and recovery.</span>
<a name="l01441"></a>01441 <span class="comment"> * This means the logging and recovery system has these characteristics:</span>
<a name="l01442"></a>01442 <span class="comment"> * - uses write-ahead logging (WAL)</span>
<a name="l01443"></a>01443 <span class="comment"> * - repeats history on restart before doing any rollback </span>
<a name="l01444"></a>01444 <span class="comment"> * - all updates are logged, including those performed during rollback</span>
<a name="l01445"></a>01445 <span class="comment"> * - compensation records are used in the log to bound the amount</span>
<a name="l01446"></a>01446 <span class="comment"> *   of logging done for rollback </span>
<a name="l01447"></a>01447 <span class="comment"> *   and guarantee progress in the case of repeated </span>
<a name="l01448"></a>01448 <span class="comment"> *   failures and restarts.</span>
<a name="l01449"></a>01449 <span class="comment"> *</span>
<a name="l01450"></a>01450 <span class="comment"> * Each time a storage manager (ss_m class) is constructed, the logs</span>
<a name="l01451"></a>01451 <span class="comment"> * are inspected, the last checkpoint is located, and its lsn is</span>
<a name="l01452"></a>01452 <span class="comment"> * remembered as the master_lsn, then recovery is performed.</span>
<a name="l01453"></a>01453 <span class="comment"> * Recovery consists of three phases: analysis, redo and undo.</span>
<a name="l01454"></a>01454 <span class="comment"> *</span>
<a name="l01455"></a>01455 <span class="comment"> *\subsubsection RECOVANAL Analysis</span>
<a name="l01456"></a>01456 <span class="comment"> * This pass analyzes the log starting at the master_lsn, and</span>
<a name="l01457"></a>01457 <span class="comment"> *   reading log records written thereafter.  Reading the log records for the</span>
<a name="l01458"></a>01458 <span class="comment"> *   last completed checkpoint, it reconstructs the transaction table, the</span>
<a name="l01459"></a>01459 <span class="comment"> *   buffer-pool's dirty page table, and mounts the devices and</span>
<a name="l01460"></a>01460 <span class="comment"> *   volumes that were mounted at the time of the checkpoint.</span>
<a name="l01461"></a>01461 <span class="comment"> *   From the dirty page table, it determines the \e redo_lsn, </span>
<a name="l01462"></a>01462 <span class="comment"> *   the lowest recovery lsn of the dirty pages, which is </span>
<a name="l01463"></a>01463 <span class="comment"> *   where the next phase of recovery must begin.</span>
<a name="l01464"></a>01464 <span class="comment"> *</span>
<a name="l01465"></a>01465 <span class="comment"> *\subsubsection RECOVREDO Redo</span>
<a name="l01466"></a>01466 <span class="comment"> * This pass starts reading the log at the redo_lsn, and, for each</span>
<a name="l01467"></a>01467 <span class="comment"> *   log record thereafter, decides whether that log record's </span>
<a name="l01468"></a>01468 <span class="comment"> *   work needs to be redone.  The general protocol is:</span>
<a name="l01469"></a>01469 <span class="comment"> *   - if the log record is not redoable, it is ignored</span>
<a name="l01470"></a>01470 <span class="comment"> *   - if the log record is redoable and contains a page ID, the</span>
<a name="l01471"></a>01471 <span class="comment"> *   page is inspected and its lsn is compared to that of the log</span>
<a name="l01472"></a>01472 <span class="comment"> *   record. If the page lsn is later than the log record's sequence number,</span>
<a name="l01473"></a>01473 <span class="comment"> *   the page does not need to be updated per this log record, and the</span>
<a name="l01474"></a>01474 <span class="comment"> *   action is not redone.</span>
<a name="l01475"></a>01475 <span class="comment"> *</span>
<a name="l01476"></a>01476 <span class="comment"> *\subsubsection RECOVUNDO Undo</span>
<a name="l01477"></a>01477 <span class="comment"> *  After redo,  the state of the database matches that at the time </span>
<a name="l01478"></a>01478 <span class="comment"> *  of the crash.  Now the storage manager rolls back the transactions that </span>
<a name="l01479"></a>01479 <span class="comment"> *  remain active.  </span>
<a name="l01480"></a>01480 <span class="comment"> *  Care is taken to undo the log records in reverse chronological order, </span>
<a name="l01481"></a>01481 <span class="comment"> *  rather than allowing several transactions to roll back </span>
<a name="l01482"></a>01482 <span class="comment"> *  at their own paces.  This is necessary because some operations </span>
<a name="l01483"></a>01483 <span class="comment"> *  use page-fixing for concurrency-control (pages are protected </span>
<a name="l01484"></a>01484 <span class="comment"> *  only with latches if there is no page lock in</span>
<a name="l01485"></a>01485 <span class="comment"> *  the lock hierarchy -- this occurs when </span>
<a name="l01486"></a>01486 <span class="comment"> *  logical logging and high-concurrency locking are used, </span>
<a name="l01487"></a>01487 <span class="comment"> *  in the B-trees, for example.  A crash in the middle of </span>
<a name="l01488"></a>01488 <span class="comment"> * a compensated action such as a page split must result in </span>
<a name="l01489"></a>01489 <span class="comment"> * the split being undone before any other operations on the </span>
<a name="l01490"></a>01490 <span class="comment"> * tree are undone.). </span>
<a name="l01491"></a>01491 <span class="comment"> * \bug GNATS 49 (performance) There is no concurrent undo.</span>
<a name="l01492"></a>01492 <span class="comment"> *</span>
<a name="l01493"></a>01493 <span class="comment"> * After the storage manager has recovered, control returns from its</span>
<a name="l01494"></a>01494 <span class="comment"> * constructor method to the caller (the server).</span>
<a name="l01495"></a>01495 <span class="comment"> * There might be transactions left in prepared state.  </span>
<a name="l01496"></a>01496 <span class="comment"> * The server is now free to resolve these transactions by </span>
<a name="l01497"></a>01497 <span class="comment"> * communicating with its coordinator. </span>
<a name="l01498"></a>01498 <span class="comment"> *</span>
<a name="l01499"></a>01499 <span class="comment"> *\subsection LSNS Log Sequence Numbers</span>
<a name="l01500"></a>01500 <span class="comment"> *</span>
<a name="l01501"></a>01501 <span class="comment"> * Write-ahead logging requires a close interaction between the</span>
<a name="l01502"></a>01502 <span class="comment"> * log manager and the buffer manager: before a page can be flushed</span>
<a name="l01503"></a>01503 <span class="comment"> * from the buffer pool, the log might have to be flushed.</span>
<a name="l01504"></a>01504 <span class="comment"> *</span>
<a name="l01505"></a>01505 <span class="comment"> * This also requires a close interaction between the transaction</span>
<a name="l01506"></a>01506 <span class="comment"> * manager and the log manager.</span>
<a name="l01507"></a>01507 <span class="comment"> * </span>
<a name="l01508"></a>01508 <span class="comment"> * All three managers understand a log sequence number (lsn_t).</span>
<a name="l01509"></a>01509 <span class="comment"> * Log sequence numbers serve to identify and locate log records</span>
<a name="l01510"></a>01510 <span class="comment"> * in the log, to timestamp pages, identify timestamp the last</span>
<a name="l01511"></a>01511 <span class="comment"> * update performed by a transaction, and the last log record written</span>
<a name="l01512"></a>01512 <span class="comment"> * by a transaction.  Since every update is logged, every update</span>
<a name="l01513"></a>01513 <span class="comment"> * can be identified by a log sequence number.  Each page bears</span>
<a name="l01514"></a>01514 <span class="comment"> * the log sequence number of the last update that affected that</span>
<a name="l01515"></a>01515 <span class="comment"> * page.</span>
<a name="l01516"></a>01516 <span class="comment"> *</span>
<a name="l01517"></a>01517 <span class="comment"> * A page cannot be written to disk until  the log record with that</span>
<a name="l01518"></a>01518 <span class="comment"> * page's lsn has been written to the log (and is on stable storage).</span>
<a name="l01519"></a>01519 <span class="comment"> * A log sequence number is a 64-bit structure,  with part identifying</span>
<a name="l01520"></a>01520 <span class="comment"> * a log partition (file) number and the rest identifying an offset within the file. </span>
<a name="l01521"></a>01521 <span class="comment"> *</span>
<a name="l01522"></a>01522 <span class="comment"> * \subsection LOGPART Log Partitions</span>
<a name="l01523"></a>01523 <span class="comment"> *</span>
<a name="l01524"></a>01524 <span class="comment"> * The log is partitioned to simplify archiving to tape (not implemented)</span>
<a name="l01525"></a>01525 <span class="comment"> * The log comprises 8 partitions, where each partition's</span>
<a name="l01526"></a>01526 <span class="comment"> * size is limited to approximately 1/8 the maximum log size given</span>
<a name="l01527"></a>01527 <span class="comment"> * in the run-time configuration option sm_logsize.</span>
<a name="l01528"></a>01528 <span class="comment"> * A partition resides in a file named \e log.&lt;n&gt;, where \e n</span>
<a name="l01529"></a>01529 <span class="comment"> * is the partition number.</span>
<a name="l01530"></a>01530 <span class="comment"> * The configuration option sm_logdir names a directory </span>
<a name="l01531"></a>01531 <span class="comment"> * (which must exist before the storage manager is started) </span>
<a name="l01532"></a>01532 <span class="comment"> * in which the storage manager may create and destroy log files.</span>
<a name="l01533"></a>01533 <span class="comment"> *</span>
<a name="l01534"></a>01534 <span class="comment"> *  The storage manger may have at most 8 active partitions at any one time.  </span>
<a name="l01535"></a>01535 <span class="comment"> *  An active partition is one that is needed because it </span>
<a name="l01536"></a>01536 <span class="comment"> *  contains log records for running transactions.  Such partitions </span>
<a name="l01537"></a>01537 <span class="comment"> *  could (if it were supported) be streamed to tape and their disk </span>
<a name="l01538"></a>01538 <span class="comment"> *  space reclaimed.  Space is reclaimed when the oldest transaction </span>
<a name="l01539"></a>01539 <span class="comment"> *  ends and the new oldest transaction's first log record is </span>
<a name="l01540"></a>01540 <span class="comment"> *  in a newer partition than that in which the old oldest </span>
<a name="l01541"></a>01541 <span class="comment"> *  transaction's first log record resided.  </span>
<a name="l01542"></a>01542 <span class="comment"> *  Until tape archiving is implemented, the storage </span>
<a name="l01543"></a>01543 <span class="comment"> *  manager issues an error (eOUTOFLOGSPACE) </span>
<a name="l01544"></a>01544 <span class="comment"> *  if it consumes sufficient log space to be unable to </span>
<a name="l01545"></a>01545 <span class="comment"> *  abort running transactions and perform all resulting necessary logging </span>
<a name="l01546"></a>01546 <span class="comment"> *  within the 8 partitions available. </span>
<a name="l01547"></a>01547 <span class="comment"> * \note Determining the point at which there is insufficient space to</span>
<a name="l01548"></a>01548 <span class="comment"> * abort all running transactions is a heuristic matter and it</span>
<a name="l01549"></a>01549 <span class="comment"> * is not reliable.  The transaction "reserves" log space for rollback, meaning</span>
<a name="l01550"></a>01550 <span class="comment"> * that no other transaction can consume that space until the transaction ends.'</span>
<a name="l01551"></a>01551 <span class="comment"> * A transaction has to reserve significantly more space to roll back than it</span>
<a name="l01552"></a>01552 <span class="comment"> * needs for forward processing B-tree deletions; this is because the log overhead</span>
<a name="l01553"></a>01553 <span class="comment"> * for the insertions is considerably larger than that for deletion.</span>
<a name="l01554"></a>01554 <span class="comment"> * The (compile-time) page size is also a factor in this heuristic.</span>
<a name="l01555"></a>01555 <span class="comment"> *</span>
<a name="l01556"></a>01556 <span class="comment"> * Log records are buffered by the log manager until forced to stable </span>
<a name="l01557"></a>01557 <span class="comment"> * storage to reduce I/O costs.  </span>
<a name="l01558"></a>01558 <span class="comment"> * The log manager keeps a buffer of a size that is determined by </span>
<a name="l01559"></a>01559 <span class="comment"> * a run-time configuration option.  </span>
<a name="l01560"></a>01560 <span class="comment"> * The buffer is flushed to stable storage when necessary.  </span>
<a name="l01561"></a>01561 <span class="comment"> * The last log in the buffer is always a skip log record, </span>
<a name="l01562"></a>01562 <span class="comment"> * which indicates the end of the log partition.</span>
<a name="l01563"></a>01563 <span class="comment"> *</span>
<a name="l01564"></a>01564 <span class="comment"> * Ultimately, archiving to tape is necessary.  The storage manager</span>
<a name="l01565"></a>01565 <span class="comment"> * does not perform write-aside or any other work in support of</span>
<a name="l01566"></a>01566 <span class="comment"> * long-running transactions.</span>
<a name="l01567"></a>01567 <span class="comment"> *</span>
<a name="l01568"></a>01568 <span class="comment"> * The checkpoint manager chkpt_m sleeps until kicked into action</span>
<a name="l01569"></a>01569 <span class="comment"> * by the log manager, and when it is kicked, it takes a checkpoint, </span>
<a name="l01570"></a>01570 <span class="comment"> * then sleeps again.  Taking a checkpoint amounts to these steps:</span>
<a name="l01571"></a>01571 <span class="comment"> * - Write a chkpt_begin log record.</span>
<a name="l01572"></a>01572 <span class="comment"> * - Write a series of log records recording the mounted devices and volumes..</span>
<a name="l01573"></a>01573 <span class="comment"> * - Write a series of log records recording the mounted devices.</span>
<a name="l01574"></a>01574 <span class="comment"> * - Write a series of log records recording the buffer pool's dirty pages.</span>
<a name="l01575"></a>01575 <span class="comment"> *    For each dirty page in the buffer pool, the page id and its recovery lsn </span>
<a name="l01576"></a>01576 <span class="comment"> *    is logged.  </span>
<a name="l01577"></a>01577 <span class="comment"> *    \anchor RECLSN</span>
<a name="l01578"></a>01578 <span class="comment"> *    A page's  recovery lsn is metadata stored in the buffer </span>
<a name="l01579"></a>01579 <span class="comment"> *    manager's control block, but is not written on the page. </span>
<a name="l01580"></a>01580 <span class="comment"> *    It represents an lsn prior to or equal to the log's current lsn at </span>
<a name="l01581"></a>01581 <span class="comment"> *    the time the page was first marked dirty.  Hence, it</span>
<a name="l01582"></a>01582 <span class="comment"> *    is less than or equal to the LSN of the log record for the first</span>
<a name="l01583"></a>01583 <span class="comment"> *    update to that page after the page was read into the buffer</span>
<a name="l01584"></a>01584 <span class="comment"> *    pool (and remained there until this checkpoint).  The minimum</span>
<a name="l01585"></a>01585 <span class="comment"> *    of all the  recovery lsn written in this checkpoint </span>
<a name="l01586"></a>01586 <span class="comment"> *    will be a starting point for crash-recovery, if this is </span>
<a name="l01587"></a>01587 <span class="comment"> *    the last checkpoint completed before a crash.</span>
<a name="l01588"></a>01588 <span class="comment"> * - Write a series of log records recording the states of the known </span>
<a name="l01589"></a>01589 <span class="comment"> *    transactions, including the prepared transactions.  </span>
<a name="l01590"></a>01590 <span class="comment"> * - Write a chkpt_end log record.</span>
<a name="l01591"></a>01591 <span class="comment"> * - Tell the log manage where this checkpoint is: the lsn of the chkpt_begin</span>
<a name="l01592"></a>01592 <span class="comment"> *   log record becomes the new master_lsn of the log. The master_lsn is</span>
<a name="l01593"></a>01593 <span class="comment"> *   written in a special place in the log so that it can always be </span>
<a name="l01594"></a>01594 <span class="comment"> *   discovered on restart.</span>
<a name="l01595"></a>01595 <span class="comment"> *</span>
<a name="l01596"></a>01596 <span class="comment"> *   These checkpoint log records may interleave with other log records, making</span>
<a name="l01597"></a>01597 <span class="comment"> *   the checkpoint "fuzzy"; this way the world doesn't have to grind to</span>
<a name="l01598"></a>01598 <span class="comment"> *   a halt while a checkpoint is taken, but there are a few operations that</span>
<a name="l01599"></a>01599 <span class="comment"> *   must be serialized with all or portions of a checkpoint. Those operations</span>
<a name="l01600"></a>01600 <span class="comment"> *   use mutex locks to synchronize.  Synchronization of operations is</span>
<a name="l01601"></a>01601 <span class="comment"> *   as follows:</span>
<a name="l01602"></a>01602 <span class="comment"> *   - Checkpoints cannot happen simultaneously - they are serialized with</span>
<a name="l01603"></a>01603 <span class="comment"> *   respect to each other.</span>
<a name="l01604"></a>01604 <span class="comment"> *   - A checkpoint and the following are serialized:</span>
<a name="l01605"></a>01605 <span class="comment"> *      - mount or dismount a volume</span>
<a name="l01606"></a>01606 <span class="comment"> *      - prepare a transaction</span>
<a name="l01607"></a>01607 <span class="comment"> *      - commit or abort a transaction (a certain portion of this must</span>
<a name="l01608"></a>01608 <span class="comment"> *        wait until a checkpoint is not happening)</span>
<a name="l01609"></a>01609 <span class="comment"> *      - heriocs to cope with shortage of log space</span>
<a name="l01610"></a>01610 <span class="comment"> *   - The portion of a checkpoint that logs the transaction table is</span>
<a name="l01611"></a>01611 <span class="comment"> *     serialized with the following:</span>
<a name="l01612"></a>01612 <span class="comment"> *      - operations that can run only with one thread attached to</span>
<a name="l01613"></a>01613 <span class="comment"> *        a transaction (including the code that enforces this)</span>
<a name="l01614"></a>01614 <span class="comment"> *      - transaction begin, end</span>
<a name="l01615"></a>01615 <span class="comment"> *      - determining the number of active transactions</span>
<a name="l01616"></a>01616 <span class="comment"> *      - constructing a virtual table from the transaction table</span>
<a name="l01617"></a>01617 <span class="comment"> *</span>
<a name="l01618"></a>01618 <span class="comment"> * \section BF_M Buffer Manager</span>
<a name="l01619"></a>01619 <span class="comment"> * The buffer manager is the means by which all other modules (except</span>
<a name="l01620"></a>01620 <span class="comment"> * the log manager) read and write pages.  </span>
<a name="l01621"></a>01621 <span class="comment"> * A page is read by calling bf_m::fix.</span>
<a name="l01622"></a>01622 <span class="comment"> * If the page requested cannot be found in the buffer pool, </span>
<a name="l01623"></a>01623 <span class="comment"> * the requesting thread reads the page and blocks waiting for the </span>
<a name="l01624"></a>01624 <span class="comment"> * read to complete.</span>
<a name="l01625"></a>01625 <span class="comment"> *</span>
<a name="l01626"></a>01626 <span class="comment"> * All frames in the buffer pool are the same size, and </span>
<a name="l01627"></a>01627 <span class="comment"> * they cannot be coalesced, </span>
<a name="l01628"></a>01628 <span class="comment"> * so the buffer manager manages a set of pages of fixed size.</span>
<a name="l01629"></a>01629 <span class="comment"> *</span>
<a name="l01630"></a>01630 <span class="comment"> * \subsection BFHASHTAB Hash Table</span>
<a name="l01631"></a>01631 <span class="comment"> * The buffer manager maintains a hash table mapping page IDs to</span>
<a name="l01632"></a>01632 <span class="comment"> * buffer control blocks.  A control block points to its frame, and</span>
<a name="l01633"></a>01633 <span class="comment"> * from a frame one can arithmetically locate its control block (in</span>
<a name="l01634"></a>01634 <span class="comment"> * bf_m::get_cb(const page_s *)).</span>
<a name="l01635"></a>01635 <span class="comment"> * The hash table for the buffer pool uses cuckoo hashing </span>
<a name="l01636"></a>01636 <span class="comment"> * (see \ref P1) with multiple hash functions and multiple slots per bucket.  </span>
<a name="l01637"></a>01637 <span class="comment"> * These are compile-time constants and can be modified (bf_htab.h).</span>
<a name="l01638"></a>01638 <span class="comment"> *</span>
<a name="l01639"></a>01639 <span class="comment"> * Cuckoo hashing is subject to cycles, in which making room on one </span>
<a name="l01640"></a>01640 <span class="comment"> * table bucket A would require moving something else into A.</span>
<a name="l01641"></a>01641 <span class="comment"> * Using at least two slots per bucket reduces the chance of a cycle.</span>
<a name="l01642"></a>01642 <span class="comment"> *</span>
<a name="l01643"></a>01643 <span class="comment"> * The implementation contains a limit on the number of times it looks for</span>
<a name="l01644"></a>01644 <span class="comment"> * an empty slot or moves that it has to perform to make room.  It does</span>
<a name="l01645"></a>01645 <span class="comment"> * If cycles are present, the limit will be hit, but hitting the limit</span>
<a name="l01646"></a>01646 <span class="comment"> * does not necessarily indicate a cycle.  If the limit is hit,</span>
<a name="l01647"></a>01647 <span class="comment"> * the insert will fail.</span>
<a name="l01648"></a>01648 <span class="comment"> * The "normal" solution in this case is to rebuild the table with</span>
<a name="l01649"></a>01649 <span class="comment"> * different hash functions. The storage manager does not handle this case.</span>
<a name="l01650"></a>01650 <span class="comment"> * \bug  GNATS 47 </span>
<a name="l01651"></a>01651 <span class="comment"> * In event of insertion failure, the hash table will have to be rebuilt with</span>
<a name="l01652"></a>01652 <span class="comment"> * different hash functions, or will have to be modified in some way.</span>
<a name="l01653"></a>01653 <span class="comment"> *</span>
<a name="l01654"></a>01654 <span class="comment"> * \bug GNATS 35 The buffer manager hash table implementation contains a race.</span>
<a name="l01655"></a>01655 <span class="comment"> * While a thread performs a hash-table</span>
<a name="l01656"></a>01656 <span class="comment"> * lookup, an item could move from one bucket to another (but not</span>
<a name="l01657"></a>01657 <span class="comment"> * from one slot to another within a bucket).</span>
<a name="l01658"></a>01658 <span class="comment"> * The implementation contains a temporary work-around for</span>
<a name="l01659"></a>01659 <span class="comment"> * this, until the problem is more gracefully fixed: if lookup fails to</span>
<a name="l01660"></a>01660 <span class="comment"> * find the target of the lookup, it performs an expensive lookup and</span>
<a name="l01661"></a>01661 <span class="comment"> * the statistics record these as bf_harsh_lookups. This is expensive.</span>
<a name="l01662"></a>01662 <span class="comment"> *</span>
<a name="l01663"></a>01663 <span class="comment"> * \subsection REPLACEMENT Page Replacement</span>
<a name="l01664"></a>01664 <span class="comment"> * When a page is fixed, the buffer manager looks for a free buffer-pool frame,</span>
<a name="l01665"></a>01665 <span class="comment"> * and if one is not available, it has to choose a victim to replace. </span>
<a name="l01666"></a>01666 <span class="comment"> * It uses a clock-based algorithm to determine where in the buffer pool</span>
<a name="l01667"></a>01667 <span class="comment"> * to start looking for an unlatched frame:</span>
<a name="l01668"></a>01668 <span class="comment"> * On the first pass of the buffer pool it considers only clean frames. </span>
<a name="l01669"></a>01669 <span class="comment"> * On the second pass it will consider dirty pages,</span>
<a name="l01670"></a>01670 <span class="comment"> * and on the third or subsequent pass it will consider any frame.</span>
<a name="l01671"></a>01671 <span class="comment"> *</span>
<a name="l01672"></a>01672 <span class="comment"> * The buffer manager forks background threads to flush dirty pages. </span>
<a name="l01673"></a>01673 <span class="comment"> * The buffer manager makes an attempt to avoid hot pages and to minimize </span>
<a name="l01674"></a>01674 <span class="comment"> * the cost of I/O by sorting and coalescing requests for contiguous pages. </span>
<a name="l01675"></a>01675 <span class="comment"> * Statistics kept by the buffer manager tell the number of resulting write </span>
<a name="l01676"></a>01676 <span class="comment"> * requests of each size.</span>
<a name="l01677"></a>01677 <span class="comment"> *</span>
<a name="l01678"></a>01678 <span class="comment"> * There is one bf_cleaner_t thread for each volume, and it flushes pages for that</span>
<a name="l01679"></a>01679 <span class="comment"> * volume; this is done so that it can combine contiguous pages into</span>
<a name="l01680"></a>01680 <span class="comment"> * single write requests to minimize I/O.  Each bf_cleaner_t is a master thread with</span>
<a name="l01681"></a>01681 <span class="comment"> * multiple page-writer slave threads.  The number of slave threads per master</span>
<a name="l01682"></a>01682 <span class="comment"> * thread is controlled by a run-time option.</span>
<a name="l01683"></a>01683 <span class="comment"> * The master thread can be disabled (thereby disabling all background</span>
<a name="l01684"></a>01684 <span class="comment"> * flushing of dirty pages) with a run-time option. </span>
<a name="l01685"></a>01685 <span class="comment"> *</span>
<a name="l01686"></a>01686 <span class="comment"> * The buffer manager writes dirty pages even if the transaction</span>
<a name="l01687"></a>01687 <span class="comment"> * that dirtied the page is still active (steal policy). Pages</span>
<a name="l01688"></a>01688 <span class="comment"> * stay in the buffer pool as long as they are needed, except when</span>
<a name="l01689"></a>01689 <span class="comment"> * chosen as a victim for replacement (no force policy).</span>
<a name="l01690"></a>01690 <span class="comment"> *</span>
<a name="l01691"></a>01691 <span class="comment"> * The replacement algorithm is clock-based (it sweeps the buffer</span>
<a name="l01692"></a>01692 <span class="comment"> * pool, noting and clearing reference counts). This is a cheap</span>
<a name="l01693"></a>01693 <span class="comment"> * way to achieve something close to LRU; it avoids much of the</span>
<a name="l01694"></a>01694 <span class="comment"> * overhead and mutex bottlenecks associated with LRU.</span>
<a name="l01695"></a>01695 <span class="comment"> *</span>
<a name="l01696"></a>01696 <span class="comment"> * The buffer manager maintains a hash table that maps page IDs to buffer </span>
<a name="l01697"></a>01697 <span class="comment"> * frame  control blocks (bfcb_t), which in turn point to frames</span>
<a name="l01698"></a>01698 <span class="comment"> * in the buffer pool.  The bfcb_t keeps track of the page in the frame, </span>
<a name="l01699"></a>01699 <span class="comment"> * the page ID of the previously-held page, </span>
<a name="l01700"></a>01700 <span class="comment"> * and whether it is in transit, the dirty/clean state of the page, </span>
<a name="l01701"></a>01701 <span class="comment"> * the number of page fixes (pins) held on the page (i.e., reference counts), </span>
<a name="l01702"></a>01702 <span class="comment"> * the \ref RECLSN "recovery lsn" of the page, etc.  </span>
<a name="l01703"></a>01703 <span class="comment"> * The control block also contains a latch.  A page, when fixed,</span>
<a name="l01704"></a>01704 <span class="comment"> * is always fixed in a latch mode, either LATCH_SH or LATCH_EX.</span>
<a name="l01705"></a>01705 <span class="comment"> * \bug GNATS 40 bf_m::upgrade_latch() drops the latch and re-acquires in</span>
<a name="l01706"></a>01706 <span class="comment"> * the new mode, if it cannot perform the upgrade without blocking. </span>
<a name="l01707"></a>01707 <span class="comment"> * This is an issue inherited from the original SHORE storage manager.</span>
<a name="l01708"></a>01708 <span class="comment"> * To block in this case</span>
<a name="l01709"></a>01709 <span class="comment"> * would enable a deadlock in which two threads hold the latch in SH mode</span>
<a name="l01710"></a>01710 <span class="comment"> * and both want to upgrade to EX mode.  When this happens, the statistics </span>
<a name="l01711"></a>01711 <span class="comment"> * counter \c bf_upgrade_latch_race is incremented.</span>
<a name="l01712"></a>01712 <span class="comment"> *</span>
<a name="l01713"></a>01713 <span class="comment"> * Page fixes are expensive (in CPU time, even if the page is resident).</span>
<a name="l01714"></a>01714 <span class="comment"> *</span>
<a name="l01715"></a>01715 <span class="comment"> * Each page type defines a set of fix methods that are virtual in </span>
<a name="l01716"></a>01716 <span class="comment"> * the base class for all pages: The rest of the storage manager </span>
<a name="l01717"></a>01717 <span class="comment"> * interacts with the buffer manager primarily through these methods </span>
<a name="l01718"></a>01718 <span class="comment"> * of the page classes.  </span>
<a name="l01719"></a>01719 <span class="comment"> * The macros MAKEPAGECODE are used for each page subtype; they </span>
<a name="l01720"></a>01720 <span class="comment"> * define all the fix methods on the page in such a way that bf_m::fix() </span>
<a name="l01721"></a>01721 <span class="comment"> * is properly called in each case. </span>
<a name="l01722"></a>01722 <span class="comment"> *</span>
<a name="l01723"></a>01723 <span class="comment"> * A page frame may be latched for a page without the page being </span>
<a name="l01724"></a>01724 <span class="comment"> * read from disk; this</span>
<a name="l01725"></a>01725 <span class="comment"> * is done when a page is about to be formatted. </span>
<a name="l01726"></a>01726 <span class="comment"> *</span>
<a name="l01727"></a>01727 <span class="comment"> * The buffer manager is responsible for maintaining WAL; this means it may not</span>
<a name="l01728"></a>01728 <span class="comment"> * flush to disk dirty pages whose log records have not reached stable storage yet.</span>
<a name="l01729"></a>01729 <span class="comment"> * Temporary pages (see sm_store_property_t) do not get logged, so they do not</span>
<a name="l01730"></a>01730 <span class="comment"> * have page lsns to assist in determining their clean/dirty status, and since pages</span>
<a name="l01731"></a>01731 <span class="comment"> * may change from temporary (unlogged) to logged, they require special handling, described</span>
<a name="l01732"></a>01732 <span class="comment"> * below.</span>
<a name="l01733"></a>01733 <span class="comment"> *</span>
<a name="l01734"></a>01734 <span class="comment"> * When a page is unfixed, sometimes it has been updated and must be marked dirty.</span>
<a name="l01735"></a>01735 <span class="comment"> * The protocol used in the storage manager is as follows:</span>
<a name="l01736"></a>01736 <span class="comment"> *</span>
<a name="l01737"></a>01737 <span class="comment"> * - Fixing with latch mode EX signals intent to dirty the page. If the page</span>
<a name="l01738"></a>01738 <span class="comment"> *   is not already dirty, the buffer control block for the page is given a</span>
<a name="l01739"></a>01739 <span class="comment"> *   recovery lsn of the page's lsn. This means that any dirtying of the page</span>
<a name="l01740"></a>01740 <span class="comment"> *   will be done with a log record whose lsn is larger than this recovery lsn.</span>
<a name="l01741"></a>01741 <span class="comment"> *   Fixing with EX mode of an already-dirty page does not change </span>
<a name="l01742"></a>01742 <span class="comment"> *   the recovery lsn  for the page.</span>
<a name="l01743"></a>01743 <span class="comment"> *</span>
<a name="l01744"></a>01744 <span class="comment"> * - Clean pages have a recovery lsn of lsn_t::null.</span>
<a name="l01745"></a>01745 <span class="comment"> *</span>
<a name="l01746"></a>01746 <span class="comment"> * - A thread updates a page in the buffer pool only when it has the</span>
<a name="l01747"></a>01747 <span class="comment"> *   page EX-fixed(latched).</span>
<a name="l01748"></a>01748 <span class="comment"> *</span>
<a name="l01749"></a>01749 <span class="comment"> * - After the update to the page, the thread writes a log record to </span>
<a name="l01750"></a>01750 <span class="comment"> *   record the update.  The log functions (generated by Perl) </span>
<a name="l01751"></a>01751 <span class="comment"> *   determine if a log record should be written (not if a tmp </span>
<a name="l01752"></a>01752 <span class="comment"> *   page, or if logging turned off, for example),</span>
<a name="l01753"></a>01753 <span class="comment"> *   and if not, they call page.set_dirty() so that any subsequent</span>
<a name="l01754"></a>01754 <span class="comment"> *   unfix notices that the page is dirty.</span>
<a name="l01755"></a>01755 <span class="comment"> *   If the log record is written, the modified page is unfixed with</span>
<a name="l01756"></a>01756 <span class="comment"> *   unfix_dirty() (in xct_impl::give_logbuf).</span>
<a name="l01757"></a>01757 <span class="comment"> *</span>
<a name="l01758"></a>01758 <span class="comment"> * - Before unfixing a page, if it was written, it must be marked dirty first</span>
<a name="l01759"></a>01759 <span class="comment"> *   with </span>
<a name="l01760"></a>01760 <span class="comment"> *   - set_dirty followed by unfix, or</span>
<a name="l01761"></a>01761 <span class="comment"> *   - unfix_dirty (which is set_dirty + unfix).</span>
<a name="l01762"></a>01762 <span class="comment"> *</span>
<a name="l01763"></a>01763 <span class="comment"> * - Before unfixing a page, if it was NOT written, unfix it with bf_m::unfix</span>
<a name="l01764"></a>01764 <span class="comment"> *   so its recovery lsn gets cleared.  This happens only if this is the</span>
<a name="l01765"></a>01765 <span class="comment"> *   last thread to unfix the page.  The page could have multiple fixers </span>
<a name="l01766"></a>01766 <span class="comment"> *   (latch holders) only if it were fixed in SH mode.  If fixed (latched)</span>
<a name="l01767"></a>01767 <span class="comment"> *   in EX mode,  this will be the only thread to hold the latch and the</span>
<a name="l01768"></a>01768 <span class="comment"> *   unfix will clear the recovery lsn.</span>
<a name="l01769"></a>01769 <span class="comment"> *</span>
<a name="l01770"></a>01770 <span class="comment"> *  It is possible that a page is fixed in EX mode, marked dirty but never</span>
<a name="l01771"></a>01771 <span class="comment"> *  updated after all,  then unfixed.  The buffer manager attempts to recognize</span>
<a name="l01772"></a>01772 <span class="comment"> *  this situation and clean the control block "dirty" bit and recovery lsn.</span>
<a name="l01773"></a>01773 <span class="comment"> *</span>
<a name="l01774"></a>01774 <span class="comment"> * Things get a little complicated where the buffer-manager's </span>
<a name="l01775"></a>01775 <span class="comment"> * page-writer threads are</span>
<a name="l01776"></a>01776 <span class="comment"> * concerned.  The  page-writer threads acquire a share latches and copy</span>
<a name="l01777"></a>01777 <span class="comment"> * dirty pages; this being faster than holding the latch for the duration of the</span>
<a name="l01778"></a>01778 <span class="comment"> * write to disk</span>
<a name="l01779"></a>01779 <span class="comment"> * When the write is finished,  the page-writer re-latches the page with the</span>
<a name="l01780"></a>01780 <span class="comment"> * intention of marking it clean if no intervening updates have occurred. This</span>
<a name="l01781"></a>01781 <span class="comment"> * means changing the \e dirty bit and updating the recovery lsn in the buffer </span>
<a name="l01782"></a>01782 <span class="comment"> * control block. The difficulty lies in determining if the page is indeed clean,</span>
<a name="l01783"></a>01783 <span class="comment"> * that is, matches the latest durable copy.</span>
<a name="l01784"></a>01784 <span class="comment"> * In the absence of unlogged (t_temporary) pages, this would not be terribly</span>
<a name="l01785"></a>01785 <span class="comment"> * difficult but would still have to cope with the case that the page was</span>
<a name="l01786"></a>01786 <span class="comment"> * (updated and) written by another thread between the copy and the re-fix.</span>
<a name="l01787"></a>01787 <span class="comment"> * It might have been cleaned, or that other thread might be operating in</span>
<a name="l01788"></a>01788 <span class="comment"> * lock-step with this thread.</span>
<a name="l01789"></a>01789 <span class="comment"> * The conservative handling would be not to change the recovery lsn in the</span>
<a name="l01790"></a>01790 <span class="comment"> * control block if the page's lsn is changed, however this has </span>
<a name="l01791"></a>01791 <span class="comment"> * serious consequences</span>
<a name="l01792"></a>01792 <span class="comment"> * for hot pages: their recovery lsns might never be moved toward the tail of</span>
<a name="l01793"></a>01793 <span class="comment"> * the log (the recovery lsns remain artificially low) and </span>
<a name="l01794"></a>01794 <span class="comment"> * thus the hot pages can prevent scavenging of log partitions. If log</span>
<a name="l01795"></a>01795 <span class="comment"> * partitions cannot be scavenged, the server runs out of log space.</span>
<a name="l01796"></a>01796 <span class="comment"> * For this reason, the buffer manager goes to some lengths to update the</span>
<a name="l01797"></a>01797 <span class="comment"> * recovery lsn if at all possible.</span>
<a name="l01798"></a>01798 <span class="comment"> * To further complicate matters, the page could have changed stores, </span>
<a name="l01799"></a>01799 <span class="comment"> * and thus its page type or store (logging) property could differ.</span>
<a name="l01800"></a>01800 <span class="comment"> * The details of this problem are handled in a function called determine_rec_lsn().</span>
<a name="l01801"></a>01801 <span class="comment"> *</span>
<a name="l01802"></a>01802 <span class="comment"> * \subsection PAGEWRITERMUTEX Page Writer Mutexes</span>
<a name="l01803"></a>01803 <span class="comment"> *</span>
<a name="l01804"></a>01804 <span class="comment"> * The buffer manager keeps a set of \e N mutexes to sychronizing the various</span>
<a name="l01805"></a>01805 <span class="comment"> * threads that can write pages to disk.  Each of these mutexes covers a</span>
<a name="l01806"></a>01806 <span class="comment"> * run of pages of size smlevel_0::max_many_pages. N is substantially smaller</span>
<a name="l01807"></a>01807 <span class="comment"> * than the number of "runs" in the buffer pool (size of </span>
<a name="l01808"></a>01808 <span class="comment"> * the buffer pool/max_many_pages), so each of the N mutexes actually covers</span>
<a name="l01809"></a>01809 <span class="comment"> * several runs:  </span>
<a name="l01810"></a>01810 <span class="comment"> * \code</span>
<a name="l01811"></a>01811 <span class="comment"> * page-writer-mutex = page / max_many_pages % N</span>
<a name="l01812"></a>01812 <span class="comment"> * \endcode</span>
<a name="l01813"></a>01813 <span class="comment"> *</span>
<a name="l01814"></a>01814 <span class="comment"> * \subsection BFSCAN Foreground Page Writes and Discarding Pages</span>
<a name="l01815"></a>01815 <span class="comment"> * Pages can be written to disk by "foreground" threads under several</span>
<a name="l01816"></a>01816 <span class="comment"> * circumstances.</span>
<a name="l01817"></a>01817 <span class="comment"> * All foreground page-writing goes through the method bf_m::_scan.</span>
<a name="l01818"></a>01818 <span class="comment"> * This is called for:</span>
<a name="l01819"></a>01819 <span class="comment"> * - discarding all pages from the buffer pool (bf_m::_discard_all)</span>
<a name="l01820"></a>01820 <span class="comment"> * - discarding all pages belonging to a given store from the buffer pool </span>
<a name="l01821"></a>01821 <span class="comment"> *   (bf_m::_discard_store), e.g., when a store is destroyed.</span>
<a name="l01822"></a>01822 <span class="comment"> * - discarding all pages belonging to a given volume from the buffer pool </span>
<a name="l01823"></a>01823 <span class="comment"> *   (bf_m::_discard_volume), e.g., when a volume is destroyed.</span>
<a name="l01824"></a>01824 <span class="comment"> * - forcing all pages to disk (bf_m::_force_all) with or without invalidating</span>
<a name="l01825"></a>01825 <span class="comment"> *   their frames, e.g., during clean shutdown.</span>
<a name="l01826"></a>01826 <span class="comment"> * - forcing all pages of a store to disk (bf_m::_force_store) with </span>
<a name="l01827"></a>01827 <span class="comment"> *   or without invalidating</span>
<a name="l01828"></a>01828 <span class="comment"> *   their frames, e.g., when changing a store's property from unlogged to</span>
<a name="l01829"></a>01829 <span class="comment"> *   logged.</span>
<a name="l01830"></a>01830 <span class="comment"> * - forcing all pages of a volume to disk (bf_m::_force_store) with </span>
<a name="l01831"></a>01831 <span class="comment"> *   without invalidating the frames, e.g., when dismounting a volume.</span>
<a name="l01832"></a>01832 <span class="comment"> * - forcing all pages whose recovery lsn is less than or equal to a given</span>
<a name="l01833"></a>01833 <span class="comment"> *   lsn_t, e.g.,  for a clean shutdown, after restart.</span>
<a name="l01834"></a>01834 <span class="comment"> */</span><span class="comment"></span>
<a name="l01835"></a>01835 <span class="comment">/**\page Logging </span>
<a name="l01836"></a>01836 <span class="comment"> *</span>
<a name="l01837"></a>01837 <span class="comment"> * See \ref LOG_M.</span>
<a name="l01838"></a>01838 <span class="comment"> * */</span>
<a name="l01839"></a>01839 <span class="comment"></span>
<a name="l01840"></a>01840 <span class="comment">/**\page DEBUGAID Debugging Aids</span>
<a name="l01841"></a>01841 <span class="comment">  *\section SSMDEBUGAPI Storage Manager Methods for Debugging</span>
<a name="l01842"></a>01842 <span class="comment"> *</span>
<a name="l01843"></a>01843 <span class="comment"> * The storage manager contains a few methods that are useful for</span>
<a name="l01844"></a>01844 <span class="comment"> * debugging purposes. Some of these should be used for not other</span>
<a name="l01845"></a>01845 <span class="comment"> * purpose, as they are not thread-safe, or might be very expensive.</span>
<a name="l01846"></a>01846 <span class="comment"> * See \ref SSMAPIDEBUG.</span>
<a name="l01847"></a>01847 <span class="comment"> * </span>
<a name="l01848"></a>01848 <span class="comment"> *\section SSMDEBUG Build-time Debugging Options</span>
<a name="l01849"></a>01849 <span class="comment"> *</span>
<a name="l01850"></a>01850 <span class="comment"> * At configure time, you can control which debugger-related options</span>
<a name="l01851"></a>01851 <span class="comment"> * (symbols, inlining, etc) with the debug-level options. See \ref CONFIGOPT.</span>
<a name="l01852"></a>01852 <span class="comment"> * \section SSMTRACE Tracing (--enable-trace)</span>
<a name="l01853"></a>01853 <span class="comment"> * When this build option is used, additional code is included in the build to</span>
<a name="l01854"></a>01854 <span class="comment"> * enable some limited tracing.  These C Preprocessor macros apply:</span>
<a name="l01855"></a>01855 <span class="comment"> * -W_TRACE</span>
<a name="l01856"></a>01856 <span class="comment"> *  --enable-trace defines this.</span>
<a name="l01857"></a>01857 <span class="comment"> * -FUNC</span>
<a name="l01858"></a>01858 <span class="comment"> *  Outputs the function name when the function is entered.</span>
<a name="l01859"></a>01859 <span class="comment"> * -DBG </span>
<a name="l01860"></a>01860 <span class="comment"> *  Outputs the arguments.</span>
<a name="l01861"></a>01861 <span class="comment"> * -DBGTHRD </span>
<a name="l01862"></a>01862 <span class="comment"> *  Outputs the arguments.</span>
<a name="l01863"></a>01863 <span class="comment"> *</span>
<a name="l01864"></a>01864 <span class="comment"> *  The tracing is controlled by these environment variables:</span>
<a name="l01865"></a>01865 <span class="comment"> *  -DEBUG_FLAGS: a list of file names to trace, e.g. "smfile.cpp log.cpp"</span>
<a name="l01866"></a>01866 <span class="comment"> *  -DEBUG_FILE: name of destination for the output. If not defined, the output</span>
<a name="l01867"></a>01867 <span class="comment"> *    is sent to cerr/stderr.</span>
<a name="l01868"></a>01868 <span class="comment"> *</span>
<a name="l01869"></a>01869 <span class="comment"> * See \ref CONFIGOPT.</span>
<a name="l01870"></a>01870 <span class="comment"> *  \note This tracing is not thread-safe, as it uses streams output.</span>
<a name="l01871"></a>01871 <span class="comment"> * \section SSMENABLERC Return Code Checking (--enable-checkrc)</span>
<a name="l01872"></a>01872 <span class="comment"> * If a w_rc_t is set but not checked with method is_error(), upon destruction the</span>
<a name="l01873"></a>01873 <span class="comment"> * w_rc_t will print a message to the effect "error not checked".</span>
<a name="l01874"></a>01874 <span class="comment"> * See \ref CONFIGOPT.</span>
<a name="l01875"></a>01875 <span class="comment"> *</span>
<a name="l01876"></a>01876 <span class="comment"> */</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Mon Jan 2 15:13:57 2012 for Shore Storage Manager by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
