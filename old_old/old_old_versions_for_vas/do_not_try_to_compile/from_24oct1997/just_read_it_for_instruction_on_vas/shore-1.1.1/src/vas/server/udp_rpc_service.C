/* --------------------------------------------------------------- */
/* -- Copyright (c) 1994, 1995 Computer Sciences Department,    -- */
/* -- University of Wisconsin-Madison, subject to the terms     -- */
/* -- and conditions given in the file COPYRIGHT.  All Rights   -- */
/* -- Reserved.                                                 -- */
/* --------------------------------------------------------------- */

#define __EFS_C__
static char *rcsid="$Header: /p/shore/shore_cvs/src/vas/server/udp_rpc_service.C,v 1.26 1996/07/23 22:42:50 nhall Exp $";


#define __malloc_h

#define THREADID <<" th."<<me()->id << " "

#include "efs.h"
#include "nfs.h"
#include <assert.h>
#include <debug.h>
#include "svas_error_def.h"
#include "os_error_def.h"
#include "udp_clients.h"
#include "udp_rpc_service.h"

BEGIN_EXTERNCLIST
	/* request dispatchers generated by rpcgen (see nfs_svc.c) */
	void nfs_program_2(struct svc_req *rqstp, SVCXPRT *transp);
	void mountprog_1(struct svc_req *rqstp, SVCXPRT *transp);

#if defined(SUNOS41)||defined(Ultrix42)
	int 	socket(int, int, int);
	int 	bind(int, const void *, int);
#endif

#ifdef HPUX8
	int 	socket(int, int, int);
#endif

#ifdef DEBUG
	void dumpaddrs(int sock, char *str);
#endif /*DEBUG*/

END_EXTERNCLIST


w_rc_t 	
svas_layer::configure_nfs_service()
{
	w_rc_t e;
	FUNC(svas_layer::configure_nfs_service);

	if(ShoreVasLayer.nfs_service) {
		// already configured
		return RC(OS_AlreadyExists);
	}
	udp_rpc_service *u =
		new udp_rpc_service("nfsd",
		NFS_PROGRAM, NFS_VERSION, nfs_program_2, 0);

	if(!u) {
		return RC(SVAS_MallocFailure);
	}

	ShoreVasLayer.nfs_service =  u;

	{
		w_rc_t rc =
		ShoreVasLayer.set_value_log_level(ShoreVasLayer.opt_nfsd_log_level,
							ShoreVasLayer.opt_nfsd_log_level->value(), &cerr);
		if(rc) return rc;
	}

	dassert(ShoreVasLayer.opt_nfsd_port != 0);
	return ShoreVasLayer.nfs_service->set_option_values(
		(unsigned short) (strtol(ShoreVasLayer.opt_nfsd_port->value(),0,0)),
		ShoreVasLayer.rpc_unregister,
		ShoreVasLayer.nfsd_pmap,
		ShoreVasLayer.opt_nfsd_log? ShoreVasLayer.opt_nfsd_log->value():0,
		ShoreVasLayer.nfsd_loglevel);
} 

w_rc_t
udp_rpc_service::_start()
{
	FUNC(udp_rpc_service::_start);
	int 	rpc_socket;
	int		prot;
	struct sockaddr_in addr;

	addr.sin_family = AF_INET;
	addr.sin_addr.s_addr = INADDR_ANY;
	addr.sin_port = htons(port);

#ifdef SOLARIS2
	rpc_socket = t_open("/dev/udp", O_RDWR, 0);
#else
	rpc_socket = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
#endif
	if (rpc_socket < 0) {
		perror("socket");
		return RC(errno);
	}

#ifdef SOLARIS2
	struct t_bind tb_args;
	tb_args.addr.maxlen = tb_args.addr.len = sizeof addr;
	tb_args.addr.buf = (char *)&addr;
	tb_args.qlen = 0;	// Doesn't apply to connection-less transport
	if (t_bind(rpc_socket, &tb_args, 0) < 0) {
		// TODO: what is the tli counterpart of SO_REUSEADDR?
		// TODO: deal with Address-in-use error
		perror("bind");
		return RC(errno);
	}
#else 
	// have to do this before it tries to bind
	if(ShoreVasLayer.reuseaddr) {
		set_sock_opt(rpc_socket, SO_REUSEADDR);
	}
	if (bind(rpc_socket, (struct sockaddr *)&addr, sizeof (addr)) < 0) {
		// TODO: deal with Address-in-use error
		perror("bind");
		return RC(errno);
	}
#endif

	// grot- not an ideal place to put this
	dassert(sizeof(efs_handle) <= NFS_FHSIZE);

	svcxprt = svcudp_create(rpc_socket);
	if (svcxprt == NULL) {
		// for now:
		catastrophic("Cannot create RPC/UDP service.");

		log->log(log_internal, "cannot create udp service\n");
		return RC(errno);
	}
#ifdef xxSOLARIS2
	rpc_socket = svcxprt->xp_sock;
	port = svcxprt->xp_port;
#else
    if ((port != 0) && (svcxprt->xp_port != port)) {
		DBG(
			<< "svcudp_create returns wrong port :"  << svcxprt->xp_port
			<< " requested port "  << port
		)
		catastrophic("Cannot create RPC/UDP service with correct port.");
	}
#endif

#ifdef DEBUG
	dumpaddrs(rpc_socket, "udp service socket");
#endif /*DEBUG*/

#ifndef SOLARIS2
#define EFSD_CACHE_SIZE 4
	if( !svcudp_enablecache(svcxprt, EFSD_CACHE_SIZE)  ) {
		log->log(log_internal, "cannot create udp cache of size %d\n", 
			EFSD_CACHE_SIZE);
		return RC(errno);
	}
#endif

	//
	// if the last argument (prot) to svc_register is 0,
	// the rpc pkg WON'T  register with YP/RPCINFO/PORTMAPPER--
	//

	prot = use_pmap ? IPPROTO_UDP : 0;
	
	{
		DBG(<<"svc_registering " << ::hex((unsigned int)svcxprt)
		<< " program = " << program 
		<< " version= " << version
		<< " port= " << port
		);
		if (!svc_register(svcxprt, program, version, prog_1, prot)) {
			DBG("svc_register failed once");
			bool failed = 1;
			if(force) {
				failed=0;
				// unregister and try again
				(void)svc_unregister(program, version);
				if (!svc_register(svcxprt, program, version, prog_1, 0)) {
					failed = 1;
				}
			}
			if(failed) {
				log->log(log_internal, "svc_register(%d,%d) for %s fails\n",
					program, version, name);
				return RC(SVAS_RpcFailure);
			}
		}
	}

	{
		bool			ok;

		bool			is_mountd; 

		// Grot--
		if(strcmp(name,"nfsd")==0) {
			is_mountd = false;
		} else {
			assert(strcmp(name,"mountd")==0);
			is_mountd = true;
		}

		/* fork a thread */

		DBG(<<"forking a thread for " << this->name << " port=" << port);

		// fork a thread to a request off the socket

		listenerthread = new nfs_client_t(
				this->name, rpc_socket, &ok, 
				is_mountd? ShoreVasLayer.mount_service->log :
					   ShoreVasLayer.nfs_service->log,
				this,
				is_mountd
			);
		if(!listenerthread || !ok) {
			listenerthread = 0;
			catastrophic ("Cannot fork an RPC/UDP thread.");
		}
		DBG(<<"forked thread id=" << listenerthread->id );
		W_COERCE(listenerthread->fork());
		// W_COERCE(listenerthread->wait());

	}
	return RCOK;
}

w_rc_t
udp_rpc_service::start(void *arg)
{
	FUNC(udp_rpc_service::start);
	udp_rpc_service *x = (udp_rpc_service *)arg;
	return x->_start();
}

w_rc_t
svas_layer::configure_mount_service()
{
	FUNC(svas_layer::configure_mount_service);

	if(ShoreVasLayer.mount_service) {
		// already configured
		return RC(OS_AlreadyExists);
	}
	DBG(<<"making new udp_rpc_service");
	ShoreVasLayer.mount_service  = new udp_rpc_service( "mountd",
		MOUNTPROG, MOUNTVERS, mountprog_1, 0);

	if(!ShoreVasLayer.mount_service) {
		return RC(SVAS_MallocFailure);
	}
	DBG(<<"Setting option values");

	{
		w_rc_t rc =
		ShoreVasLayer.set_value_log_level(ShoreVasLayer.opt_mountd_log_level,
							ShoreVasLayer.opt_mountd_log_level->value(), &cerr);
		if(rc) return rc;
	}

	dassert(ShoreVasLayer.opt_mountd_port != 0);
	return ShoreVasLayer.mount_service->set_option_values(
		(unsigned short) (strtol(ShoreVasLayer.opt_mountd_port->value(),0,0)),
		ShoreVasLayer.rpc_unregister,
		ShoreVasLayer.mountd_pmap,
		ShoreVasLayer.opt_mountd_log? ShoreVasLayer.opt_mountd_log->value():0,
		ShoreVasLayer.mountd_loglevel);
}

w_rc_t
udp_rpc_service::shutdown(void *arg)
{
	FUNC(udp_rpc_service::shutdown);
	udp_rpc_service *x = (udp_rpc_service *)arg;
	return x->_shutdown();
}

w_rc_t
udp_rpc_service::_shutdown() 
{
	FUNC(udp_rpc_service::_shutdown);

	// disable the file handler
	// and allow the thread to exit
	if(listenerthread) {
		DBG(<< " shutting down listener ");
		listenerthread->shutdown();
		W_COERCE(listenerthread->wait());
		delete listenerthread;
		listenerthread =0;
	}
	// unregister the service
	return _cleanup();
}
