# --------------------------------------------------------------- #
# -- Copyright (c) 1994, 1995 Computer Sciences Department,    -- #
# -- University of Wisconsin-Madison, subject to the terms     -- #
# -- and conditions given in the file COPYRIGHT.  All Rights   -- #
# -- Reserved.                                                 -- #
# --------------------------------------------------------------- #

#
#   $Header: /p/shore/shore_cvs/src/sm/logdef.dat,v 1.47 1997/05/02 22:19:13 nhall Exp $
#

#########################################################################
#									#
#	The format of the file is as follows:				#
#		type = log record type					#
#		X    = transaction log (generated by transactions)	#
#		S    = sync (not used unless OLD_LOG_FLUSH)		#
#		R    = redoable	(-->t_redo)				#
#		U    = undoable	(-->t_undo)				#
#		F    = format	UNUSED                                  #
#		A    = space-allocation;overrides no-log options on pg  #
#                      (does not override per-xct log switch control)   #
#		L    = logical log (don't need the page for undo)	#
#                      --> t_logical                                    # 
#		arg  = arguments to constructor				#
#									#
#########################################################################
# type			XSRUFAL	 arg					#
#########################################################################
comment		        1011001 (const char* msg);
compensate		1000001 (lsn_t  rec_lsn);
skip			0000000 ();
chkpt_begin		0000000 (const lsn_t &lastMountLSN);
chkpt_bf_tab		0000000	(int cnt, const lpid_t* pid,
					const lsn_t* rec_lsn);
chkpt_xct_tab		0000000	(const tid_t& youngest, 
					int cnt, const tid_t* tid, 
					const smlevel_1::xct_state_t* state,
					const lsn_t* last_lsn, 
					const lsn_t* undo_nxt);
chkpt_dev_tab		0000000	(int cnt, const char dev_name[][smlevel_0::max_devname+1],
					const vid_t* vid);

chkpt_end		0000000 (const lsn_t& master, const lsn_t& min_rec_lsn);
mount_vol		0010010	(const char *dev_name, const vid_t &vid);
dismount_vol		0010010	(const char *dev_name, const vid_t &vid);
#xct_abort		1000000	();
xct_freeing_space	1000000 ();
xct_end			1000000 ();
xct_prepare_st		1010000 (const gtid_t* g, const server_handle_t& h);
xct_prepare_lk		1010000 (int num, lock_mode_t mode, lockid_t* lks);
xct_prepare_alk		1010000 (int num, lockid_t* lks, lock_mode_t* modes);
xct_prepare_stores	1010000 (int num, const stid_t* stids);
xct_prepare_fi	  	1010000 (int numex, int numix, int numsix, int numextent, const lsn_t& first);
alloc_pages_in_ext	1011011	(const page_p& page, extnum_t idx, const Pmap& pmap);
free_pages_in_ext	1011011	(const page_p& page, extnum_t idx, const Pmap& pmap);
create_ext_list		1010011 (const page_p& page, const stid_t& stid, extnum_t prev, extnum_t next, extnum_t count, const extnum_t* list);
free_ext_list		1010011 (const page_p& page, const stid_t& stid, extnum_t head, extnum_t count);
set_ext_next		1010011 (const page_p& page, extnum_t ext, extnum_t new_next);
store_operation		1011011 (const page_p& page, const store_operation_param& op);
page_init		1010000 (const page_p& page);
page_link		1011000 (const page_p& page, shpid_t new_prev, 
					shpid_t new_next);
page_insert		1011000 (const page_p& page, int idx, int cnt,
					const cvec_t* vec);
page_remove		1011000 (const page_p& page, int idx, int cnt);
page_format		1011000 (const page_p& page, int idx, int cnt, const cvec_t* vec);
page_mark		1011000 (const page_p& page, int idx);
page_reclaim		1011000 (const page_p& page, int idx, 
					const cvec_t& vec);
page_splice		1011000 (const page_p& page, int idx, int start, 
					int len, const cvec_t& vec);
page_splicez		1011000 (const page_p& page, int idx, int start, 
					int len, int osave, int nsave, const cvec_t& vec);
page_set_byte		1011000	(const page_p& page, int idx, u_char old, u_char bits, int op);
page_set_bit		1011000	(const page_p& page, int idx, int bit);
page_clr_bit		1011000	(const page_p& page, int idx, int bit);
page_image		1010000 (const page_p& page);
btree_latch		1011000	(const page_p& page, bool unlatch);
btree_purge		1011001	(const page_p& page);
btree_insert		1011001 (const page_p& page, int idx, 
					const cvec_t& key, const cvec_t& el,
					bool unique);
btree_remove		1011001 (const page_p& page, int idx, 
					const cvec_t& key, const cvec_t& el,
					bool unique);
rtree_insert		1011001 (const page_p& page, int idx,
					const nbox_t& key, const cvec_t& el);
rtree_remove		1011001	(const page_p& page, int idx, 
					const nbox_t& key, const cvec_t& el);

# these should be controlled by #define USE_RDTREE in shore.def.
#rdtree_insert		1011001 (const page_p& page, int idx,
#					const rangeset_t& key, 
#					const cvec_t& el);
#rdtree_remove		1011001	(const page_p& page, int idx, 
#					const rangeset_t& key, 
#					const cvec_t& el);
