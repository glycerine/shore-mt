<!-- Warning: Do not edit this file. -->
<!-- It was created automatically by yam2html.pl 1.3  -->
<!-- on Mon Oct 27 09:40:54 CST 1997 from file mancxxlb/string.cxxlb -->
<!DOCTYPE HTML public "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<TITLE>
string(cxxlb) -- Shore Reference Manual
</TITLE>
<LINK REV="made" HREF="mailto:solomon@cs.wisc.edu">
</HEAD>

<BODY>

<!-- .so tmac.man.local -->
<H1><A NAME="HRR.0">
string, text - SDL string and text attribute types
</A></H1><HR>
<H1>
CONTENTS
</H1>
<UL>
<LI>
<A HREF="#HRR.1">SYNOPSIS</A>
</LI>
<LI>
<A HREF="#HRR.2">DESCRIPTION</A>
<UL>
<LI>
<A HREF="#HRR.2.1">Text Attributes</A>
</LI>
<LI>
<A HREF="#HRR.2.2">Memory-Areas</A>
</LI>
<LI>
<A HREF="#HRR.2.3">Modifying String Values</A>
</LI>
<LI>
<A HREF="#HRR.2.4">Examples</A>
</LI>
</UL>
</LI>
<LI>
<A HREF="#HRR.3">VERSION</A>
</LI>
<LI>
<A HREF="#HRR.4">SPONSORSHIP</A>
</LI>
<LI>
<A HREF="#HRR.5">COPYRIGHT</A>
</LI>
<LI>
<A HREF="#HRR.6">SEE ALSO</A>
</LI></UL><HR>
<H1><A NAME="HRR.1">SYNOPSIS</A></H1>
<BLOCKQUOTE><PRE>
// in SDL:
interface stg {
public:
    attribute string    astring;
    attribute string    stringarray[10];

};

// signature of C++ binding for string/text types
// (The public part of the class declarations for 
// string and text attributes.)
class sdl_string
{
 public:
    char get(size_t n) const;    // get n'th character
    void get(char *s) const;    // get copy of entire string
    void get(char *s, size_t from, size_t len) const; // get a range of bytes

    void set(size_t n, char c);    // set n'th character
    void set(const char *s); // s is null-terminated
    void set(const char *s, size_t from, size_t len); // set a range of bytes

    int strlen(void) const;    //length of currently stored string
    int blen() const;          // available space as binary data.

    // C Library style names for modifying the string
    const char *memcpy(const char *s, size_t len); 
    void    bcopy(const char *s, size_t len);

    // conversion to C string.
    operator const char *() const;

    // const void * conversion, for use with mem/bcopy routines.
    operator const void *() const;
    const char * operator=(const char *); // conversion from C string

    const char *strcpy(const char *s);
    const char *strcat(const char *s);

    int strcmp(const char *s) const; 
    int strcmp(const sdl_string &amp;string) const;

    int strncmp(const char *s, size_t len) const;
    int strncmp(const sdl_string &amp;string, size_t len) const;
};

</PRE></BLOCKQUOTE>
<HR>
<H1><A NAME="HRR.2">DESCRIPTION</A></H1>
<P>
The SDL 
 <em>string</em>
type is a variable length string for
use in the definition of SDL interface object types.  
<H2><A NAME="HRR.2.1">Text Attributes</A></H2>
<P>
The SDL 
 <em>text</em>
type is similar, and allows the same operations as the 
 <em>string</em>
type, but there may be at most one text attribute per SDL object.
The contents of the text attribute of a
<em>registered</em>
(named)
SDL object 
is visible as a Unix file through the Shore Server.
<P>
Attributes
of SDL objects declared as
 <em>string</em>
or
 <em>text</em>
can be read and written within
SDL/C++ programs as if
they were instances of a C++ class with the method signature shown
above.  
The C++ binding of the SDL string type is designed for
easy inter-operation with C-style null-terminated strings and
<tt>char *</tt>
pointers, and can be used with many of the functions 
described in 
<strong>string(3)</strong>
(declared in the header file
<tt>&lt;string.h&gt;.</tt>
)
<H2><A NAME="HRR.2.2">Memory-Areas</A></H2>
<P>
String attributes can be used to store a memory area
(an array of characters bounded by a count, not terminated by a null character).
String attributes can be used to store such an area by using one
of the
 <strong>memcpy</strong>
or
 <strong>bcopy</strong>
member functions described below.  
<P>
Use of string-style member functions
and memory-area member functions cannot be intermixed.
<H2><A NAME="HRR.2.3">Modifying String Values</A></H2>
<P>
The member functions that modify the value of a string attribute
allocate temporary storage as necessary
to store string or memory area values; the value of a string attribute
may be treated as a
<tt>const char *</tt>
pointer value in many contexts, but the  attribute
may only be modified through member functions of the string class.
<H2><A NAME="HRR.2.4">Examples</A></H2>
<P>
The following examples are base on use of an SDL C++ binding based
on the SDL object type definition 
<BLOCKQUOTE><PRE>
interface stg {
public:
    attribute string astring;
    attribute string    stringarray[10];
    attribute text   atext;
};
</PRE></BLOCKQUOTE>
and C++/SDL variable declarations
<BLOCKQUOTE><PRE>
Ref&lt;stg&gt; sref_val;
char *s;
char *s1, *s2;
size_t n;
size_t len;
int i;
char c;
</PRE></BLOCKQUOTE>

<P>
The 
 <strong>get</strong>
member functions retrieve character values from string attributes.
<BLOCKQUOTE><PRE>
    sref-&gt;astring.get(n);
    sref-&gt;astring.get((size_t)3);
</PRE></BLOCKQUOTE>
returns the value of the 
 <em>n</em>th
(and
 <em>3</em>rd)
character of the string, or 
 <em>null</em>
if the length of the string is 
less than
 <em>n</em>(3).

The statement
<BLOCKQUOTE><PRE>
    sref-&gt;astring.get(s);
</PRE></BLOCKQUOTE>
copies the entire string (including the terminating null) into the space addressed by  
 <em>s,</em>
while
<BLOCKQUOTE><PRE>
    sref-&gt;astring.get(s,n,len)
</PRE></BLOCKQUOTE>
copies 
 <em>len</em>
bytes starting at the 
 <em>i</em>th
character in the space addressed by 
 <em>s.</em>
The two statements
<BLOCKQUOTE><PRE>
    sref-&gt;astring.get(s, 0, sref-&gt;astring.strlen()+1)
    sref-&gt;astring.get(s)
</PRE></BLOCKQUOTE>
are equivalent.

<P>
The
 <strong>set</strong>
member functions change the string value or subranges of the string value:
<BLOCKQUOTE><PRE>
    sref.update()-&gt;astring.set(n,c);
</PRE></BLOCKQUOTE>
sets the value of the 
 <em>n</em>th
character of the string attribute to the
character
 <em>c,</em>
extending the length of the attribute as necessary
to accommodate the character (without regard to the
value of the argument
 <em>c,</em>
so using
 <strong>set</strong>
this way can leave you with a string that is
not null-terminated).
The statement
<BLOCKQUOTE><PRE>
    sref.update()-&gt;astring.set(s);
</PRE></BLOCKQUOTE>
copies the entire null-terminated string 
 <em>s</em>
into the string attribute, resetting
the length of the attribute. 
The function
<BLOCKQUOTE><PRE>
    sref.update()-&gt;astring.set(s,i,len)
</PRE></BLOCKQUOTE>
copies 
 <em>len</em>
bytes, starting at
 <em>s,</em>
into the portion of the string attribute 
that begins with the 
 <em>i</em>th
character of the attribute.
This can leave the attribute terminated
with a non-null character.
<P>
A string attribute can be used as a 
<tt>const char *</tt>
pointer, either by implicit coercion or by explicit casting. 
For example, a string attribute could be printed using 
 <strong>printf</strong>
by explicitly casting the reference to a 
<tt>const char *</tt>
value:
<BLOCKQUOTE><PRE>
    printf(&quot;astring: %s\n&quot;,(const char *)(sref-&gt;astring))
</PRE></BLOCKQUOTE>
Where a 
<tt>char *</tt>
pointer is required by context, this
conversion will be done implicitly, e.g.
<BLOCKQUOTE><PRE>
extern &quot;C&quot; long atoi(const char *);
    int nval = atoi(sref-&gt;astring);
</PRE></BLOCKQUOTE>
<P>
If a string attribute is uninitialized, or if it
has been set to NULL by an assignment operator, the value returned
by the
<tt>const char *</tt>
conversion operator will be NULL.
<P>
The function
 <strong>strlen,</strong>
as in the statement
<BLOCKQUOTE><PRE>
    sref-&gt;astring.strlen()
</PRE></BLOCKQUOTE>
returns the current length of the string 
attribute; this is similar to
<BLOCKQUOTE><PRE>
    strlen(sref-&gt;str.attr);
</PRE></BLOCKQUOTE>
except that the former 
cleanly handles
null-valued strings
by returning 0.  
The function
 <strong>blen</strong>
is equivalent to 
 <strong>strlen,</strong>
but does not check for nulls,
that is, if
a string attribute is used to store binary data, 
<BLOCKQUOTE><PRE>
    sref-&gt;astring.blen()
</PRE></BLOCKQUOTE>
will return the length of the memory area stored, ignoring 
embedded nulls.
<P>
The method
 <strong>strcpy</strong>
works as follows:
<BLOCKQUOTE><PRE>
    sref.update()-&gt;astring.strcpy(s2)
</PRE></BLOCKQUOTE>
copies string
 <em>s2</em>
to the string attribute
 <em>astring</em>
until the
null character has been copied.
Space is allocated as necessary.
This is equivalent to the operation
<BLOCKQUOTE><PRE>
    sref.update()-&gt;astring = s2;
</PRE></BLOCKQUOTE>
<P>
 <strong>Strcat</strong>works<strong>similarly:</strong>
<BLOCKQUOTE><PRE>
    sref.update()-&gt;astring.strcat(s2)
</PRE></BLOCKQUOTE>
appends a copy of string
 <em>s2</em>
to the end of the string attribute astring.
<P>
 <strong>Memcpy</strong>
and 
 <strong>bcopy</strong>
ignore the null characters:
<BLOCKQUOTE><PRE>
    sref.update()-&gt;astring.memcpy(s2,len)
    sref.update()-&gt;astring.bcopy(s2,len)
</PRE></BLOCKQUOTE>
copy
 <em>len</em>
bytes from memory at location s2 into the string attribute (starting
at the beginning of the attribute), and
sets the length to 
 <em>len.</em>
The difference between the two is that 
 <strong>memcpy</strong>
returns a pointer to the resulting string, whereas 
 <strong>bcopy</strong>
does not.
<P>
The functions
 <strong>strcmp</strong>
and
 <strong>strncmp</strong>
analogues to the 
<strong>string(3)</strong>
functions:
<BLOCKQUOTE><PRE>
    sref-&gt;astring.strcmp(s)
    sref-&gt;astring.strncmp(s, n)
</PRE></BLOCKQUOTE>
returns
In these examples,
<BLOCKQUOTE><PRE>
    sref-&gt;astring.strcmp(sref-&gt;stringarray[i])
    sref-&gt;astring.strncmp(sref-&gt;stringarray[i], n)
</PRE></BLOCKQUOTE>
the string attribute
 <em>astring</em>
and 
 <em>stringarray</em>
are compared. 
Integers greater than, 
equal to, or less than zero
are returned
when 
 <em>astring</em>
&gt;
 <em>stringarray,</em>
 <em>astring</em>
==
 <em>stringarray,</em>
and
 <em>astring</em>
&lt;
 <em>stringarray,</em>
respectively.
The function
 <strong>strncmp</strong>
compares at most
 <em>n</em>
characters.
<HR>
<H1><A NAME="HRR.3">VERSION</A></H1>
This manual page applies to Version 1.1.1 of the Shore software.
<HR>
<H1><A NAME="HRR.4">SPONSORSHIP</A></H1>
The Shore project is sponsored by the Advanced Research Project Agency, ARPA
order number 018 (formerly 8230), monitored by the U.S. Army Research
Laboratory under contract DAAB07-91-C-Q518.
<HR>
<H1><A NAME="HRR.5">COPYRIGHT</A></H1>
Copyright &#169; 1994, 1995, 1996, 1997,
Computer Sciences Department, University of
Wisconsin -- Madison. All Rights Reserved.
<HR>
<H1><A NAME="HRR.6">SEE ALSO</A></H1>
<A HREF="intro.cxxlb.html"><STRONG>intro(cxxlb)</STRONG></A>,
<A HREF="method.cxxlb.html"><STRONG>method(cxxlb)</STRONG></A>, 
<A HREF="ref.cxxlb.html"><STRONG>ref(cxxlb)</STRONG></A>,
and the
<A HREF="../sdlman/sdlman.html">Shore Data Language Reference Manual</A>
</BODY>
</HTML>
