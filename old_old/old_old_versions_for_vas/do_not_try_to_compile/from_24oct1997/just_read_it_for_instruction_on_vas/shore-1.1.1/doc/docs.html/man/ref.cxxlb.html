<!-- Warning: Do not edit this file. -->
<!-- It was created automatically by yam2html.pl 1.3  -->
<!-- on Mon Oct 27 09:40:54 CST 1997 from file mancxxlb/ref.cxxlb -->
<!DOCTYPE HTML public "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<TITLE>
ref(cxxlb) -- Shore Reference Manual
</TITLE>
<LINK REV="made" HREF="mailto:solomon@cs.wisc.edu">
</HEAD>

<BODY>

<!-- .so tmac.man.local -->
<H1><A NAME="HRR.0">
REF - pointer to Shore object
</A></H1><HR>
<H1>
CONTENTS
</H1>
<UL>
<LI>
<A HREF="#HRR.1">SYNOPSIS</A>
</LI>
<LI>
<A HREF="#HRR.2">DESCRIPTION</A>
</LI>
<LI>
<A HREF="#HRR.3">SEE ALSO</A>
</LI></UL><HR>
<H1><A NAME="HRR.1">SYNOPSIS</A></H1>
<BLOCKQUOTE><PRE>
// macros found in &lt;ShoreApp.h&gt;
class Ref&lt;T&gt;; 
class WRef&lt;T&gt;; 

// templates equivalent to the above macros 
template class Ref&lt;T&gt;; 
template class WRef&lt;T&gt;;
</PRE></BLOCKQUOTE>

<HR>
<H1><A NAME="HRR.2">DESCRIPTION</A></H1>

A C++ program's access to a Shore object of type
 <em>T</em>
is through the classes 
Ref&lt;T&gt; 
and 
WRef&lt;T&gt;,
equivalently, 
Ref&lt;T&gt;
and 
WRef&lt;T&gt;.
<P>
The form Ref&lt;T&gt; (template class Ref&lt;T&gt;) is for 
read-only access to objects.
Writable access is through the writable references,
WRef&lt;T&gt; (template class WRef&lt;T&gt;), which are derived
from Ref&lt;T&gt;, and thus inherit all the methods of REF(T). 
<P>
A writable reference to an object can be constructed
from a read-only reference:
<BLOCKQUOTE><PRE>
	Ref&lt;myInterfaceType&gt; r;	 

	Ref&lt;T&gt;::lookup(fname, r);
	if(r) {
		// r now points to the registered 
		// object with name fname 
		// and you can now invoke any const
		// methods of Ref&lt;T&gt;
	}

	WRef&lt;myInterfaceType&gt; w(r);
	// OR
	WRef&lt;myInterfaceType&gt; w = r;
	if(w) {
		// you can now invoke any non-const
		// methods of Ref&lt;T&gt;/WREF(T)
	}
</PRE></BLOCKQUOTE>
<P>
Creating a writable reference to an object
does not cause the object to be inspected,
or any of its access control information to be
queried.  Access to an object is checked only
when the reference is followed.
<P>
These templates are generated with the SDL language binding.
The public methods are describe in the manual pages listed below.
<HR>
<H1><A NAME="HRR.3">SEE ALSO</A></H1>
<A HREF="valid.cxxlb.html"><STRONG>valid(cxxlb)</STRONG></A>
<P>
The public methods of 
<tt>Ref&lt;T&gt;</tt>
are described in
<A HREF="assign.cxxlb.html"><STRONG>assign(cxxlb)</STRONG></A>,
<A HREF="construct.cxxlb.html"><STRONG>construct(cxxlb)</STRONG></A>,
<A HREF="create.cxxlb.html"><STRONG>create(cxxlb)</STRONG></A>,
<A HREF="create_xref.cxxlb.html"><STRONG>create_xref(cxxlb)</STRONG></A>,
<A HREF="destroy.cxxlb.html"><STRONG>destroy(cxxlb)</STRONG></A>,
<A HREF="equal.cxxlb.html"><STRONG>equal(cxxlb)</STRONG></A>,
<A HREF="fetch.cxxlb.html"><STRONG>fetch(cxxlb)</STRONG></A>,
<A HREF="flush.cxxlb.html"><STRONG>flush(cxxlb)</STRONG></A>,
<A HREF="get_lockmode.cxxlb.html"><STRONG>get_lockmode(cxxlb)</STRONG></A>,
<A HREF="get_loid.cxxlb.html"><STRONG>get_loid(cxxlb)</STRONG></A>,
<A HREF="get_type.cxxlb.html"><STRONG>get_type(cxxlb)</STRONG></A>,
<A HREF="is_resident.cxxlb.html"><STRONG>is_resident(cxxlb)</STRONG></A>,
<A HREF="lookup.cxxlb.html"><STRONG>lookup(cxxlb)</STRONG></A>,
<A HREF="method.cxxlb.html"><STRONG>method(cxxlb)</STRONG></A>,
<A HREF="update.cxxlb.html"><STRONG>update(cxxlb)</STRONG></A>
and
<A HREF="valid.cxxlb.html"><STRONG>valid(cxxlb)</STRONG></A>.
<P>
For information about the SDL compiler, see
<A HREF="sdl.sdl.html"><STRONG>sdl(sdl)</STRONG></A>.
<P>
For information about the SDL C++ language binding generator, see
<A HREF="sdlcxx.sdl.html"><STRONG>sdlcxx(sdl)</STRONG></A>.
</BODY>
</HTML>
