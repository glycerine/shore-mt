<!-- Warning: Do not edit this file. -->
<!-- It was created automatically by yam2html.pl 1.3  -->
<!-- on Mon Oct 27 09:41:09 CST 1997 from file manssm/smthread_t.ssm -->
<!DOCTYPE HTML public "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<TITLE>
smthread_t(ssm) -- Shore Reference Manual
</TITLE>
<LINK REV="made" HREF="mailto:solomon@cs.wisc.edu">
</HEAD>

<BODY>

<!-- .so tmac.man.local -->
<H1><A NAME="HRR.0">
smthread_t - SSM Thread Class

</A></H1><HR>
<H1>
CONTENTS
</H1>
<UL>
<LI>
<A HREF="#HRR.1">SYNOPSIS</A>
</LI>
<LI>
<A HREF="#HRR.2">DESCRIPTION</A>
<UL>
<LI>
<A HREF="#HRR.2.1">Methods pertinent to Transactions</A>
</LI>
</UL>
</LI>
<LI>
<A HREF="#HRR.3">ERRORS</A>
</LI>
<LI>
<A HREF="#HRR.4">EXAMPLES</A>
</LI>
<LI>
<A HREF="#HRR.5">VERSION</A>
</LI>
<LI>
<A HREF="#HRR.6">SPONSORSHIP</A>
</LI>
<LI>
<A HREF="#HRR.7">COPYRIGHT</A>
</LI>
<LI>
<A HREF="#HRR.8">SEE ALSO</A>
</LI></UL><HR>
<H1><A NAME="HRR.1">SYNOPSIS</A></H1>
<BLOCKQUOTE><PRE>

#include &lt;sm_vas.h&gt;  // which includes smthread.h

typedef void st_proc_t(void *);

class smthread_t : public sthread_t {
public:
    NORET			smthread_t(
	st_proc_t* 		    f,
	void* 		            arg,
	priority_t 		    priority = t_regular,
	bool 			    block_immediate = false, 
	bool 			    auto_delete = false,
	const char* 		    name = 0,
	long 			    lockto = WAIT_FOREVER);

    NORET			smthread_t(
	priority_t 		    priority = t_regular,
	bool 			    block_immediate = false, 
	bool 			    auto_delete = false,
	const char* 		    name = 0,
	long 			    lockto = WAIT_FOREVER);

    NORET			~smthread_t();

    virtual void 		run() = 0;
    
    void 			attach_xct(xct_t* x);
    void 			detach_xct(xct_t* x);
    xct_t* 			xct();
    const xct_t* 		const_xct() const;
    static smthread_t* 		me();

    // set and get lock_timeout value
    long 			lock_timeout() const;
    void 			lock_timeout(long i);

    /*
     *  These methods are used to verify than nothing is
     *  left pinned accidentally.  Call mark_pin_count before an
     *  operation and check_pin_count after it with the expected
     *  number of pins that should not have been released.
     */
    void 			mark_pin_count();
    void 			check_pin_count(int change);
    void 			check_actual_pin_count(int actual) ;
    void 			incr_pin_count(int amount) ;
   
    /*
     *  These methods are used to verify that a thread
     *  is only in one ss_m::, scan::, or pin:: function at a time.
     */
    void 			in_sm(bool in);
    bool 			is_in_sm() const;

private:
    void			user(); /* disabled sthread_t::user */
};


</PRE></BLOCKQUOTE>

<HR>
<H1><A NAME="HRR.2">DESCRIPTION</A></H1>

Class
 <strong>smthread_t</strong>
inherits from 
 <strong>sthread_t,</strong>
and extends it for use by the higher layers of the 
Shore Storage Manager.  Any thread calling methods
documented in
 <em>ssm</em>
section manual pages (see
<A HREF="intro.ssm.html"><STRONG>intro(ssm)</STRONG></A>
for a list) must be an
 <strong>smthread_t</strong>
or derived from it.

<P>
 <strong>sthread_t(priority, block_immediate, auto_delete, name, lock_timout)</strong>
<DL>
<PP>
See
<A HREF="sthread_t.sthread.html"><STRONG>sthread_t(sthread)</STRONG></A>
for details on the
 <em>priority,</em>
 <em>block_immediate,</em>
 <em>auto_delete</em>
and
 <em>name</em>
parameters.
The
 <em>lock_timout</em>
parameter specifies the default for how long a lock
request by the smthread should block before it times out.

<P>
</DL>
 <strong>run()</strong>
<DL>
<PP>
This method is the body of the thread.  See
<A HREF="sthread_t.sthread.html"><STRONG>sthread_t(sthread)</STRONG></A>
for more details.  Users must provide their own 
 <strong>run</strong>
method.

</DL>
<H2><A NAME="HRR.2.1">Methods pertinent to Transactions</A></H2>
<P>
Threads often run on behalf of a transaction, so there are
methods for associating a thread with a transaction.  
For more information on transactions, see
<A HREF="transaction.ssm.html"><STRONG>transaction(ssm)</STRONG></A>

<P>
 <strong>attach_xct(xct)</strong>
<DL>
<PP>
The
 <strong>attach_xct</strong>
method attaches the thread to transaction
 <em>xct.</em>
Any SSM operation, performed by this thread,
that requires transaction information will use the
 <em>xct</em>
transaction.  For example, all locks acquired by operations
will be for the 
 <em>xct</em>
transaction.
The 
 <strong>ss_m::begin_xct</strong>
method automatically calls 
 <strong>attach_xct.</strong>
It is a fatal error to call
 <strong>attach_xct</strong>
if the thread is already attached to a transaction.

<P>
</DL>
More than one thread can operate on behalf of a
given transaction at any time, but certain
transaction-related activities are serialized 
with a synchronization variable.  For example,
only one of the threads can be writing log records
for a top-level (compensated) operation at any time.
Another example of such serialization involves the
lock manager: if any single thread of a multi-threaded
transaction waits on a lock, all of the transaction's
threads that would block in the lock manager wait on 
the same lock (regardless what locks they are trying to 
acquire).

<P>
A VAS that attaches a transaction to more than one thread 
runs a high risk of getting latch-latch deadlocks among
threads.  It is the responsibility of the VAS to implement
its own protocol for avoiding these deadlocks.
An example of such a protocol is to allow threads of 
multi-threaded transactions
to work on non-overlapping partitions of the database.
<P>
It is also the responsibility of the VAS to see that
certain operations, including commit and abort,
are not attempted while a transaction
is attached to several threads.

<P>
 <strong>detach_xct(xct)</strong>
<DL>
<PP>
The
 <strong>detach_xct</strong>
method detaches the thread from transaction
 <em>xct.</em>
It is a fatal error if the thread is not already attached to
 <em>xct.</em>

<P>
</DL>
 <strong>xct()</strong>
<DL>
<PP>
The
 <strong>xct</strong>
method returns the transaction to which the thread is currently
attached.


</DL>
<HR>
<H1><A NAME="HRR.3">ERRORS</A></H1>

TODO

<HR>
<H1><A NAME="HRR.4">EXAMPLES</A></H1>

See
<A HREF="../ssmvas/ssmvas.html">Writing Value-Added Servers with the Shore Storage Manager</A>
for an example of how to use threads in a server.


<HR>
<H1><A NAME="HRR.5">VERSION</A></H1>
This manual page applies to Version 1.1.1 of the Shore software.
<HR>
<H1><A NAME="HRR.6">SPONSORSHIP</A></H1>
The Shore project is sponsored by the Advanced Research Project Agency, ARPA
order number 018 (formerly 8230), monitored by the U.S. Army Research
Laboratory under contract DAAB07-91-C-Q518.
<HR>
<H1><A NAME="HRR.7">COPYRIGHT</A></H1>
Copyright &#169; 1994, 1995, 1996, 1997,
Computer Sciences Department, University of
Wisconsin -- Madison. All Rights Reserved.

<HR>
<H1><A NAME="HRR.8">SEE ALSO</A></H1>

<A HREF="intro.sthread.html"><STRONG>intro(sthread)</STRONG></A>
<A HREF="sthread_t.sthread.html"><STRONG>sthread_t(sthread)</STRONG></A>
<A HREF="transaction.ssm.html"><STRONG>transaction(ssm)</STRONG></A>
<A HREF="lock.ssm.html"><STRONG>lock(ssm)</STRONG></A>

</BODY>
</HTML>
