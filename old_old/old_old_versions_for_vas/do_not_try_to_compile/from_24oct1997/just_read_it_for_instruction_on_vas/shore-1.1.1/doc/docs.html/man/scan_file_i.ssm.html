<!-- Warning: Do not edit this file. -->
<!-- It was created automatically by yam2html.pl 1.3  -->
<!-- on Mon Oct 27 09:41:08 CST 1997 from file manssm/scan_file_i.ssm -->
<!DOCTYPE HTML public "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<TITLE>
scan_file_i(ssm) -- Shore Reference Manual
</TITLE>
<LINK REV="made" HREF="mailto:solomon@cs.wisc.edu">
</HEAD>

<BODY>

<!-- .so tmac.man.local -->
<H1><A NAME="HRR.0">
scan_file_i - Classes for Scanning Files in the Shore Storage Manager
</A></H1><HR>
<H1>
CONTENTS
</H1>
<UL>
<LI>
<A HREF="#HRR.1">SYNOPSIS</A>
</LI>
<LI>
<A HREF="#HRR.2">DESCRIPTION</A>
<UL>
<LI>
<A HREF="#HRR.2.1">Constructors and Destructors</A>
</LI>
<LI>
<A HREF="#HRR.2.2">Scanning</A>
</LI>
<LI>
<A HREF="#HRR.2.3">CAVEAT</A>
</LI>
<LI>
<A HREF="#HRR.2.4">Other Member Functions</A>
</LI>
<LI>
<A HREF="#HRR.2.5">Updates While Scanning</A>
</LI>
<LI>
<A HREF="#HRR.2.6">Appending to a file</A>
</LI>
</UL>
</LI>
<LI>
<A HREF="#HRR.3">ERRORS</A>
</LI>
<LI>
<A HREF="#HRR.4">EXAMPLES</A>
</LI>
<LI>
<A HREF="#HRR.5">VERSION</A>
</LI>
<LI>
<A HREF="#HRR.6">SPONSORSHIP</A>
</LI>
<LI>
<A HREF="#HRR.7">COPYRIGHT</A>
</LI>
<LI>
<A HREF="#HRR.8">SEE ALSO</A>
</LI></UL><HR>
<H1><A NAME="HRR.1">SYNOPSIS</A></H1>
<BLOCKQUOTE><PRE>
#include &lt;sm_vas.h&gt;  // which includes scan.h

class scan_file_i {
public:
    NORET			scan_file_i(
	const lvid_t&amp;		    lvid, 
	const serial_t&amp; 	    fid,
	concurrency_t		    cc = t_cc_file,
	bool		            prefetch = false);

    NORET			scan_file_i(
	const lvid_t&amp;		    lvid,
	const serial_t&amp; 	    fid,
	const serial_t&amp; 	    start_rid,
	concurrency_t		    cc = t_cc_file,
	bool		            prefetch = false);

    NORET			~scan_file_i();
    
    rc_t			next(
	pin_i*&amp;			    pin_ptr,
	smsize_t		    start_offset, 
	bool&amp; 		    	    eof);

    rc_t			next_page(
	pin_i*&amp;			    pin_ptr,
	smsize_t 		    start_offset, 
	bool&amp; 		    	    eof);

    // logical serial # and volume ID of the file if created that way
    const serial_t&amp;		lfid() const;
    const lvid_t&amp;		lvid() const;
   
    void			finish();
    bool			eof();
    rc_t			error_code();
};

class append_file_i : public scan_file_i {
public:
    NORET			append_file_i(
	const lvid_t&amp;		    lvid, 
	const serial_t&amp; 	    fid
	);

    NORET			~append_file_i();
    
   rc_t                        create_rec(
        const vec_t&amp;                hdr,
        smsize_t                    len_hint,
        const vec_t&amp;                data,
        lrid_t&amp;                     lrid); // logical id

    rc_t                        create_rec(
        const vec_t&amp;                hdr,
        smsize_t                    len_hint,
        const vec_t&amp;                data,
        rid_t&amp;                      rid); // physical id

};

</PRE></BLOCKQUOTE>
<HR>
<H1><A NAME="HRR.2">DESCRIPTION</A></H1>
Class
 <em>scan_file_i</em>
supports iterating over the records in a file.
The scan is controlled by a 
 <em>scan_file_i</em>
object.
Multiple scans can be open at the same time.
<P>
Class
 <em>append_file_i</em>
allows a VAS to appending of records to a file in 
rapid succession.
The location of the end of the file is maintained by the 
 <em>append_file_i</em>object.
The constructor of the
 <em>append_file_i</em>
exclusively locks the file.
The effect of using more than one
 <em>append_file_i</em>
on a single file within a single transaction is undefined.

<P>
Each instance of 
 <em>scan_file_i</em>
and
 <em>append_file_i</em>
keeps a record pinned (and therefore, a page fixed)
throughout its existence. You must carefully
control the use of these classes to avoid
fixing all the pages in the buffer pool. 

<P>
The order in which records are visited by a scan is called
the
<em>scan order.</em>
There are two guarantees about scan order.  
<P>
The first
guarantee is that if two scans are performed on a file, the scan orders
will be identical as long as none of the following operations
occur between the two scans:
<strong>creating a</strong>
record in the file
<strong>destroying</strong>
a record in the file
<strong>changing the size </strong>
of a record in the file.
<P>
The second guarantee is that 
if a file is created using the 
<strong>append_file_i</strong>
class, and no updates are performed on the file or any of its records, the
scan order is identical to the order of record creation.

<H2><A NAME="HRR.2.1">Constructors and Destructors</A></H2>

<P>
 <strong>scan_file_i(lvid, fid, cc)</strong>
<P>
 <strong>scan_file_i(lvid, fid, start_rid, cc)</strong>
<DL>
<PP>
The
<strong>scan_file_i</strong>
constructors have a number of parameters in common.
The first two parameters, 
 <em>lvid</em>
and
 <em>fid</em>
specify the
<A HREF="lid.ssm.html">logical ID</A>
of the file to be scanned.  The 
 <em>cc</em>
parameter specifies the granularity of locks
acquired for
concurrency control.  
See
<A HREF="enum.ssm.html"><STRONG>enum(ssm)</STRONG></A>
for a description of the values.  
Here are the effects of the values for file scan:
<PP>
<strong>t_cc_none:</strong>
The file is IS (intention shared) locked, but no locks are obtained on any
pages or records in the file.
<PP>
<strong>t_cc_page:</strong>
<strong>t_cc_record:</strong>
Pages are SH locked; records are not locked.
Files are IS locked.
<PP>
<strong>t_cc_file:</strong>
The file is SH locked, so no finer granularity locks
are obtained.
<P>
</DL>
<DL>
<PP>
The starting location (record) of the scan can
be controlled using the optional
 <em>start_rid</em>
parameter.
<P>
</DL>
 <strong>append_file_i(lvid, fid)</strong>
<DL>
<PP>
The arguments to 
 <strong>append_file_i()</strong>
are as described above, for the
<strong>scan_file_i constructors.</strong>
<P>
</DL>
 <strong>~scan_file_i()</strong>
 <strong>~append_file_i()</strong>
<DL>
<PP>
These destructors unpin the current record, if any, and destroy the object.
To unpin the record before destroying the object, you may
explicitly call
 <strong>finish().</strong>

</DL>
<H2><A NAME="HRR.2.2">Scanning</A></H2>
<P>
 <strong>next(pin_ptr, start_offset, eof)</strong>
<DL>
<PP>
The
 <strong>next</strong>
method
is used to retrieve records from the scan and
(including the first).
A handle to the retrieved record 
made available through the
 <em>pin_ptr</em>
parameter.  See
<A HREF="pin_i.ssm.html"><STRONG>pin_i(ssm)</STRONG></A>
for information on using this handle.  The
 <em>start_offset</em>
parameter controls what part of the record to retrieve.
This parameter is passed directly to the
<A HREF="pin_i.ssm.html">pin_i</A>
constructor.  The
 <em>eof</em>
parameter will be set to
 <em>true</em>
only when no value can be retrieved.  So, if a file contains two
records and
 <em>next</em>
has been called twice,
 <em>eof</em>
will return
 <em>false</em>
on the second call, and
 <em>true</em>
on the third.


<P>
</DL>
 <strong>next_page(pin_ptr, start_offset, eof)</strong>
<DL>
<PP>
The
 <strong>next_page</strong>
method
advances the scan to the next disk page in the file and
returns a handle to the first record in the page.
Its parameters are identical to those of
 <strong>next.</strong>

</DL>
<H2><A NAME="HRR.2.3">CAVEAT</A></H2>
<P>
Do not unpin the record explicitly during a scan.

<H2><A NAME="HRR.2.4">Other Member Functions</A></H2>

The
 <strong>lfid</strong>
and
 <strong>lvid</strong>
methods return the logical ID of the file being scanned.
<P>
The
 <strong>finish</strong>
method unpins the current record and closes the scan.
<P>
The
 <strong>eof</strong>
method returns
 <em>true</em>
if the end of the file has been reached.
<P>
The
 <strong>error_code</strong>
method returns any error code generated by the
the scan member methods.  See the
<strong>ERRORS section for more information.</strong>

<H2><A NAME="HRR.2.5">Updates While Scanning</A></H2>
<P>
A common question is what is the effect of changes to a file (or
its records) made by a transaction that is also scanning the file.
In general, it is safest not to change anything in the file
while scanning.  Instead, a list of changes should be made during
the scan and only performed after the scan is complete.

<P>
However, there are a number of changes that can safely be made to
a file while scanning.  It is safe to:
<DL>
<PP>
Update any record in the file using
 <strong>update_rec</strong>
or 
 <strong>update_rec_hdr.</strong>
<PP>
Destroy any record in the file using
 <strong>destroy_rec,</strong>
including the current one (although the 
 <strong>pin_i</strong>
for the current record will no longer be valid.

<P>
</DL>
It is also safe to change the size of records using
 <strong>truncate_rec</strong>
or
 <strong>append_rec</strong>
and to create new records.  However, this may cause records
to be moved and therefore revisited or never visited during the
scan.

<H2><A NAME="HRR.2.6">Appending to a file</A></H2>
<P>
 <strong>Create_rec</strong>
in class
 <strong>append_file_i</strong>
appends a record to a file.  It is used much the same way
that the static
function
 <strong>ss_m::create_rec</strong>
is used, but appending to a file with
 <strong>append_file_i::create_rec</strong>is<strong>the</strong>more
efficient way to populate a file if many creations
are to be performed without other intervening operations
on the file, and it guarantees that new records are placed
at the end of the file.

<HR>
<H1><A NAME="HRR.3">ERRORS</A></H1>
A scan_file_i object remembers if an error has occured while
constructing the scan or while scanning.  An error that
occurs in constructing the scan (such as having a bad file ID),
can be detected by calling
 <strong>error_code.</strong>
Alternatively, the error can be detected on the first call to
 <strong>next</strong>
which will return the remembered error code.  Therefore, if an error
occurs while constructing or scanning, repeated calls
to next will all return the first error code and no progress
will be made on the scan.

<HR>
<H1><A NAME="HRR.4">EXAMPLES</A></H1>
To Do.

<HR>
<H1><A NAME="HRR.5">VERSION</A></H1>
This manual page applies to Version 1.1.1 of the Shore software.
<HR>
<H1><A NAME="HRR.6">SPONSORSHIP</A></H1>
The Shore project is sponsored by the Advanced Research Project Agency, ARPA
order number 018 (formerly 8230), monitored by the U.S. Army Research
Laboratory under contract DAAB07-91-C-Q518.
<HR>
<H1><A NAME="HRR.7">COPYRIGHT</A></H1>
Copyright &#169; 1994, 1995, 1996, 1997,
Computer Sciences Department, University of
Wisconsin -- Madison. All Rights Reserved.
<HR>
<H1><A NAME="HRR.8">SEE ALSO</A></H1>
<A HREF="pin_i.ssm.html"><STRONG>pin_i(ssm)</STRONG></A>,
<A HREF="file.ssm.html"><STRONG>file(ssm)</STRONG></A>,
<A HREF="scan_index_i.ssm.html"><STRONG>scan_index_i(ssm)</STRONG></A>,
<A HREF="intro.ssm.html"><STRONG>intro(ssm)</STRONG></A>,

</BODY>
</HTML>
