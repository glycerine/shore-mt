<!-- Warning: Do not edit this file. -->
<!-- It was created automatically by yam2html.pl 1.3  -->
<!-- on Mon Oct 27 09:40:56 CST 1997 from file manoc/process_options.oc -->
<!DOCTYPE HTML public "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<TITLE>
process_options(oc) -- Shore Reference Manual
</TITLE>
<LINK REV="made" HREF="mailto:solomon@cs.wisc.edu">
</HEAD>

<BODY>

<!-- .so tmac.man.local -->
<H1><A NAME="HRR.0">
process_options - customizing options

</A></H1><HR>
<H1>
CONTENTS
</H1>
<UL>
<LI>
<A HREF="#HRR.1">SYNOPSIS</A>
</LI>
<LI>
<A HREF="#HRR.2">DESCRIPTION</A>
</LI>
<LI>
<A HREF="#HRR.3">BUGS</A>
</LI>
<LI>
<A HREF="#HRR.4">VERSION</A>
</LI>
<LI>
<A HREF="#HRR.5">SPONSORSHIP</A>
</LI>
<LI>
<A HREF="#HRR.6">COPYRIGHT</A>
</LI>
<LI>
<A HREF="#HRR.7">SEE ALSO</A>
</LI></UL><HR>
<H1><A NAME="HRR.1">SYNOPSIS</A></H1>
<BLOCKQUOTE><PRE>

<TT>#include &lt;ShoreApp.h&gt;</TT>

main( int argc, char **argv,...)
{
    ...

    //
    // minimal required options handling ...
    // but don't do this if your program is called a.out
    // or anything with a &quot;.&quot; in its name.
    //
    //
    // The SH_DO macro (defined in Shore.h) checks return codes
    //
    SH_DO(Shore::init(argc, argv));

    // Results in options being processed thus:
    //
    // Shore::default_options(argc, argv) 
    // FILE: looks for .shoreconfig in . and then in ~
    // OPTIONS: names are shore.client.&lt;argv[0]&gt;.&lt;option-name&gt;

    // ...or...

    SH_DO(Shore::init(argc, argv, &quot;myprog&quot;));
    // overrides argv[0] with myprog so that
    // option names are shore.client.myprog.&lt;option-name&gt;
    // 
        
    // ...or...

    SH_DO(Shore::init(argc, argv, 0, &quot;.myrcfile&quot;));
    // overrides .shoreconfig with .myrcfile
    // so that it looks for .myrcfile in . and then in ~

    // rest of main()
    ... 
}

//
// OR... 
// less simple but a little bit more flexible...
//

shrc    my_options(option_group_t *o); 

main( int argc, ...)
{
    ...

    // this allows the application to add its
    // own options, to specify options class,
    // program name, name of file of commands, etc.

    char    *usage_string = &quot;usage: how-to-use-this-command&quot;;
    shrc    rc;    // return code
    option_group_t *options;

    rc = Shore::process_options( argc, argv,
        // type is always &quot;shore&quot;
        &quot;myclass&quot;,    // class of options
        &quot;myprogram&quot;,// program name 
                // - does not have to be argv[0]
                // options recognized will be those
                // of the form
                // shore.myclass.myprogram.&lt;option-name&gt;
                //
        &quot;.rcfile&quot;,    // file to search-- can be null
                // search for ./.rcfile, then ~/.rcfile

        usage_string,     // string to print if error
        my_options, // optional - can be 0
        &amp;options,   // return value returned here
        false         // I want to process arguments -h, -v
                    // here, using getopt()
        ); 

    if(rc){
         cerr &lt;&lt; &quot;Cannot process options:&quot; &lt;&lt; rc &lt;&lt; endl;
         exit (1);
    }
    // ... my own processing of the rest of the argv,
    // e.g., using getopt()

    SH_DO(Shore::init()); // short form of init, since
                         // options were already processed

    // rest of main()
    ... 
}

</PRE></BLOCKQUOTE>

<HR>
<H1><A NAME="HRR.2">DESCRIPTION</A></H1>
When you are writing an application, you might wish to use
the Shore options service, or you might handle your arguments
and options your own way.
Either way, your application program must provide the lower
layers of Shore with the means to discover what values are to
be used for the options that the Shore software uses.
The simplest way to do this is to
call the first form of the function
 <strong>process_options,</strong>
which calls the lower layers of Shore to establish
default values for all the options that have defaults,
and looks (in a file and on the command line) 
for values for those options.
If the given file name 
is a relative path name, 
the function
 <strong>process_options</strong>
looks 
in the current directory
and if no such file exists there, 
in the home directory (determined by 
<tt>$HOME ).</tt>
After processing the file,
it reads the command line as determined
by the first two arguments.
A detailed description of these methods
is in 
<A HREF="init.oc.html"><STRONG>init(oc)</STRONG></A>.
<P>
<strong>NB:</strong>
Your application must be called by a name that
does not include a period if you wish to
set any options with a file with the 4-part
command names.
For example,
<tt>a.out</tt>
does not work with the 4-part command names
but it does work with the wild-card command:
<BLOCKQUOTE><PRE>
*.option: value
</PRE></BLOCKQUOTE>
and 
<tt>a.out</tt>
is fine if you do not need to set any options because
the default values are satisfactory.
<P>
If you want your application to add its own options,
to specify the program class or program name for options,
or to read a configuration file other than 
that determined by
 <strong>Shore::default_options</strong>
(see
<A HREF="init.oc.html"><STRONG>init(oc)</STRONG></A>
for details),
or if you do not want the 
command-line arguments
 <em>-h</em>
and
 <em>-v</em>
to be processed by the lower layers of Shore,
you can have your 
<tt>main()</tt>
call the function
 <strong>process_options</strong>.
This
calls the lower layers of Shore to establish
default values for all the options that have defaults,
and
allows your program to create its own options.
This takes place 
before the
file and the command line are searched.
<P>
Each option has a name; its name is composed of four parts:
<BLOCKQUOTE><PRE>
type.class.program.option
</PRE></BLOCKQUOTE>
where
 <em>type</em>
is 
<tt>shore ,</tt>
 <em>class</em>
and
 <em>program</em>
are determined by the caller of 
 <strong>process_options</strong>,
and 
 <em>option</em>
is determined by the software layer that
creates the option.
<P>
When a file or command line is searched for option values,
the options are identified by their full 4-part names
or by pattern-matching expressions that include wild cards
('*' and '?').
<P>
For example, to set the option
<tt>shore.oo7.bench.configfile</tt>
to the value 
<tt>./script</tt>
in the program
<tt>bench,</tt>
the function
<tt>main()</tt>
in 
<tt>bench</tt>
calls
<BLOCKQUOTE><PRE>
    ... 
    Shore::process_options(argc, argv, &quot;oo7&quot;, &quot;bench&quot;,
        &quot;.oo7rc&quot;, usage_string, oo7_options, &amp;options, true)
</PRE></BLOCKQUOTE>
and the file
<tt>.oo7rc</tt>
can contain any of these lines:
<BLOCKQUOTE><PRE>
<tt>shore.oo7.bench.configfile: ./script</tt>
<tt>?.oo7.bench.configfile: ./script</tt>
<tt>shore.oo7.?.configfile: ./script</tt>
<tt>*.configfile: ./script</tt>
</PRE></BLOCKQUOTE>
<P>
The 
<tt>bench</tt>
program also has to add the option
<tt>configfile</tt>
to the list of options used by the lower layers of Shore.
This is done by providing a non-null seventh argument
to
 <strong>process_options.</strong>
<strong>Bench does this with its function</strong>
 <strong>oo7_options,</strong>which<strong>looks</strong>like<strong>this:</strong>

<BLOCKQUOTE><PRE>

shrc oo7_options(option_group_t *options)
{
    static option_t    *configfile_opt;
    shrc    e =
    options-&gt;add_option(
        &quot;configfile&quot;,  // 4th part of option name
        &quot;string&quot;,      // description of syntax of value
        &quot;-&quot;,           // default value
        &quot;name of configuration file&quot;, // meaning of option
        false,         // Boolean: is it a mandatory option?
        option_t::set_value_charstr, 
                       // function to check the syntax of the value
        configfile_opt // return value - ptr to an option_t
                       // that describes this option
    );
    return e;
}
 
</PRE></BLOCKQUOTE>
<P>
Finally, if you want even more control of the options
processing,  or if you want to take option values from the
command line,
you can use any of the functions
from the options service, found in 
<TT>#include &lt;option.h&gt;</TT>.
<HR>
<H1><A NAME="HRR.3">BUGS</A></H1>
The options service is not completely documented.
For more details, you'll have to look at the source
code for something that uses options, like the Shore Value-Added
Server or the oo7 example.
The file that sets up the options is 
<tt>svas_layer.C</tt>
and there is such a file in 
<tt>src/vas/client</tt>
and another in
<tt>src/vas/server.</tt>
Search for
<tt>add_option.</tt>
<HR>
<H1><A NAME="HRR.4">VERSION</A></H1>
This manual page applies to Version 1.1.1 of the Shore software.
<HR>
<H1><A NAME="HRR.5">SPONSORSHIP</A></H1>
The Shore project is sponsored by the Advanced Research Project Agency, ARPA
order number 018 (formerly 8230), monitored by the U.S. Army Research
Laboratory under contract DAAB07-91-C-Q518.
<HR>
<H1><A NAME="HRR.6">COPYRIGHT</A></H1>
Copyright &#169; 1994, 1995, 1996, 1997,
Computer Sciences Department, University of
Wisconsin -- Madison. All Rights Reserved.
<HR>
<H1><A NAME="HRR.7">SEE ALSO</A></H1>
<A HREF="init.oc.html"><STRONG>init(oc)</STRONG></A>,
<A HREF="options.oc.html"><STRONG>options(oc)</STRONG></A>,
and
<A HREF="options.svas.html"><STRONG>options(svas)</STRONG></A>
</BODY>
</HTML>
