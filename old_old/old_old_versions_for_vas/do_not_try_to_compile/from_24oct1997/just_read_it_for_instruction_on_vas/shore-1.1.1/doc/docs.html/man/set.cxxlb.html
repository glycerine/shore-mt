<!-- Warning: Do not edit this file. -->
<!-- It was created automatically by yam2html.pl 1.3  -->
<!-- on Mon Oct 27 09:40:54 CST 1997 from file mancxxlb/set.cxxlb -->
<!DOCTYPE HTML public "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<TITLE>
set(cxxlb) -- Shore Reference Manual
</TITLE>
<LINK REV="made" HREF="mailto:solomon@cs.wisc.edu">
</HEAD>

<BODY>

<!-- .so tmac.man.local -->
<H1><A NAME="HRR.0">
set, bag, sequence, array - set bag, sequence, and array attributes 
</A></H1><HR>
<H1>
CONTENTS
</H1>
<UL>
<LI>
<A HREF="#HRR.1">SYNOPSIS</A>
</LI>
<LI>
<A HREF="#HRR.2">DESCRIPTION</A>
</LI>
<LI>
<A HREF="#HRR.3">SET AND BAG OPERATIONS</A>
<UL>
<LI>
<A HREF="#HRR.3.1">Iterating over Sets and Bags</A>
</LI>
</UL>
</LI>
<LI>
<A HREF="#HRR.4">SEQUENCE OPERATIONS</A>
</LI>
<LI>
<A HREF="#HRR.5">ARRAY OPERATIONS</A>
</LI>
<LI>
<A HREF="#HRR.6">RESTRICTIONS</A>
</LI>
<LI>
<A HREF="#HRR.7">NOTE</A>
</LI>
<LI>
<A HREF="#HRR.8">VERSION</A>
</LI>
<LI>
<A HREF="#HRR.9">SPONSORSHIP</A>
</LI>
<LI>
<A HREF="#HRR.10">COPYRIGHT</A>
</LI>
<LI>
<A HREF="#HRR.11">SEE ALSO</A>
</LI></UL><HR>
<H1><A NAME="HRR.1">SYNOPSIS</A></H1>
<BLOCKQUOTE><PRE>
// in sdl:
interface a; // some object class definition
interface my_obj {
public:
    attribute set&lt;a&gt; a_set;
    attribute bag&lt;a&gt; a_bag;

    // sdl permits only sequences of values
    attribute sequence&lt;ref&lt;a&gt;&gt; a_seq;

    // variable-length sequence:
    attribute sequence&lt;long&gt; vseq;
    attribute sequence&lt;long, 3&gt; bounded_vseq;

    attribute long an_array[3];
};

// The C++ language binding for my_obj (with
// the private portion omitted):

class           my_obj:public sdlObj {
public:
    Set &lt; a &gt; a_set;
    Bag &lt; a &gt; a_bag;
    sdl_val_set_apply &lt; Ref &lt; a &gt; &gt;a_seq;
    sdl_val_set &lt; long &gt;vseq;
    sdl_val_set &lt; long &gt;bounded_vseq;
    long            an_array[3];
};


// signature of C++ bindings for sets, bags, and sequences:
// (The public potions of their class declarations.)

template &lt;class T&gt;
class Set
{
public:
    void add(const Ref&lt;T&gt;);
    void del(const Ref&lt;T&gt; &amp;arg); // delete the given elt
    Ref&lt;T&gt; delete_one(); // delete any elt and return it
    Ref&lt;T&gt; get_elt(int i) const;
    size_t get_size(); // size_t is defined in &lt;sys/types.h&gt;
    bool member(const Ref&lt;T&gt;  &amp;arg) const;
};

template &lt;class T&gt;
class Bag
{
public:
    void add(const Ref&lt;T&gt;);
    void del(const Ref&lt;T&gt; &amp;arg); // delete the given elt
    Ref&lt;T&gt; delete_one(); // delete any elt and return it
    Ref&lt;T&gt; get_elt(int i) const;
    size_t get_size(); // size_t is defined in &lt;sys/types.h&gt;
    bool member(const Ref&lt;T&gt;  &amp;arg) const;
};

// for sequences:

template &lt;class t&gt;
class Sequence {
public:
    size_t max_elements() const { return cur_size / sizeof(t); }
    int append_elt(const t &amp; new_elt); //initialized element
    int append_elt();    // uninitialized element
    void delete_elt(unsigned int i); 
    const t &amp; get_elt(unsigned int i) const;
    const t &amp; operator[] (unsigned int i) const;
    t &amp; write_elt(unsigned int i);
    size_t get_size() const; // returns number of elements
    void set_size(int i) ; // sets size absolutely
};


</PRE></BLOCKQUOTE>
<HR>
<H1><A NAME="HRR.2">DESCRIPTION</A></H1>
<P>
Sets, bags, and sequences are types that can be used
for 
<em>attributes</em>
of objects (SDL interfaces).
(The template classes that implement
sets, bags, or sequences,
are implementations for object attributes, and they cannot
be used for 
<em>transient</em>
data structures.)
<P>
The SDL set and bag types provide a mechanism for maintaining
a collection of references to Shore objects.
In the SDL source, the members, or elements of
sets and bags are declared to be object types 
(types declared as SDL interfaces);
the set or bag is implemented by reference.
That is, the set attribute stores a set of object references
and not copies of the objects.
Attributes
of SDL objects declared as type 
 <em>set&lt;T&gt;</em>
can be accessed  within
SDL/C++ programs as if
they were instances of the C++ template class 
 <em>Set&lt;T&gt;</em>
with the method signature shown above.  
The only difference between 
 <em>set&lt;T&gt;</em>
and 
 <em>bag&lt;T&gt;</em>
is that an instance
of 
 <em>set&lt;T&gt;</em>
never contains more than one reference to a particular
object of type 
 <em>T;</em>
an attribute of type 
 <em>bag&lt;T&gt;</em>
may contain any number
of references to the same object.  
That is, sets never contain
duplicate references, while bags may contain duplicates.
<P>
The SDL sequence type can be used to provide a variable-length array
abstraction within an SDL object.  
If an attribute is
declared as sequence&lt;T&gt;, values can be appended to the end
of the sequence and elements within the sequence can be accessed
using a simple integer index as their location within the sequence.
Unlike sets and bags, sequences store elements by value, not by
references; therefore, the type parameter of a sequence type
may not be an object (interface) type.
The declaration of a sequence attribute may include
an upper bound on the length of the sequence, which allows
the language binding to use an alternative, possibly more efficient, 
implementation for sequences when a bound is known.
(The language binding illustrated here does not do so.)
<P>
The SDL array type is a fixed-length array.
<P>
In what follows, we assume bindings for the following SDL definitions
in the synopsis above.
We also assume the following C++/SDL variable declarations:
<BLOCKQUOTE><PRE>
Ref&lt;a&gt; a_ref;
Ref&lt;my_obj&gt; o_ref;
</PRE></BLOCKQUOTE>
<HR>
<H1><A NAME="HRR.3">SET AND BAG OPERATIONS</A></H1>
<P>
The 
 <strong>add</strong>
method inserts a reference of the correct type into the given
set:
<BLOCKQUOTE><PRE>
    o_ref.update()-&gt;a_set.add(a_ref);
</PRE></BLOCKQUOTE>
adds the reference 
 <em>a_ref</em>
to the 
 <em>a_set</em>
attribute of the object to which
the variable 
 <em>o_ref</em>
refers.
<P>
To remove an element, use
 <strong>del:</strong>
<BLOCKQUOTE><PRE>
    o_ref.update()-&gt;a_set.del(a_ref);
    o_ref.update()-&gt;a_bag.del(a_ref);
</PRE></BLOCKQUOTE>
deletes any reference to the element
 <em>a_ref</em>
or the first value matching 
 <em>a_ref</em>
(for bags). 
If no matching reference is found within the set/bag, the operation
has no effect.
<P>
To delete and return elements one at a time, use 
 <strong>delete_one:</strong>
<BLOCKQUOTE><PRE>
    a_ref = o_ref.update()-&gt;a_set.delete_one();
</PRE></BLOCKQUOTE>
deletes one element of a set, and returns a ref to the element
deleted; the element chosen for deletion is based on efficiency
considerations.
<P>
The 
 <strong>get_size</strong>
function returns the number of elements in the set or bag.


<P>
The method
 <strong>member</strong>
returns 
 <em>true</em>
if the given element
is a member of the set or bag,
 <em>false</em>
otherwise.
<H2><A NAME="HRR.3.1">Iterating over Sets and Bags</A></H2>
<P>
A simple idiom for iterating though the elements of a set or bag is
is to increment a parameter to 
 <strong>get_elt</strong>
until a null reference is returned, as shown below.
<BLOCKQUOTE><PRE>
    int i;
    for (a_ref = o_ref-&gt;a_bag.get_elt(i=0);
        a_ref != NULL;
        a_ref = o_ref-&gt;a_bag.get_elt(++i))
    {
        // do something with a_ref
    }
</PRE></BLOCKQUOTE>
The 
 <strong>get_elt</strong>
function returns a reference to the 
 <em>i</em>th
element of the set,
numbered from 0 to n-1, where n-1 is the value returned by
 <strong>get_size;</strong>
if the parameter is out of range for the set, a null value is
returned.
If an application inserts
or deletes members while iterating
in this fashion, the results are not defined.
<P>
This interface is likely to change in a future release,
to provide a more set-like mechanism for iteration.

<HR>
<H1><A NAME="HRR.4">SEQUENCE OPERATIONS</A></H1>
<P>
Sequence attributes have operations similar to sets and bags, but
they store values, not references to objects.  
Object types (interfaces) may not be used
as the element type in a sequence declaration.
<P>
Sequence attributes are initially empty.  
In this respect, even those declared with an upper bound differ 
from fixed-length arrays.
<P>
A sequence may be extended, one element at a time, using 
 <strong>append_elt.</strong>
Two overloaded variants are provided, both of which
return the index of the new element.
If the parameterless variant is called, 
the new element is uninitialized.   
If a parameter of the sequence element type is provided, the value 
of the parament is used to initialize the new sequence element.
<BLOCKQUOTE><PRE>
	int i;
    i = o_ref.update()-&gt;a_seq.append_elt();  // uninitialized
    i = o_ref.update()-&gt;a_seq.append_elt(a_ref); 

    i = o_ref.update()-&gt;vseq.append_elt();  // uninitialized
    i = o_ref.update()-&gt;vseq.append_elt(2);  
</PRE></BLOCKQUOTE>
<P>
Random access to the elements
of a sequence is made with an integer
index (with origin 0). 
The function
 <strong>get_elt</strong>
returns a const C++ reference to the 
 <em>i</em>th
element of the sequence,
that is, it allows read only access to the element.
The member function
 <strong>operator[]</strong>
is semantically identical to 
 <strong>get_elt.</strong>
<P>
The method
 <strong>write_elt</strong>
returns a non-const C++ reference to the 
 <em>i</em>th
element; this form
may be used to update an element of a sequence in place.
 <strong>Get_size</strong>
returns the number of elements in the sequence, and
 <strong>set_size</strong>
changes the number of elements in the sequence.
If 
set_size
causes a sequence to increase in size, the new elements
are not initialized.
<P>
Elements may be deleted from a sequence using 
 <strong>delete_elt,</strong>
which removes the 
 <em>i</em>th
element from the sequence:
<BLOCKQUOTE><PRE>
    long i;
    if(o_ref-&gt;a_seq.get_size() == 2) {
        // these 2 are identical :
        a_ref = o_ref-&gt;a_seq.get_elt(0);
        a_ref = o_ref-&gt;a_seq[0];

        o_ref.update()-&gt;a_seq.delete_elt(0); // renumbers element [1] to [0]
        o_ref.update()-&gt;a_seq.delete_elt(0); // removes what was element [1]
    }

    // Similarly:
    if(o_ref-&gt;vseq.get_size() == 2) {
        // these 2 are identical :
        i = o_ref-&gt;vseq.get_elt(0);
        i = o_ref-&gt;vseq[0];

        o_ref.update()-&gt;vseq.delete_elt(0); // renumbers element [1] to [0]
        o_ref.update()-&gt;vseq.delete_elt(0); // removes what was element [1]
    }
</PRE></BLOCKQUOTE>
This results in the renumbering of the elements
in the sequence that follow the one deleted.
If any of the functions
 <strong>write_elt,</strong>
 <strong>operator[],</strong>
or
 <strong>get_elt</strong>
tries to access an element beyond the range of the sequence, 
the first element in the sequence is returned, since there
is no way to return a &quot;null&quot; value.
It is up to the application program to check the validity of
indexes prior to using them.

<HR>
<H1><A NAME="HRR.5">ARRAY OPERATIONS</A></H1>
<P>
The language binding for an array attribute is straightforward:
it is an array of the type seen in the SDL declaration.
Access to the values is as expected for any array:
<BLOCKQUOTE><PRE>
    long i;
    o_ref.update()-&gt;an_array[0] = 1; 
    i = o_ref-&gt;an_array[0]; 
</PRE></BLOCKQUOTE>
The application must
explicitly initialize the elements of an array.

<HR>
<H1><A NAME="HRR.6">RESTRICTIONS</A></H1>

There isn't any way to define operator==() in SDL; 
thus set elements are 
restricted to primitive types (e.g. long, float, etc.) or
references to objects (interface) types.

<HR>
<H1><A NAME="HRR.7">NOTE</A></H1>
The implementation of sets, bags, and sequences is
somewhat simplistic; this implementation
will likely be superseded by an implementation
based on the C++ Standard Template Library.

<HR>
<H1><A NAME="HRR.8">VERSION</A></H1>
This manual page applies to Version 1.1.1 of the Shore software.
<HR>
<H1><A NAME="HRR.9">SPONSORSHIP</A></H1>
The Shore project is sponsored by the Advanced Research Project Agency, ARPA
order number 018 (formerly 8230), monitored by the U.S. Army Research
Laboratory under contract DAAB07-91-C-Q518.
<HR>
<H1><A NAME="HRR.10">COPYRIGHT</A></H1>
Copyright &#169; 1994, 1995, 1996, 1997,
Computer Sciences Department, University of
Wisconsin -- Madison. All Rights Reserved.
<HR>
<H1><A NAME="HRR.11">SEE ALSO</A></H1>
<A HREF="intro.cxxlb.html"><STRONG>intro(cxxlb)</STRONG></A>,
<A HREF="intro.oc.html"><STRONG>intro(oc)</STRONG></A>,
<A HREF="method.cxxlb.html"><STRONG>method(cxxlb)</STRONG></A>,
<A HREF="index.cxxlb.html"><STRONG>index(cxxlb)</STRONG></A>,
<A HREF="ref.cxxlb.html"><STRONG>ref(cxxlb)</STRONG></A>,
and the 
<A HREF="../sdlman/sdlman.html">Shore Data Language Reference Manual</A>
</BODY>
</HTML>
