<!-- Warning: Do not edit this file. -->
<!-- It was created automatically by yam2html.pl 1.3  -->
<!-- on Mon Oct 27 09:41:00 CST 1997 from file mansvas/errors.svas -->
<!DOCTYPE HTML public "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<TITLE>
errors(svas) -- Shore Reference Manual
</TITLE>
<LINK REV="made" HREF="mailto:solomon@cs.wisc.edu">
</HEAD>

<BODY>

<!-- .so tmac.man.local -->
<H1><A NAME="HRR.0">
errors - errors returned by Shore Value-Added Server
</A></H1><HR>
<H1>
CONTENTS
</H1>
<UL>
<LI>
<A HREF="#HRR.1">SYNOPSIS</A>
</LI>
<LI>
<A HREF="#HRR.2">DESCRIPTION</A>
</LI>
<LI>
<A HREF="#HRR.3">VERSION</A>
</LI>
<LI>
<A HREF="#HRR.4">SPONSORSHIP</A>
</LI>
<LI>
<A HREF="#HRR.5">COPYRIGHT</A>
</LI>
<LI>
<A HREF="#HRR.6">SEE ALSO</A>
</LI></UL><HR>
<H1><A NAME="HRR.1">SYNOPSIS</A></H1>
<BLOCKQUOTE><PRE>

typedef int  VASResult;

enum TxStatus { Stale, Active, Prepared, Aborting, 
				Committing, Ended, NoTx };

enum error_type { ET_USER=0x1, ET_VAS=0x2, ET_FATAL=0x4000 };

struct Status {
    int         vasresult;
    int         vasreason;
    int         smresult;
    int         smreason;
    int         unixreason;
    TxStatus    txstate;
};
 
void            shore_vas::perr(
                    const char *message,
                    int         line = -1, // not printed if &lt;0
                    const char *filename=0,// not printed if null
					error_type  ekind = ET_VAS // not printed if 
						// ekind == ET_USER and !this-&gt;printusererrors
                ) const;

void            shore_vas::perr(
                    ostream &amp;out,
                    const char *message,
                    int         line = -1, // not printed if &lt;0
                    const char *filename=0,// not printed if null
					error_type  ekind = ET_VAS // not printed if 
						// ekind == ET_USER and !this-&gt;printusererrors
                ) const;

static const char*  p_status(unsigned int x);
static bool         unp_status(const char *msg, unsigned int *res) ;


</PRE></BLOCKQUOTE>
<HR>
<H1><A NAME="HRR.2">DESCRIPTION</A></H1>
Each function (method) in the Shore Value-Added Server class
returns either
SVAS_OK 
(zero),
SVAS_FAILURE
(non-zero), or
SVAS_WARNING
(non-zero).
In general, 
return values of functions (through output arguments) are not valid unless
the function returns
SVAS_OK.
If the function returns SVAS_FAILURE or SVAS_WARNING,
the 
 <em>status</em>
member indicates the reason for the failure.
The reason can be a condition discovered by the SVAS, 
or it might have been a failure discovered by a lower level,
such as the operating system or the Storage Manager.
<P>
If the condition is discovered by the SVAS, 
 <em>status.vasresult</em>
is SVAS_FAILURE or SVAS_WARNING,
 <em>status.vasreason</em>
has a value from the list below,
and the fields
 <em>status.smresult,</em>
 <em>status.smreason,</em>
 <em>status.osreason</em>
have the value zero.
<P>
If the condition is discovered by the Storage Manager,
 <em>status.vasresult</em>
is SVAS_FAILURE or SVAS_WARNING,
 <em>status.vasreason</em>
has the value SVAS_SmFailure,
and the fields
 <em>status.smresult,</em>
 <em>status.smreason,</em>
 <em>status.osreason</em>
have nonzero values, which indicate the reason for 
the problem.
<P>
The field 
 <em>status.osreason</em>
takes its values from the list found in 
 <tt>&lt;errno.h&gt;</tt>.
<P>
The functions 
 <strong>perr(...)</strong>
can be called to print a message that interprets the SVAS's
 <em>status</em>
member.
The 
 <em>message</em>
argument is any string that the caller wishes to be printed
along with the interpretive messages (similar to the C library's
 <strong>perror()</strong>
).
<P>
The function 
 <strong>p_status</strong>
interprets its argument as a candidate for 
<em>status.vasreason,</em>
and if the value is one of those that the SVAS can
return in the circumstance of an error,
 <strong>p_status</strong>
returns the string name of the error condition.
<P>
The function 
 <strong>unp_status</strong>
converts a string name to an integer error code.
If the string is associated with an error condition,
the integer error code is returned in 
 <em>*res,</em>
and the Boolean value TRUE is returned.
If the string is not associated with any error condition,
the Boolean value FALSE is returned and
 <em>*res,</em>
is unchanged.
<BLOCKQUOTE><PRE>
SVAS_WARNING 
SVAS_FAILURE 
SVAS_OK 
SVAS_NotImplemented - function or feature isn't implemented yet
SVAS_TxNotAllowed - this method cannot be called inside a transaction
SVAS_TxRequired - this method must be called inside a transaction
SVAS_Missing - object with the given OID does not exist
SVAS_Already - function has already been completed (e.g., format)
SVAS_CantFormat - volume cannot be formatted
SVAS_SmFailure - Storage Manager discovered an error
SVAS_RpcFailure - network failure, server crashed
SVAS_WrongObjectType - tried to use an object as if it were
    a type other than what it is
SVAS_NotFound - could not find object with the given path name
SVAS_BadParam1 - problem with first argument to method
SVAS_BadParam2 - problem with second argument to method
SVAS_BadParam3 - problem with third argument to method
SVAS_BadParam4 - problem with fourth argument to method
SVAS_BadParam5 - problem with fifth argument to method
SVAS_BadParam6 - problem with sixth argument to method
SVAS_BadParam7 - problem with seventh argument to method
SVAS_BadParam8 - problem with eighth argument to method
SVAS_BadParam9 - problem with ninth argument to method
SVAS_InUse - volume cannot be unmounted because it is in use
    by some user
SVAS_TxNotActive - the current transaction was not found to be
    in the active state, as expected. 
SVAS_MallocFailure - internal error: server could not malloc space
SVAS_BadRange - the given range of bytes is inappropriate for the 
    object being read or written 
SVAS_IntegrityBreach - the integrity of the type system has been compromised,
    or would be compromised if this were to completed and the 
    transaction were to commit
SVAS_IndexScanIsOpen - this function cannot be invoked during an index scan
SVAS_PoolScanIsOpen - this function cannot be invoked during a pool scan
SVAS_ScanNotInProgress - a scan must be opened before this function can
    be invoked
SVAS_CantChangeCoreSize - an attempt to truncate an object would have
    removed part of the object's core. 
SVAS_NotAPool - this function applies to a pool, and the object
    given is not a pool
SVAS_BadPathSyntax - the string given does not have proper syntax
    for a pathname
SVAS_BadFileNameSyntax - the string given does not have proper
    syntax for a file name
SVAS_IsAnonymous - the object referenced is anonymous; the function
    applies to registered objects
SVAS_VolumesDontMatch - an attempt to create an object with a given,
    preallocated OID failed because the OID was created on a volume
    different from the volume on which the pool resides.
SVAS_XdrError - the object could not be byte-swapped
SVAS_ShmError - the SVAS could not allocate or attach shared memory
SVAS_InternalError - unspecified internal error
SVAS_BadType - an attempt to operate on the object's type object
    failed, possibly because the type object's OID is bad
SVAS_AuthenticationFailure - could not authenticate the client to the server
SVAS_UnixFailure - a failure was returned from a Unix library function,
    such as getpwuid()
SVAS_BadSerial - this is an internal error
SVAS_UserAbort - the reason for aborting the transaction is that 
    the user (caller, client, application) requested it
SVAS_NotMounted -  the directory requested is not on a mounted file system
SVAS_NotADirectory - this function applies to directories; the object
    named is not a directory
SVAS_IsADirectory - this function does not apply to directories; the object
    named is a directory
SVAS_NotEmpty - an attempt to remove something failed because the 
    object was not empty (e.g., a directory)
SVAS_NotOwner - you have to be the owner of the object to do this
SVAS_PermissionDenied - you don't have the necessary permission 
    (read/write/execute) to do this
SVAS_ReadOnlyFS - an attempt to update an object failed because the
    object resides on a read-only file system
SVAS_TooManySymlinks - while expanding symbolic links during path 
    -resolution, too many symbolic links were encountered (possibly a loop) 
SVAS_TooManyLinks - an attempt to create a hard link to an object failed
    - because the maximum number of links per object was reached
SVAS_PathTooLong - after expansion of symbolic links, the pathname
    exceeds the maximum length permitted 
SVAS_CrossDeviceRef - you cannot make cross-references  or links across 
    devices (volumes, file system)
SVAS_AlreadyExists - an attempt to create an object with a pre-allocated
    OID failed because there is already an object with that OID
SVAS_BadAddress - the caller gave an invalid address for an argument
</PRE></BLOCKQUOTE>
<HR>
<H1><A NAME="HRR.3">VERSION</A></H1>
This manual page applies to Version 1.1.1 of the Shore software.
<HR>
<H1><A NAME="HRR.4">SPONSORSHIP</A></H1>
The Shore project is sponsored by the Advanced Research Project Agency, ARPA
order number 018 (formerly 8230), monitored by the U.S. Army Research
Laboratory under contract DAAB07-91-C-Q518.
<HR>
<H1><A NAME="HRR.5">COPYRIGHT</A></H1>
Copyright &#169; 1994, 1995, 1996, 1997,
Computer Sciences Department, University of
Wisconsin -- Madison. All Rights Reserved.
<HR>
<H1><A NAME="HRR.6">SEE ALSO</A></H1>
<A HREF="transaction.svas.html"><STRONG>transaction(svas)</STRONG></A>.
</BODY>
</HTML>
