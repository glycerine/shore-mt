<!-- Warning: Do not edit this file. -->
<!-- It was created automatically by yam2html.pl 1.3  -->
<!-- on Mon Oct 27 09:41:08 CST 1997 from file manssm/scan_index_i.ssm -->
<!DOCTYPE HTML public "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<TITLE>
scan_index_i(ssm) -- Shore Reference Manual
</TITLE>
<LINK REV="made" HREF="mailto:solomon@cs.wisc.edu">
</HEAD>

<BODY>

<!-- .so tmac.man.local -->
<H1><A NAME="HRR.0">
scan_index_i - Class for Scanning B+tree Indexes

</A></H1><HR>
<H1>
CONTENTS
</H1>
<UL>
<LI>
<A HREF="#HRR.1">SYNOPSIS</A>
</LI>
<LI>
<A HREF="#HRR.2">DESCRIPTION</A>
<UL>
<LI>
<A HREF="#HRR.2.1">Updates While Scanning</A>
</LI>
</UL>
</LI>
<LI>
<A HREF="#HRR.3">ERRORS</A>
</LI>
<LI>
<A HREF="#HRR.4">EXAMPLES</A>
</LI>
<LI>
<A HREF="#HRR.5">VERSION</A>
</LI>
<LI>
<A HREF="#HRR.6">SPONSORSHIP</A>
</LI>
<LI>
<A HREF="#HRR.7">COPYRIGHT</A>
</LI>
<LI>
<A HREF="#HRR.8">SEE ALSO</A>
</LI></UL><HR>
<H1><A NAME="HRR.1">SYNOPSIS</A></H1>
<BLOCKQUOTE><PRE>

#include &lt;sm_vas.h&gt;  // which includes scan.h

class scan_index_i {
public:
    enum cmp_t { bad_cmp_t=badOp, eq=eqOp, 
		 gt=gtOp, ge=geOp, lt=ltOp, le=leOp };

    NORET			scan_index_i(
	const lvid_t&amp; 		    lvid,
	const serial_t&amp; 	    stid,
	cmp_t			    c1,
	const cvec_t&amp; 		    bound1,
	cmp_t 			    c2,
	const cvec_t&amp; 		    bound2,
	concurrency_t		    cc = t_cc_kvl);

    NORET			~scan_index_i();

    rc_t			curr(
	vec_t* 			    key,
	smsize_t&amp; 		    klen,
	vec_t* 			    el,
	smsize_t&amp; 		    elen);

    rc_t 			next(bool&amp; eof)

    void			finish();
    bool			eof();
    rc_t			error_code();
};

</PRE></BLOCKQUOTE>

<HR>
<H1><A NAME="HRR.2">DESCRIPTION</A></H1>
Class
 <strong>scan_index_i</strong>
supports scanning a range in a B+ tree index. 
The scan is controlled by a
 <strong>scan_index_i</strong>
object.  
Multiple scans can be open at one time.
More information on indexes and key types is can be found
<A HREF="../ssmapi/ssmapi.html">in the SSM interface document.</A>

<P>
<strong>scan_index_i(lvid, stid, c1, bound1, c2, bound2, cc)</strong>
<DL>
<PP>
The 
 <strong>scan_index_i</strong>
constructor is used to initialize a scan.
The
 <em>lvid</em>
and
 <em>stid</em>
parameters specify the
index to be scanned.  
The
 <em>bound1</em>
and
 <em>bound2</em>
parameters
specify the keys marking the beginning and end of the scan, respectively.
The
 <em>c1</em>
and
 <em>c2</em>parameters<em>specify</em>how<em>comparisons</em>
should be made with their corresponding bounds.  Valid
values are:

<BLOCKQUOTE><PRE>
	eq: Only keys equal to the bound will be returned.
	    Valid for c1 or c2.
	gt: Only keys greater than the bound will be returned.
	    Valid only for c1. 
	ge: Only keys greater than or equal to the bound will
	    be returned.  Valid only for c1. 
	lt: Only keys less than the bound will be returned.
	    Valid only for c2. 
	le: Only keys less than or equal to the bound will
	    be returned.  Valid only for c2. 
</DL>
</PRE></BLOCKQUOTE>
<DL>
<PP>
The
 <em>cc</em>
parameter specifies the granularity of locks
acquired for concurrency control.
See
<A HREF="enum.ssm.html"><STRONG>enum(ssm)</STRONG></A>
for a description of the values. Here are the effects
of all valid values for file scan:

<DT>t_cc_none:</DT><DD>
The file is IS locked, but no locks are obtained on any pages or entries
in the file.

</DD>
<DT>t_cc_kvl:</DT><DD>
The file is IS locked and the keys of the index entries are locked.
Next-key locking provides phantom protection.

</DD>
<DT>t_cc_modkvl:</DT><DD>
The file is IS locked and the keys of the index entries are locked.
No next-key locking is done.  The only permissible scans are
those where both bounds are
<strong>eq.</strong>

</DD>
<DT>t_cc_im:</DT><DD>
The value in an entry is treated as a (physical) record identifier,
and that record's lock is obtained.
Next-record locking provides phantom protection.
This locking protocol not useful for VASs that use logical identifiers.

</DD>
<DT>t_cc_file:</DT><DD>
The file is SH locked, so no finer-granularity locks are obtained. 

<P>
</DD>
</DL>
<strong>~scan_index_i()</strong>
<DL>
<PP>
The destructor frees all resources used by the scan.

<P>
</DL>
<strong>curr(key, klen, el, elen)</strong>
<DL>
<PP>
The 
 <strong>curr</strong>
method copies out the current key and element.
They are copied to the memory addressed by the
 <em>key</em>
and
 <em>el</em>
vectors.  The
 <em>klen</em>
parameter will be set to the length of the key copied out.  The
 <em>elen</em>
parameter will be set to the length of the element copied out.

<P>
</DL>
<strong>next(eof)</strong>
<DL>
<PP>
The 
 <strong>next</strong>
method advances the scan to the next key/element
pair.  If the upper bound of the scan has been reached,
 <em>eof</em>
will be set to
<strong>true.</strong>

<P>
</DL>
<strong>finish()</strong>
<DL>
<PP>
The 
 <strong>finish</strong>
method frees all resources used by the scan.

<P>
</DL>
<strong>eof()</strong>
<DL>
<PP>
If the upper bound of the scan has been reached, the
 <strong>eof</strong>
method will return
<strong>true.</strong>

<P>
</DL>
<strong>error_code()</strong>
<DL>
<PP>
The 
 <strong>error_code</strong>
method will return any error code generated by the other
scan member methods.  For more information on errors,
see ERRORS section below.

</DL>
<H2><A NAME="HRR.2.1">Updates While Scanning</A></H2>
<P>
A common question is 
<em>what is the effect of changes to an index made by a transaction that is also scanning the index?</em>
It is not safe to change anything in the file
while scanning.  Instead, a list of changes should be made during
the scan and only performed after the scan is complete.

<HR>
<H1><A NAME="HRR.3">ERRORS</A></H1>
A
 <strong>scan_index_i</strong>
object remembers if an error has occured while
constructing the scan or while scanning.  An error that
occurs in constructing the scan (such as having a bad index ID),
can be detected by calling
 <strong>error_code.</strong>
Alternatively, the error can be detected on the first call to
 <strong>next</strong>
which will return the remembered error code.  Therefore, if an error
occurs while constructing or scanning, repeated calls
to next will all return the first error code and no progress
will be made on the scan.

<HR>
<H1><A NAME="HRR.4">EXAMPLES</A></H1>
To Do.

<HR>
<H1><A NAME="HRR.5">VERSION</A></H1>
This manual page applies to Version 1.1.1 of the Shore software.
<HR>
<H1><A NAME="HRR.6">SPONSORSHIP</A></H1>
The Shore project is sponsored by the Advanced Research Project Agency, ARPA
order number 018 (formerly 8230), monitored by the U.S. Army Research
Laboratory under contract DAAB07-91-C-Q518.
<HR>
<H1><A NAME="HRR.7">COPYRIGHT</A></H1>
Copyright &#169; 1994, 1995, 1996, 1997,
Computer Sciences Department, University of
Wisconsin -- Madison. All Rights Reserved.

<HR>
<H1><A NAME="HRR.8">SEE ALSO</A></H1>

<A HREF="intro.ssm.html"><STRONG>intro(ssm)</STRONG></A>,
<A HREF="btree.ssm.html"><STRONG>btree(ssm)</STRONG></A>,
<A HREF="scan_file_i.ssm.html"><STRONG>scan_file_i(ssm)</STRONG></A>,
<A HREF="scan_rt_i.ssm.html"><STRONG>scan_rt_i(ssm)</STRONG></A>
</BODY>
</HTML>
