<!-- Warning: Do not edit this file. -->
<!-- It was created automatically by yam2html.pl 1.3  -->
<!-- on Mon Oct 27 09:41:12 CST 1997 from file mancommon/options.common -->
<!DOCTYPE HTML public "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<TITLE>
options(common) -- Shore Reference Manual
</TITLE>
<LINK REV="made" HREF="mailto:solomon@cs.wisc.edu">
</HEAD>

<BODY>

<!-- .so tmac.man.local -->
<H1><A NAME="HRR.0">
options - Shore option-processing package
</A></H1><HR>
<H1>
CONTENTS
</H1>
<UL>
<LI>
<A HREF="#HRR.1">SYNOPSIS</A>
</LI>
<LI>
<A HREF="#HRR.2">DESCRIPTION</A>
<UL>
<LI>
<A HREF="#HRR.2.1">ESTABLISHING OPTION DESCRIPTIONS</A>
</LI>
<LI>
<A HREF="#HRR.2.2">SCANNING a FILE and COMMAND LINE</A>
</LI>
<LI>
<A HREF="#HRR.2.3">DETERMINING IF REQUIRED OPTIONS HAVE VALUES</A>
</LI>
<LI>
<A HREF="#HRR.2.4">PARSING VALUES</A>
</LI>
</UL>
</LI>
<LI>
<A HREF="#HRR.3">ERRORS</A>
</LI>
<LI>
<A HREF="#HRR.4">VERSION</A>
</LI>
<LI>
<A HREF="#HRR.5">SPONSORSHIP</A>
</LI>
<LI>
<A HREF="#HRR.6">COPYRIGHT</A>
</LI>
<LI>
<A HREF="#HRR.7">SEE ALSO</A>
</LI></UL><HR>
<H1><A NAME="HRR.1">SYNOPSIS</A></H1>
<BLOCKQUOTE><PRE>
<TT>#include &lt;option.h&gt;</TT>

class option_group_t {
    option_group_t(int max_class_levels);
    ~option_group_t();

    w_rc_t      add_class_level(const char* name);

    w_rc_t      add_option(
                    const char*             name,
                    const char*             possible_values,
                    const char*             default_value,
                    const char*             description,
                    bool                    required,
                    option_t::OptionSetFunc set_func,
                    option_t*&amp;              new_opt);

    w_rc_t      lookup(const char* name, bool exact, option_t*&amp;);

    w_rc_t      lookup_by_class(
                    const char* opt_class_name,
                    option_t*&amp;  returnOption,
                    bool        exact=false);

    w_rc_t      set_value(
                    const char* name,  bool exact,
                    const char* value, bool overRide,
                    ostream*           err_stream);

    void        print_usage(bool longForm, ostream&amp; err_stream);
    void        print_values(bool longForm, ostream&amp; err_stream);
    w_rc_t      check_required(ostream* err_stream);
    w_rc_t      parse_command_line(
                    char**   argv,
                    int&amp;     argc, 
                    int      min_len,
                    ostream* err_stream);
    w_list_t&lt;option_t&gt;&amp;
                option_list();
    int         num_class_levels();
    const char* class_name();
};

class option_t {
    bool        match(const char* matchName, bool exact=false);
    w_rc_t      set_value(
                    const char*  value,
                    bool         override,
                    ostream*     err_stream);
    const char* value();
    bool        is_set();
    bool        is_required();
    const char* name();
    const char* possible_values();
    const char* default_value();
    const char* description();

    typedef w_rc_t (*OptionSetFunc)(
                        option_t*   option,
                        const char* value,
                        ostream*     err_stream);

    // Standard functions for basic types
    static w_rc_t set_value_bool(
                        option_t*   option,
                        const char* value,
                        ostream*     err_stream);
    static w_rc_t set_value_long(
                        option_t*   option,
                        const char* value,
                        ostream*     err_stream);
    static w_rc_t set_value_charstr(
                        option_t*   option,
                        const char* value,
                        ostream*     err_stream);
    static bool str_to_bool(const char* str, bool&amp; bad_str);
};

class option_file_scan_t {
    option_file_scan_t(
                    const char*     opt_file_path,
                    option_group_t* opt_group);
    ~option_file_scan_t();
    w_rc_t  scan(
                bool     override,
                ostream&amp; err_stream,
                bool     exact=false);
};

</PRE></BLOCKQUOTE>
<HR>
<H1><A NAME="HRR.2">DESCRIPTION</A></H1>
<P>
The Shore options-processing package provides a convient means for
run-time configuration of Shore programs (both servers and clients)
based on command-line flags and configuration files.
It is inspired by the X Window System ``resources'' facility.
An option consists of an option name and a string value.
In addition, an option may have
<DL>
<PP>
a
<em>template</em>
indicating possible values, such as ``yes/no'' or ``positive integer'',
<PP>
a
<em>description</em>
explaining the meaning of the option,
<PP>
a
<em>default value ,</em>
and flags indicating whether the option has been supplied (possibly
by virtue of having a non-null default) and whether it must be supplied.
An


The option name is hierarchically structured, so that various
software ``layers'' (library packages) can define their own collections
of options without fear of collisions.
A convention followed by most Shore programs is to use option names
with four components:
<em>type.class.progname.option ,</em>
where
<DT><strong>type</strong></DT><DD>
is the 





an 
A program 
uses the options package in these stages:
</DD>
<DT>Establishes</DT><DD>
descriptions of options, default values, etc.  
</DD>
<DT>Scans</DT><DD>
a file and/or the command line
for character-string representations of values chosen by the user.
</DD>
<DT>Determines</DT><DD>
if all required options have been given values.
</DD>
<DT>Parses</DT><DD>
the character-string representations of values given, and converting them
to binary values.
<P>
</DD>
</DL>
Whether you are writing a value-added server or a Shore application,
your program combines libraries that implement several software
layers (or modules), each of which has its own set of options.
It is the job of the function
 <strong>main</strong>
to initiate each of the above steps, so that
each software layer can perform the first step,
then the file or command line can be scanned once
to determine the values for all the layers' options.
The options package determines if all required options
have been given values, based on the options' descriptions
created in the first step.
Finally, each software layer performs the fourth step.
<P>
The first three steps
are performed in proper succession by the function
<A HREF="process_options.oc.html"><STRONG>process_options(oc)</STRONG></A>,
which is 
in the client-side language-independent library.
If are writing a value-added server, you can look at
or use the function
 <strong>::process_options</strong>
in the Shore Value-Added Server, found in
in source tree at
<tt>src/vas/common/process_options.C.</tt>
If you want to write your own options-handling 
function, read on.
<H2><A NAME="HRR.2.1">ESTABLISHING OPTION DESCRIPTIONS</A></H2>
<P>
An instance of 
 <em>option_t</em>
describes an option.
It contains 
<DL>
<DT>name</DT><DD>
a character string, the name of the option.
</DD>
<DT>description</DT><DD>
a character string, describes the semantics of the
option.  Can be printed for &quot;usage&quot; and &quot;help&quot;.
</DD>
<DT>required</DT><DD>
True if the option has no default value
and the software that uses the option needs a value
for the option.
</DD>
<DT>set</DT><DD>
True if a value 
has been given to this option
(by default or otherwise).
</DD>
<DT>value</DT><DD>
Holds the last value given to the option,
in the form of a character string (as typed
on a command line or read from a file).
<P>
</DD>
</DL>
Options are grouped into option groups, 
represented by instances of
 <em>option_group_t.</em>
By convention, each 
process has an option group, and 
each software layer or module
adds options to the the option group.
<P>
An option group has a classification hierarchy associated with it.
Each level of the hierarchy is given a string name.
Levels are added  with add_class_level().
The level hierarchy is printed
in the form: `level1.level2.level3.'
A complete option name is specified by 
`level1.level2.level3.optionName:'.  
A convention for level names is:
<em>programtype.programname</em>
where 
<em>programtype</em>
indicates the general type of the program
and 
<em>programname</em>
is the Unix file name of the program.
<P>
Options are created and added to the group with the method
 <strong>add_option,</strong>
and located in a group with
the methods
 <strong>lookup</strong>
and
 <strong>lookup_by_class.</strong>
<BLOCKQUOTE><PRE>
        option_t                *opt_make_tcl_shell;
        option_t                *opt_nfsd_port;

        option_group_t  options = new option_group_t(3); // 3 levels

        W_DO(options-&gt;add_option(&quot;svas_tclshell&quot;,  // name of option
                        &quot;yes/no&quot;,  // help-information
                        &quot;yes&quot;,     // default value
                        &quot;yes causes server to run a Tcl shell&quot;, // help info
            false,         // ok if not set by user
            option_t::set_value_bool,  // function called during
                                           // scan of options file or of command-line
                                           // to check the syntax of the given value
                        opt_make_tcl_shell      // place to stash a pointer 
                                                // to this option
                ));

        W_DO(options-&gt;add_option(&quot;svas_nfsd_port&quot;,  // name of option
                        &quot;1024 &lt; integer &lt; 65535&quot;,       // help-information
            &quot;2999&quot;,     // default value
                        &quot;port for NFS service&quot;,     // help information
            false,              // ok if not set by user
            option_t::set_value_long, // interpret strings as an integer
                        opt_nfsd_port // place to stash a pointer 
                                                // to this option
                ));

</PRE></BLOCKQUOTE>
<H2><A NAME="HRR.2.2">SCANNING a FILE and COMMAND LINE</A></H2>
<P>
Given a group of options,
a process can read a file containing
option names and values,  and set
the values of the options in the
option group accordingly.
This is done with the class
 <em>option_file_scan_t.</em>
<BLOCKQUOTE><PRE>
        option_file_scan_t oscan(&quot;.shoreconfig&quot;, options);
        w_rc_t e = oscan.scan(true, cerr); // override any
                                                                // options already set
</PRE></BLOCKQUOTE>
<P>
Applications might need to set option values
explicitly, in which case they can do so with
 <strong>option_group_t::set_value</strong>
or any of the static members of
 <em>option_t:</em>
 <strong>option_t::set_value_bool,</strong>
 <strong>option_t::set_value_long,</strong>and
 <strong>option_t::set_value_charstr.</strong>
These methods check the syntax of the 
character-string representations of values, 
but they do not convert the strings to 
binary values (Boolean, integer, etc.).
<P>
<H2><A NAME="HRR.2.3">DETERMINING IF REQUIRED OPTIONS HAVE VALUES</A></H2>
<P>
The function
 <strong>check_required</strong>
runs through all options associated with the
option group, and determines if 
there is a value (default or assigned explicitly)
for each one that was described in
 <strong>add_option</strong>
as required.
<H2><A NAME="HRR.2.4">PARSING VALUES</A></H2>
<P>
The application program 
or  the function
 <strong>main</strong>
must call functions to
convert the character strings to values.
Typically this is done as follows:
<BLOCKQUOTE><PRE>
        ... = strtol(opt_nfsd_port-&gt;value(),0,0);

        // or 

        bool    isbad=false;
        ... = option_t::str_to_bool(opt_nfsd_port-&gt;value(),isbad);
        if(isbad) {
                // if this returns isbad==true, set_value_bool()
                // would have returned an error had it been called previously
        }
</PRE></BLOCKQUOTE>

<HR>
<H1><A NAME="HRR.3">ERRORS</A></H1>

Errors returned from the option method are:

<BLOCKQUOTE><PRE>
OPT_IllegalDescLine    - Illegal option description line
OPT_IllegalClass       - Illegal option class name
OPT_ClassTooLong       - Option class name too long
OPT_TooManyClasses     - Too many option class levels
OPT_Duplicate          - Option name is not unique
OPT_NoOptionMatch      - Unknown option name
OPT_NoClassMatch       - Unknown option class name
OPT_Syntax             - Bad syntax in configuration file
OPT_BadValue           - Bad option value
OPT_NotSet             - A required option was not set
</PRE></BLOCKQUOTE>

<HR>
<H1><A NAME="HRR.4">VERSION</A></H1>
This manual page applies to Version 1.1.1 of the Shore software.
<HR>
<H1><A NAME="HRR.5">SPONSORSHIP</A></H1>
The Shore project is sponsored by the Advanced Research Project Agency, ARPA
order number 018 (formerly 8230), monitored by the U.S. Army Research
Laboratory under contract DAAB07-91-C-Q518.
<HR>
<H1><A NAME="HRR.6">COPYRIGHT</A></H1>
Copyright &#169; 1994, 1995, 1996, 1997,
Computer Sciences Department, University of
Wisconsin -- Madison. All Rights Reserved.
<HR>
<H1><A NAME="HRR.7">SEE ALSO</A></H1>
<A HREF="process_options.oc.html"><STRONG>process_options(oc)</STRONG></A>
</BODY>
</HTML>
