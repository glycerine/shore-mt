<!-- Warning: Do not edit this file. -->
<!-- It was created automatically by yam2html.pl 1.3  -->
<!-- on Mon Oct 27 09:41:06 CST 1997 from file manssm/btree.ssm -->
<!DOCTYPE HTML public "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<TITLE>
ss_m::index(ssm) -- Shore Reference Manual
</TITLE>
<LINK REV="made" HREF="mailto:solomon@cs.wisc.edu">
</HEAD>

<BODY>

<!-- .so tmac.man.local -->
<H1><A NAME="HRR.0">
bulkld_index, create_assoc, create_index, destroy_assoc, destroy_index, find_assoc, print_index - Class ss_m Methods for B+Tree Index Operations
</A></H1><HR>
<H1>
CONTENTS
</H1>
<UL>
<LI>
<A HREF="#HRR.1">SYNOPSIS</A>
</LI>
<LI>
<A HREF="#HRR.2">DESCRIPTION</A>
<UL>
<LI>
<A HREF="#HRR.2.1">Common Parameters</A>
</LI>
</UL>
</LI>
<LI>
<A HREF="#HRR.3">ERRORS</A>
</LI>
<LI>
<A HREF="#HRR.4">EXAMPLES</A>
</LI>
<LI>
<A HREF="#HRR.5">VERSION</A>
</LI>
<LI>
<A HREF="#HRR.6">SPONSORSHIP</A>
</LI>
<LI>
<A HREF="#HRR.7">COPYRIGHT</A>
</LI>
<LI>
<A HREF="#HRR.8">SEE ALSO</A>
</LI></UL><HR>
<H1><A NAME="HRR.1">SYNOPSIS</A></H1>
<BLOCKQUOTE><PRE>
#include &lt;sm_vas.h&gt;  // includes sm.h (where they are declared)

static rc_t                 create_index(
    const lvid_t&amp;               lvid,
    ndx_t                       ntype,
    store_property_t            property,
    const char*                 key_desc,
    concurrency_t               cc,
    uint                        size_kb_hint,  // hint on final size in KB
    serial_t&amp;                   liid);

// for backward-compatibility:
static rc_t                 create_index(
    const lvid_t&amp;               lvid,
    ndx_t                       ntype,
    store_property_t            property,
    const char*                 key_desc,
    uint                        size_kb_hint,  // hint on final size in KB
    serial_t&amp;                   liid);

static rc_t                 destroy_index(
    const lvid_t&amp;               lvid,
    const serial_t&amp;             liid);

static rc_t                 bulkld_index(
    const lvid_t&amp;               lvid,
    const serial_t&amp;             liid,
    const lvid_t&amp;               s_lvid,
    const serial_t&amp;             s_lfid,
    sm_du_stats_t&amp;              stats);

static rc_t                 bulkld_index(
    const lvid_t&amp;               lvid,
    const serial_t&amp;             liid,
    sort_stream_i&amp;              sorted_stream,
    sm_du_stats_t&amp;              stats);

static rc_t                 print_index(
    const lvid_t&amp;               lvid,
    const serial_t&amp;             liid);

static rc_t                 create_assoc(
    const lvid_t&amp;               lvid,
    const serial_t&amp;             liid,
    const vec_t&amp;                key,
    const vec_t&amp;                el);

static rc_t                 destroy_assoc(
    const lvid_t&amp;               lvid,
    const serial_t&amp;             liid,
    const vec_t&amp;                key,
    const vec_t&amp;                el);

static rc_t                 destroy_all_assoc(
    const lvid_t&amp;               lvid, 
    const serial_t&amp;             liid,
    const vec_t&amp;                key,
    int&amp;                        num_removed);

static rc_t                 find_assoc(
    const lvid_t&amp;               lvid,
    const serial_t&amp;             liid,
    const vec_t&amp;                key,
    void*                       el,
    smsize_t&amp;                   elen,	// if you don't want the result,
                                       // make this 0 on input
    bool&amp;                       found);


</PRE></BLOCKQUOTE>
<HR>
<H1><A NAME="HRR.2">DESCRIPTION</A></H1>

The above class
 <strong>ss_m</strong>
methods manipulate B+tree indexes.
See 
<A HREF="../ssmapi/ssmapi.html">The Shore Storage Manager Programming Interface</A>
for a more detailed description of B+tree indexes.

<H2><A NAME="HRR.2.1">Common Parameters</A></H2>
<P>
There are a number of common parameters for these methods:
<DL>
<DT>lvid</DT><DD>
Logical volume ID of volume containing an index.
</DD>
<DT>liid</DT><DD>
Logical index ID, the serial number of an index.
</DD>
<DT>key</DT><DD>
A vector pointing to the key portion of an index entry. 
</DD>
<DT>el</DT><DD>
A vector pointing to the element portion of an index entry.

<P>
</DD>
</DL>
<strong>create_index(lvid, ntype, property, key_desc, size_kb_hint, liid)</strong>
<DL>
<PP>
The
 <strong>create_index</strong>
methods creates a new B+tree index on the volume
 <em>lvid,</em>
and returns its serial number in
 <em>liid.</em>
The
 <em>ntype</em>
parameter specifies the type of implementation used for the index.
Valid values for the
 <em>ntype</em>
parameter are
<strong>t_btree,</strong>
indicating a B+tree allowing entries with duplicate keys,
and
<strong>t_uni_btree,</strong>
indicating a B+tree only allowing entries with unique keys.
The 
 <em>property</em>
parameter specifies whether the index is temporary.
See
<A HREF="enum.ssm.html"><STRONG>enum(ssm)</STRONG></A>
for more information on
<strong>ss_m::store_property_t.</strong>
<PP>
The
 <em>key_desc</em>
parameter is a string describing the the type of the keys to be stored
in the index.  The syntax of
 <em>key_desc</em>
is as follows:
<BLOCKQUOTE><PRE>
    &lt;key_type_str&gt;      ::= &lt;key_type&gt;* &lt;v_key_type&gt;
    &lt;key_type&gt;          ::= &lt;type&gt; &lt;len&gt;
    &lt;v_key_type&gt;        ::= &lt;type&gt; &lt;var&gt; &lt;len&gt;
    &lt;type&gt;              ::= 'i' | 'u' | 'f' | 'b'
    &lt;var&gt;               ::= '*' | NULL
    &lt;len&gt;               ::= [1-9][0-9]*
</DL>
</PRE></BLOCKQUOTE>
<DL>
<PP>
A &lt;key_type&gt; contains a type ('i' for integer, 'u' for unsigned, 'f'
for float, 'b' for binary), and a length. A &lt;v_key_type&gt;, which is the
last part of &lt;key_type_str&gt;, can contain an optional indicator ('*')
for variable length field.
A &lt;key_type_str&gt; is composed of multiple &lt;key_type&gt;, and a &lt;v_key_type&gt;;
i.e. only the last field can be variable length.
<BLOCKQUOTE><PRE>
   For example the key_desc &quot;i4f8b*1000&quot; specifies a
   key that contains:
	1. a 4 byte integer
	2. an 8 byte float (double)
	3. a variable length binary field that could be as long as
	   as a 1000 bytes.
</DL>
</PRE></BLOCKQUOTE>
<DL>
<PP>
The SSM applies a function to the key values, the result
of which is a string of bytes that can be lexicographically
compared, and yield the correct order.  The SSM contains such
functions for keys of the following types:
signed and unsigned integer keys of length 1, 2, or 4,
floating point keys of length 4 or 8.
Byte strings keys are not interpreted; they
are stored as presented to the SSM.
<PP>
The
 <em>size_kb_hint</em>
parameter allows the caller to give a hint about the final
size of the index (in K-bytes).  This helps the SM determine
where to allocate space for the index.  For now, the hint's main
purpose is to determine whether the index will fit on one
page or on many.  A value of 0 should be used if it is known
the index will be small or if the final size of the index is
unknown.  Otherwise a value larger than
<strong>ss_m::page_sz/1000 should be used.</strong>

<P>
</DL>
<strong>create_index(lvid, ntype, property, cc, key_desc, size_kb_hint, liid)</strong>
<DL>
<PP>
This form of
 <strong>create_index</strong>
allows you to associate with the index, a locking protocol other
than
 <em>t_cc_kvl.</em>
See
<A HREF="enum.ssm.html"><STRONG>enum(ssm)</STRONG></A>
for more information on
<strong>ss_m::concurrency_t.</strong>

<P>
</DL>
<DL>
<PP>
See the &quot;ROOT INDEX METHODS&quot; section of
<A HREF="volume.ssm.html"><STRONG>volume(ssm)</STRONG></A>
for information on how to keep track of the indexes on a volume.

<P>
</DL>
<strong>destroy_index(lvid, liid)</strong>
<DL>
<PP>
The
 <strong>destroy_index</strong>
methods destroys the index and deallocates all space used by it.
The space is not available for reuse until
the transaction destroying the index commits.

<P>
</DL>
<strong>bulkld_index(lvid, liid, s_lvid, s_lfid, stats)</strong>
<DL>
<PP>
This
 <strong>bulkld_index</strong>
method bulk loads the
<strong>empty</strong>
index, identified by
 <em>lvid</em>
and
 <em>liid.</em>
The entries to load must be located, in sorted order, in the
file identified by
 <em>s_lvid</em>
and 
 <em>s_lfid.</em>
The header of each record in the file contains the key
and the body contains the element (value) associated with the key.
Statistics for the newly loaded index are returned in
 <em>stats,</em>
specifically in the
 <em>btree</em>
field.
<P>
</DL>
<strong>bulkld_index(lvid, liid, sorted_stream, stats)</strong>
<DL>
<PP>
This
 <strong>bulkld_index</strong>
method is identical to the one above except that rather than
getting entries from a file, the entries come from
 <em>sorted_stream.</em>
<strong>Note:</strong>
this method has not been extensively tested and may change in the
future.  See
<A HREF="sort_stream_i.ssm.html"><STRONG>sort_stream_i(ssm)</STRONG></A>
for more information.

<P>
</DL>
<strong>print_index(lvid, liid)</strong>
<DL>
<PP>
The
 <strong>print_index</strong>
method is prints the contents of the index.  It is meant to
be a debugging tool.

<P>
</DL>
<strong>create_assoc(lvid, liid, key, el)</strong>
<DL>
<PP>
The 
 <strong>create_assoc</strong>
method adds a new entry associating
 <em>key</em>
with the element (value)
 <em>el.</em>

<P>
</DL>
<strong>destroy_assoc(lvid, liid, key, el)</strong>
<DL>
<PP>
The
 <strong>destroy_assoc</strong>
method destroys the entry associating
 <em>key</em>
with the element (value)
 <em>el.</em>

<P>
</DL>
<strong>destroy_all_assoc(lvid, liid, key, num_removed)</strong>
<DL>
<PP>
The
 <strong>destroy_all_assoc</strong>
method destroys all entries with
 <em>key</em>
as a key.  The number of entries removed is returned in
 <em>num_removed.</em>

<P>
</DL>
<strong>find_assoc(lvid, liid, key, el, elen, found)</strong>
<DL>
<PP>
The
 <strong>find_assoc</strong>
method finds
 <em>key</em>
in the index and
and writes the associated element (only the first one found) to the address specified by
 <em>el.</em>
At most
 <em>elen</em>
bytes will be written.  If the element is not needed, set
 <em>elen</em>
to 0.  
 <em>Elen</em>
will be set to the length actually written.
If
 <em>key</em>
is found, then
 <em>found</em>
will be set to 
<strong>true.</strong>
A more comprehensive lookup facility, allowing range searches,
is available from the class 
 <em>scan_index_i</em>
described in 
<A HREF="scan_index_i.ssm.html"><STRONG>scan_index_i(ssm)</STRONG></A>

</DL>
<HR>
<H1><A NAME="HRR.3">ERRORS</A></H1>

All of the above methods return a
 <strong>w_rc_t</strong>
error code.  If an error occurs during a methods that is updating
persistent data (the create, destroy, and bulk load methods will
update data) then the index could be in an inconsistent state.
The caller then has the choice of aborting the transaction or rolling
back to the nearest save-point (see
<A HREF="transaction.ssm.html"><STRONG>transaction(ssm)</STRONG></A>
).

<P>
See
<A HREF="errors.ssm.html"><STRONG>errors(ssm)</STRONG></A>
for more information on error handling.

<HR>
<H1><A NAME="HRR.4">EXAMPLES</A></H1>
To Do.

<HR>
<H1><A NAME="HRR.5">VERSION</A></H1>
This manual page applies to Version 1.1.1 of the Shore software.
<HR>
<H1><A NAME="HRR.6">SPONSORSHIP</A></H1>
The Shore project is sponsored by the Advanced Research Project Agency, ARPA
order number 018 (formerly 8230), monitored by the U.S. Army Research
Laboratory under contract DAAB07-91-C-Q518.
<HR>
<H1><A NAME="HRR.7">COPYRIGHT</A></H1>
Copyright &#169; 1994, 1995, 1996, 1997,
Computer Sciences Department, University of
Wisconsin -- Madison. All Rights Reserved.
<HR>
<H1><A NAME="HRR.8">SEE ALSO</A></H1>
<A HREF="scan_index_i.ssm.html"><STRONG>scan_index_i(ssm)</STRONG></A>,
<A HREF="sort_stream_i.ssm.html"><STRONG>sort_stream_i(ssm)</STRONG></A>
<A HREF="intro.ssm.html"><STRONG>intro(ssm)</STRONG></A>,
</BODY>
</HTML>
