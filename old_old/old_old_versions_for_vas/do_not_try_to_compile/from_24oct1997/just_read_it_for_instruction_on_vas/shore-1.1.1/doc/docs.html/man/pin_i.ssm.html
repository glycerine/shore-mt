<!-- Warning: Do not edit this file. -->
<!-- It was created automatically by yam2html.pl 1.3  -->
<!-- on Mon Oct 27 09:41:08 CST 1997 from file manssm/pin_i.ssm -->
<!DOCTYPE HTML public "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<TITLE>
pin_i(ssm) -- Shore Reference Manual
</TITLE>
<LINK REV="made" HREF="mailto:solomon@cs.wisc.edu">
</HEAD>

<BODY>

<!-- .so tmac.man.local -->
<H1><A NAME="HRR.0">
pin_i, pin, repin, unpin - Class for Pinning Records
</A></H1><HR>
<H1>
CONTENTS
</H1>
<UL>
<LI>
<A HREF="#HRR.1">SYNOPSIS</A>
</LI>
<LI>
<A HREF="#HRR.2">DESCRIPTION</A>
</LI>
<LI>
<A HREF="#HRR.3">CONSTRUCTORS and DESTRUCTORS</A>
</LI>
<LI>
<A HREF="#HRR.4">PINNING</A>
</LI>
<LI>
<A HREF="#HRR.5">ACCESSING THE RECORD</A>
</LI>
<LI>
<A HREF="#HRR.6">UPDATING A PINNED RECORD</A>
</LI>
<LI>
<A HREF="#HRR.7">OTHER MEMBER FUNCTIONS</A>
</LI>
<LI>
<A HREF="#HRR.8">CAVEATS</A>
</LI>
<LI>
<A HREF="#HRR.9">ERRORS</A>
</LI>
<LI>
<A HREF="#HRR.10">EXAMPLES</A>
</LI>
<LI>
<A HREF="#HRR.11">VERSION</A>
</LI>
<LI>
<A HREF="#HRR.12">SPONSORSHIP</A>
</LI>
<LI>
<A HREF="#HRR.13">COPYRIGHT</A>
</LI>
<LI>
<A HREF="#HRR.14">SEE ALSO</A>
</LI></UL><HR>
<H1><A NAME="HRR.1">SYNOPSIS</A></H1>
<BLOCKQUOTE><PRE>
#include &lt;sm_vas.h&gt;  // which includes pin.h

class pin_i : public smlevel_top {
public:
    enum flags_t { 
	pin_empty		= 0x0,
	pin_rec_pinned		= 0x01,
	pin_hdr_only		= 0x02, 
	pin_separate_data	= 0x04,
	pin_lg_data_pinned	= 0x08  // large data page is pinned
    };
    
    NORET		pin_i();
    NORET		~pin_i();

    rc_t	   	pin(
	const lvid_t&amp;	    lvid,
	const serial_t&amp;	    lrid,
	smsize_t	    start,
	lock_mode_t	    lmode = SH);

    void   		unpin();
    void                set_ref_bit(int value);
    rc_t    		repin(lock_mode_t lmode = SH);
    rc_t		next_bytes(bool&amp; eof); 
    bool  		pinned() const;
    bool  		pinned_all() const;
    bool		up_to_date() const;

    // methods for accessing the record
    smsize_t   		start_byte() const;
    smsize_t   		length() const;
    smsize_t   		hdr_size() const;
    smsize_t   		body_size() const;
    const char*     	hdr() const;
    const char*     	body();
    bool  		is_small() const;
    const record_t* 	rec() const;
    const serial_t&amp;	serial_no() const;
    const lvid_t&amp;	lvid() const;
    const rid_t&amp;	rid() const;

    // methods for changing the record
    rc_t    		update_rec(smsize_t start, const vec_t&amp; data);
    rc_t    		update_rec_hdr(smsize_t start, const vec_t&amp; hdr);
    rc_t    		append_rec(const vec_t&amp; data);
    rc_t    		truncate_rec(smsize_t amount);

    // miscellaneous   
    const char* 	hdr_page_data();
    lpid_t 		page_containing(
	smsize_t	    offset,
	smsize_t&amp;	    start_byte) const;
    static void 	pin_stats(
	u_long&amp;		    pins,
	u_long&amp;		    unpins,
	bool		    reset);

private:
    // these methods are disabled
    pin_i(const pin_i&amp;);
    pin_i&amp; operator=(const pin_i&amp;);
};

</PRE></BLOCKQUOTE>
<HR>
<H1><A NAME="HRR.2">DESCRIPTION</A></H1>
Class
 <strong>pin_i</strong>
supports pinning
records
in the buffer pool and provides
a variety of methods for accessing information about a
record and its contents.  A
 <strong>pin_i</strong>
object is basically a handle to a pinned record.  
The _i suffix in a class name indicates that a class is an iterator.
Class
 <strong>pin_i</strong>
is an iterator since it is used to iterate over all by bytes
in a record's body.

<HR>
<H1><A NAME="HRR.3">CONSTRUCTORS and DESTRUCTORS</A></H1>

<P>
<strong>pin_i()</strong>
<DL>
<PP>
The
 <strong>pin_i</strong>
constructor simply initializes a pin_i object.
<P>
</DL>
<strong>~pin_i()</strong>
<DL>
<PP>
If a record is pinned,
 <strong>~pin_i</strong>
un-pins it.

</DL>
<HR>
<H1><A NAME="HRR.4">PINNING</A></H1>

<P>
<strong>pin(lvid, lrid, start, lmode)</strong>
<DL>
<PP>
The
 <strong>pin</strong>
method pins a range of bytes of a record.
For small records (those
that fit on one page), the entire record body will be pinned.  For large
records, only one page of the body will be pinned at a time.
For both small and large records, the
record header is always pinned as well. 
The first two parameters, 
 <em>lvid</em>
and
 <em>lrid</em>
specify the
<A HREF="lid_t.common.html">logical ID</A>
of the record to be pinned.
<P>
</DL>
<DL>
<PP>
The
 <em>start</em>
parameter
specifies a byte offset into the record body corresponding to a region
of the body to pin.  However, the pin operation will always
adjust the starting location of the pin to reflect the beginning
of the page containing the byte indicated by the
 <em>start</em>
parameter.  The true starting location and size of the pinned
region are available from the 
 <strong>start_byte</strong>
and
 <strong>length</strong>
methods, respectively.
For example,
 <em>start=0</em>
will always pin the first page of the record body, as will
 <em>start=10</em>
(assuming the record is at least 10 bytes long).  In both cases,
 <strong>start_byte</strong>
will return 0 and length will either the entire
record, if small, or approximately the
length of a page, if large.
<P>
</DL>
<DL>
<PP>
The
 <em>lmode</em>
parameter specifies how the record should initially be locked
(ie. the lock mode).  The options are
 <strong>SH</strong>
(share/read lock)
and
 <strong>EX</strong>
(exclusive/write lock).
 <strong>EX</strong>should<strong>be</strong>used<strong>when</strong>
the pinned record will be eventually updated (through update_rec,
unpdate_rec_hdr, append_rec, or truncate_rec).  Using EX in these
cases will improve performance and reduce the risk of deadlock,
but is not necessary for correctness.

<P>
</DL>
<strong>unpin()</strong>
<DL>
<PP>
The
 <strong>unpin</strong>
method unpins the current record (assuming one is pinned).  The
pin object can then be used to pin another record.  The destructor
automatically calls
 <strong>unpin.</strong>

<P>
</DL>
<strong>set_ref_bit(value)</strong>
<DL>
<PP>
The
 <strong>set_ref_bit</strong>
sets the reference bit
 <em>value</em>
to use for the buffer frame containing the currently pinned
body page when the page is unpinned.  A
 <em>value</em>
of 0 is a &quot;hate&quot; hint indicating that
the frame can be reused as soon as necessary.  By default, a
 <em>value</em>
of 1 is used indicating the page will be cached 
until at least 1 sweep of the buffer clock hand has passed.
Higher values cause the page to remain cached longer.

<P>
</DL>
<strong>repin(lmode)</strong>
<DL>
<PP>
The
 <strong>repin</strong>
method repins the previously pinned record, locking it in the
mode specified by
 <em>lmode</em>
(see
 <strong>pin</strong>
for further discussion of
 <em>lmode.</em>
The repin method has a number of uses.  First, when
the previously pinned record needs to be repinned,
it is more efficient to call
 <strong>repin</strong>
than to call 
 <strong>pin</strong>
with the ID of the record.
Second, it can be used to repin the record after some other
operation has modified the page containing the record.  See
the
<strong>RESTRICTIONS</strong>
section
for further information on this use of
 <strong>repin.</strong>
Third, repin can be used to upgrade the lock held on the 
currently pinned record.
However, this is usually unnecessary since all of the 
methods in class
 <strong>pin_i</strong>
that modify the record will automatically acquire an
 <strong>EX</strong>
mode lock on the record.

<P>
</DL>
<strong>next_bytes(eof)</strong>
<DL>
<PP>
The
 <strong>next_bytes</strong>
method gets the next range of bytes available to be pinned.
Parameter
 <em>eof</em>
is set to
<strong>true</strong>
if there are no more bytes to pin.
When eof is reached, the previously pinned range remains pinned

<P>
</DL>
<strong>pinned()</strong>
<DL>
<PP>
The
 <strong>pinned</strong>
methods returns
<strong>true,</strong>
if a record is currently being pinned, and
<strong>false</strong>
otherwise.

<P>
</DL>
<strong>pinned_all()</strong>
<DL>
<PP>
The
 <strong>pinned_all</strong>
methods returns
<strong>true</strong>
if the pinned region includes the entire record, otherwise.
<strong>false</strong>
is returned.

<P>
</DL>
<strong>up_to_date()</strong>
<DL>
<PP>
The
 <strong>up_to_date</strong>
method returns
true if a record is pinned and pin no changes have been made
to the page containing the record since it was pinned.
See the
<strong>RESTRICTIONS</strong>
section for information on using this method.

</DL>
<HR>
<H1><A NAME="HRR.5">ACCESSING THE RECORD</A></H1>

<P>
<strong>start_byte()</strong>
<DL>
<PP>
The
 <strong>start_byte</strong>
method returns the offset, from the beginning of the record, where
the pinned region starts.  Ie. it is the offset of the location
pointed to by the
 <strong>body</strong>
method.
<strong>Note:</strong>
the value returned by 
 <strong>start_byte</strong>
may not be the
 <em>start</em>
location passed to
 <strong>pin</strong>
since pinned regions are always aligned on page boundaries. 

<P>
</DL>
<strong>length()</strong>
<DL>
<PP>
The
 <strong>length</strong>
method returns the length, in bytes, of the pinned region.

<P>
</DL>
<strong>hdr_size()</strong>
<DL>
<PP>
The
 <strong>hdr_size</strong>
method returns the size, in bytes, of the record header.

<P>
</DL>
<strong>body_size()</strong>
<DL>
<PP>
The
 <strong>body_size</strong>
method returns the size, in bytes, of the entire record body
(not just the portion pinned).

<P>
</DL>
<strong>hdr()</strong>
<DL>
<PP>
The
 <strong>hdr</strong>
method returns a pointer to the pinned header.  Note that the
pointer is
<strong>const</strong>
since the header can only be updated via
 <strong>update_rec_hdr.</strong>

<P>
</DL>
<strong>body()</strong>
<DL>
<PP>
The
 <strong>body</strong>
method return a pointer to the pinned region of the body.
Note that the
pointer is
<strong>const</strong>
since the body can only be updated via the update methods
described below.

<P>
</DL>
<strong>is_small()</strong>
<DL>
<PP>
The
 <strong>is_small</strong>
method returns
<strong>true</strong>
if the record body fits on the same page as the header and thus is
pinned in it's entirety.


<P>
</DL>
<strong>serial_no()</strong>
<P>
<strong>lvid()</strong>
<DL>
<PP>
The
 <strong>serial_no</strong>
and
 <strong>lvid</strong>
methods
return the logical ID of the pinned
record assuming it was pinned using logical IDs. 
<strong>Note:</strong>
theses IDs are the &quot;snapped&quot; values -- ie. they
are the volume ID where the record is located and
the record's serial# on that volume.  Therefore, these
may be different than the ones passed in to pin the
record.

<P>
</DL>
<strong>rid()</strong>
<DL>
<PP>
The
 <strong>rid</strong>
method return the physical ID of the record.

<P>
</DL>
<strong>rec()</strong>
<DL>
<PP>
The
 <strong>rec</strong>
method returns the pointer
 <strong>record_t</strong>
structure that is used internally to access records on 
pages.  Most uses of this structure, such as finding the size of
the record, are already provided by other
 <strong>pin_i</strong>
methods.  
The primary use of this method is debugging or to do things
not provided by other
 <strong>pin_i</strong>
methods.

</DL>
<HR>
<H1><A NAME="HRR.6">UPDATING A PINNED RECORD</A></H1>

<P>
<strong>update_rec(start, data)</strong>
<P>
<strong>update_rec_hdr(start, hdr)</strong>
<P>
<strong>append_rec(data)</strong>
<P>
<strong>truncate_rec(amount)</strong>
<DL>
<PP>
These methods are used to change a pinned record.  They
correspond to the class
 <strong>ss_m</strong>
methods of the same name
describe in 
<A HREF="file.ssm.html"><STRONG>file(ssm)</STRONG></A>.
They can be called on any pinned record
regardless of where and how much is pinned.
Using these methods when a record is pinned is 
considerably more efficient than calling the corresponding
 <strong>ss_m</strong>
methods.
Also, the
 <strong>up_to_date</strong>
method will return
<strong>true</strong>
after calling one of these methods, even though they update
the record.

</DL>
<HR>
<H1><A NAME="HRR.7">OTHER MEMBER FUNCTIONS</A></H1>

<P>
<strong>hdr_page_data()</strong>
<DL>
<PP>
The
 <strong>hdr_page_data</strong>
method returns a pointer to beginning of the page containing
the pinned record header.  This is used by the Shore VAS
when sending entire pages of records to the client. 
A page can be interpreted with the
<strong>shore_file_page_t(ssm)</strong>
class (undocumented).

<P>
</DL>
<strong>page_containing(offset, start_byte)</strong>
<DL>
<PP>
The
 <strong>page_containing</strong>
returns the page ID of the page containing the
 <em>start_byte</em>
offset from the beginning of the record body.
This function is not currently supported.

<P>
</DL>
<strong>pin_stats(pins, unpins, reset)</strong>
<DL>
<PP>
The
 <strong>pin_stats</strong>
method return the number of pins and unpins performed.
The
 <em>pins</em>
parameter will equal the sum of all
 <strong>pin</strong>
and 
 <strong>repin</strong>
calls.  The
 <em>unpins</em>
parameter will equal the sum of all
 <strong>unpin</strong>
 <strong>repin</strong>
calls.

</DL>
<HR>
<H1><A NAME="HRR.8">CAVEATS</A></H1>

<P>
While a pin_i is valid, a page is fixed in the buffer pool.
Pages should not be fixed for long periods of time, and a
thread that pins multiple pages in the buffer pool runs the
risk of exhausting the buffer pool resources.
<P>
It is risky to pin and update two records concurrently, that is,
to update one record while another record is
pinned.  If the records are on the same page, updating one
record can invalidate the pin of the other record.
The method
 <strong>repin</strong>
can be used to re-validate the pin of the second record, 
however, it is still a risky proposition: read on.
<P>
On the other hand, if the two records are on different pages, 
and if the thread is not observing a protocol to order the pins,
(more importantly, all threads in the VAS must observe 
the same protocol), 
<strong>latch-latch deadlocks</strong>
can occur (pages are
latched when they are fixed), if
fine-grained (record) locking is in effect.
Whereas deadlock detection is performed on locks, latches are
much lighter-weight and do not perform deadlock detection.

<HR>
<H1><A NAME="HRR.9">ERRORS</A></H1>

To Do.

<HR>
<H1><A NAME="HRR.10">EXAMPLES</A></H1>
To Do.

<HR>
<H1><A NAME="HRR.11">VERSION</A></H1>
This manual page applies to Version 1.1.1 of the Shore software.
<HR>
<H1><A NAME="HRR.12">SPONSORSHIP</A></H1>
The Shore project is sponsored by the Advanced Research Project Agency, ARPA
order number 018 (formerly 8230), monitored by the U.S. Army Research
Laboratory under contract DAAB07-91-C-Q518.
<HR>
<H1><A NAME="HRR.13">COPYRIGHT</A></H1>
Copyright &#169; 1994, 1995, 1996, 1997,
Computer Sciences Department, University of
Wisconsin -- Madison. All Rights Reserved.
<HR>
<H1><A NAME="HRR.14">SEE ALSO</A></H1>
<A HREF="file.ssm.html"><STRONG>file(ssm)</STRONG></A>,
<A HREF="scan_file_i.ssm.html"><STRONG>scan_file_i(ssm)</STRONG></A>,
<A HREF="intro.ssm.html"><STRONG>intro(ssm)</STRONG></A>,

</BODY>
</HTML>
