#!/bin/sh -- # A comment mentioning perl to prevent looping.
eval 'exec perl $0 ${1+"$@"}'
    if 0;

# --------------------------------------------------------------- #
# -- Copyright (c) 1994, 1995 Computer Sciences Department,    -- #
# -- University of Wisconsin-Madison, subject to the terms     -- #
# -- and conditions given in the file COPYRIGHT.  All Rights   -- #
# -- Reserved.                                                 -- #
# --------------------------------------------------------------- #

#
#  Perl script for generating log record types.
#
#  $Id: logdef.pl,v 1.36 1997/06/13 19:30:15 solomon Exp $
#
open(INPUT, "<logdef.dat")	|| die "cannot open logdef.dat: $!\n";
open(FUNC, ">logfunc.i")	|| die "cannot open logfunc.i: $!\n";
open(TYPE, ">logtype.i")	|| die "cannot open logtype.i: $!\n";
open(DEF, ">logdef.i")		|| die "cannot open logdef.i: $!\n";
open(STUB, ">logstub.i")	|| die "cannot open logstub.i: $!\n";
open(REDO, ">redo.i")		|| die "cannot open redo.i: $!\n";
open(UNDO, ">undo.i")		|| die "cannot open undo.i: $!\n";
open(STR, ">logstr.i")		|| die "cannot open logstr.i: $!\n";

$warning = "/* DO NOT MODIFY --- generated by $0 using logdef.dat */\n\n";
print FUNC $warning;
print TYPE $warning;
print DEF $warning;
print REDO $warning;
print UNDO $warning;
print STR $warning;

printf(TYPE "enum kind_t { \n");

#
# create logtype.h
#

$unique = 0;
LINE:
while (<INPUT>) {
    s/^\s*//;
    next LINE if (/^\#/ || ! /\w/);
    chop;
    while (! /;\s*$/) {
	$_ .= <INPUT>;
	chop;
    }
    s/\s+/ /g;
    ($type, $attr, $arg) = split(/[ \t\n]+/, $_, 3);
    chop $arg;

    ($xflag, $sync, $redo, $undo, $format, $aflag, $logical) = split(//, $attr);
    $cat = &get_cat($redo, $undo, $format, $logical);
    
    printf(TYPE "\tt_$type = %d,\n", $unique++);
    &def_rec($type, $xflag, $aflag, $sync, $redo, $undo, $cat, $arg);
				# 
    print REDO "\tcase t_$type : \n";
    if ($redo) {
	printf(REDO "\t\t((%s_log *) this)->redo(page); \n", $type);
    } else {
	print REDO "\t\tW_FATAL(eINTERNAL);\n";
	}
    print REDO "\t\tbreak;\n";
    
    
    print UNDO "\tcase t_$type : \n";
    if ($undo) {
	printf(UNDO "\t\t((%s_log *) this)->undo(page); \n", $type);
    } else {
	print UNDO "\t\tW_FATAL(eINTERNAL);\n";
    }
    print UNDO "\t\tbreak;\n";

    printf(STR "\tcase t_%s : \n\t\treturn \"%s\";\n", $type, $type);
}
printf(TYPE "\tt_max_logrec = %d,\n", $unique);
print TYPE "};\n";
exit(0);

sub get_cat {
    local($redo, $undo, $format, $logical) = @_;
    local($ret);
    $ret = "0";
    $ret .= "|t_redo" if $redo;
    $ret .= "|t_undo" if $undo;
    $ret .= "|t_format" if $format;
    $ret .= "|t_logical" if $logical;
    if ($ret eq "0") { $ret = "t_status";};
    $ret;
}

sub def_rec {
    local($type, $xflag, $aflag, $sync, $redo, $undo, $cat, $arg) = @_;
    local($class) = $type . "_log";
    local($has_idx);

    $redo_stmt = ($redo) ? 'void redo(page_p*);' : '';
    $undo_stmt = ($undo) ? 'void undo(page_p*);' : '';
    print DEF<<CLASSDEF;
    class $class : public logrec_t {
	void fill(const lpid_t* p, uint2 tag, int l) {
	  _cat = $cat, _type = t_$type;
	  logrec_t::fill(p, tag, l);
	}
      public:
	$class $arg;
	$class (logrec_t*)   {};
	
	$redo_stmt
	$undo_stmt
    };

CLASSDEF
	;

    #($real = $arg) =~ s/[\(\)]|const //g;
    $arg =~ s/\((.*)\)/$1/;
    # see if arg contains "int idx"
    $arg =~ /int\s+idx/ && do { $has_idx=1; };
    $real = join(', ', grep(s/^.*\s+(\w+)$/$1/, split(/, /, $arg)));
    $decl = join(', ', grep(s/^(.*)\s+\w+$/$1/, split(/, /, $arg)));
    # print "arg = $arg\n";
    # print "real = $real\n";
    # print "decl = $decl\n";
    # print "$type: cat = $cat\n";

    if ($xflag)  {
        $func = "rc_t log_$type($arg)";
        $ign = "rc_t log_$type($decl)";

        print STUB $func, "\n";
        print STUB "{\n";
	($page = $real) =~ s/(\w*).*/$1/;
    	# print "page = $page\n";
	print STUB "    xct_t* xd = xct();\n";
        print STUB "    bool should_log = smlevel_1::log && smlevel_0::logging_enabled";
	if($aflag==0) {
	    if ($page eq "page") {
		print STUB "\n\t\t\t&& (page.store_flags() & page.st_tmp) == 0";
	    }
	    print STUB "\n\t\t\t&& xd && xd->is_log_on()";
	}
	print STUB ";\n";
	print STUB "    if (should_log)  {\n";
	print STUB "        logrec_t* logrec;\n";
	print STUB "        W_DO( xd->get_logbuf(logrec) ); \n";
        print STUB "        new (logrec) $class($real);\n";	   
	if ($page eq "page") {
	    print STUB "        xd->give_logbuf(logrec, &page);\n";
	} else {
	    print STUB "        xd->give_logbuf(logrec);\n";
	}
	if ($sync) {
	    print STUB "        xd->flush_logbuf();\n";
	    print STUB "        W_COERCE( smlevel_0::log->flush_all() );\n";
	}
	print STUB "    }\n";
	if ($page eq "page") {
	    # no longer need to call set_dirty explicitly after give_logbuf 
	    print STUB "    else page.set_dirty();\n" if ($real);
	}
	print STUB "    return RCOK;\n";
    print STUB "}\n";

    print FUNC "EXTERN $func;\n";
    } 
}
