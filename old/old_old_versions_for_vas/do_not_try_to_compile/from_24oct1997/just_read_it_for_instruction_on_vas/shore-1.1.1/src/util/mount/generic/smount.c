/* --------------------------------------------------------------- */
/* -- Copyright (c) 1994, 1995 Computer Sciences Department,    -- */
/* -- University of Wisconsin-Madison, subject to the terms     -- */
/* -- and conditions given in the file COPYRIGHT.  All Rights   -- */
/* -- Reserved.                                                 -- */
/* --------------------------------------------------------------- */
#ifndef __GNUC__
#define __attribute__(x)
#endif
static char *rcsid  __attribute__((unused)) =
"$Header: /p/shore/shore_cvs/src/util/mount/generic/smount.c,v 1.13 1997/06/13 22:33:56 solomon Exp $";

#include "platform.h"

#define NFSCLIENT
/*
#if #platform(ultrix)
#	include <machine/param.h>
#	include <nfs/nfs.h>
#endif
*/
#include <sys/types.h>
#if #platform(ultrix)
#else
#	include <sys/mount.h>
#endif
#include <stdio.h>

#if #platform(solaris)
#	define PORTMAP
#	include <sys/mnttab.h>
#	include <nfs/mount.h>
#	include <rpc/bootparam.h>
#	include <sys/netconfig.h>
#endif

#include <string.h>
#include <stdlib.h>
#include <errno.h>
#include <netdb.h>
#include <sys/time.h>
#include <rpc/rpc.h>

#if #platform(linux)
#	include <linux/fs.h>
#	include <linux/nfs.h>
#	include <linux/nfs_mount.h>
#else
#	include <nfs/nfs.h>
#endif

#if #platform(ultrix)
#	include <nfs/nfs_gfs.h>
#	include <sys/mount.h>
	/* Bug in Ultrix:  fs_types initializes the array gt_names.  If we
	 * include it here and in mount_tab.c, the linker chokes.  The
	 * following horrid kludge fixes that.
	 */
#	define KERNEL
#	include <sys/fs_types.h>
#	undef KERNEL
#endif

#include <rpcsvc/mount.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <unistd.h>

#include "globals.h"

/* Platform-dependent stuff */

/* LOCAL_MOUNT(Path,Flags,Args) should generate the system call to tell
 * the local kernel that Path is a mount point.  It varies widely from
 * system to system (so much for standards!)
 */

/*************************** SunOS 4.1 *******************************/
#if #platform(sunos)
#define LOCAL_MOUNT(Path,Flags,Args) \
	mount("nfs", Path, Flags, (caddr_t)&Args)
#define DEFAULT_FLAGS (M_NEWTYPE | M_NOSUB)
#define NFS_ARGS nfs_args
#define XDR_PATH xdr_path

/* Various prototypes that should be in standard hearder files but aren't
 * (SunOS 4.1.3).
 */
void fprintf(FILE *, const char *, ...);
void printf(const char *, ...);
void exit(int);
int getopt(int, char *const*, const char *);
void perror(const char *);
int mount(const char *, const char *, int, const caddr_t);
#endif /* sunos */

/*************************** Solaris 2.4 (a.k.a. SunOS 5.2) ***************/
#if #platform(solaris)
#define LOCAL_MOUNT(Path,Flags,Args) \
	mount(remote_path, Path, Flags, "nfs", (const char *)&Args, sizeof (Args))
#define DEFAULT_FLAGS MS_DATA
#define NFS_ARGS nfs_args
#define XDR_PATH xdr_path

#define M_RDONLY		MS_RDONLY
#define M_NOSUID		MS_NOSUID
#define M_REMOUNT		MS_REMOUNT

/* These are generated by rpcgen, but for convenince, we just give the
 * definitions explicitly so we don't have to mess with rpcgen.
 */
int xdr_fhstatus(XDR *xdrs, struct fhstatus *objp) {
	return
		   xdr_u_int(xdrs, &objp->fhs_status)
		&& xdr_opaque(xdrs, (caddr_t)&objp->fhs_fh, NFS_FHSIZE);
}
int xdr_path(XDR *xdrs, char **objp) {
	return xdr_string(xdrs, objp, MAX_PATH_LEN);
}
#endif /* solaris */

/*************************** HPUX 9 *******************************/
#if #platform(hpux)
#define LOCAL_MOUNT(Path,Flags,Args) \
	vfsmount(MOUNT_NFS, Path, Flags, (caddr_t)&Args)
#define DEFAULT_FLAGS 0
#define NFS_ARGS nfs_args
#define XDR_PATH xdr_path
#endif /* hpux */

/*************************** Ultrix 4.3 *******************************/
#if #platform(ultrix)
#define LOCAL_MOUNT(Path,Flags,Args) \
	mount(remote_name, Path, (mount_args.gfs_flags & M_RONLY) != 0, \
		GT_NFS, (char *)&Args)

#define DEFAULT_FLAGS 0
#define NFS_ARGS nfs_gfs_mount
#define XDR_PATH xdr_path
#define M_RDONLY M_RONLY
/* Ultrix doesn't use bits in NFS_ARGS.flags to indicate whether
 * AC timeouts are set.  It fills in default values instead.
 */
#define NFSMNT_ACREGMIN 0
#define NFSMNT_ACREGMAX 0
#define NFSMNT_ACDIRMIN 0
#define NFSMNT_ACDIRMAX 0

/* These are generated by rpcgen, but for convenince, we just give the
 * definitions explicitly so we don't have to mess with rpcgen.
 */
int xdr_fhstatus(XDR *xdrs, struct fhstatus *objp) {
	return
		   xdr_u_int(xdrs, &objp->fhs_status)
		&& xdr_opaque(xdrs, (caddr_t)&objp->fhstatus_u, NFS_FHSIZE);
}
int xdr_path(XDR *xdrs, char **objp) {
	return xdr_string(xdrs, objp, NFS_MAXPATHLEN);
}

/* missing prototypes */
int getopt(int, char *const*, const char *);
int mount(char *special, char *dirname, int rwflag, int type, char *options);
#endif /* ultrix */

/*************************** Linux 2.1 *******************************/
#if #platform(linux)
#define LOCAL_MOUNT(Path,Flags,Args) \
	mount(remote_path, Path, "nfs", (Flags) & 0x00ED0000, (caddr_t)&Args)
#define DEFAULT_FLAGS 0
#define NFS_ARGS nfs_mount_data
#define XDR_PATH xdr_dirpath

/* Linux doesn't use bits in NFS_ARGS.flags to indicate whether
 * other options are set.  It fills in default values instead.
 */
#define NFSMNT_WSIZE	0
#define NFSMNT_RSIZE	0
#define NFSMNT_TIMEO	0
#define NFSMNT_RETRANS	0
#define NFSMNT_ACDIRMAX	0
#define NFSMNT_ACDIRMIN	0
#define NFSMNT_ACREGMAX	0
#define NFSMNT_ACREGMIN	0

/* These are defined in <linux/nfs_mount.h> */
#define NFSMNT_SOFT		NFS_MOUNT_SOFT
#define NFSMNT_INT		NFS_MOUNT_INTR
#define NFSMNT_SECURE	NFS_MOUNT_SECURE
#define NFSMNT_POSIX	NFS_MOUNT_POSIX
#define NFSMNT_NOCTO	NFS_MOUNT_NOCTO
#define NFSMNT_NOAC		NFS_MOUNT_NOAC

/* These are defined in <linux/fs.h> */
#define M_RDONLY		MS_RDONLY
#define M_NOSUID		MS_NOSUID

/* These are generated by rpcgen, but for convenince, we just give the
 * definitions explicitly so we don't have to mess with rpcgen.
 */
int xdr_fhstatus(XDR *xdrs, fhstatus *objp) {
	return
		   xdr_u_int(xdrs, &objp->fhs_status)
		&& xdr_opaque(xdrs, (caddr_t)&objp->fhstatus_u.fhs_fhandle, FHSIZE);
}
int xdr_dirpath(XDR *xdrs, dirpath *objp) {
	return xdr_string(xdrs, objp, MNTPATHLEN);
}
#endif /* linux */
/*************************** End Platform-dependent Stuff  ****************/

extern int errno; /* in case errno.h omits it */
typedef struct { /* see below */
	int mask;
	char *name;
} FlagInfo;

/* Functions defined below */
int process_opts(const char *opts);
int remote_mount(char *host, char *path);
static void pflags(FILE *fi, FlagInfo *info, int flags);
static void dumpargs(void);
char *augment_opts(char *dir, char *opts);
void usage(void);

/* Global flags and parameters */
char *progname = "mount";
int background, ac_timeout, ac_tflag, max_retries, verbose; /* default zero */
int port = SHORE_PORT, mport = SHORE_MPORT;

/* passed to the Flags argument of LOCAL_MOUNT */
int mount_flags = DEFAULT_FLAGS;

/* passed to the Args argument of LOCAL_MOUNT */
struct NFS_ARGS mount_args;

/* Short names to make the tables below more compact */
#if #platform(ultrix)
#define MF mount_args.gfs_flags
#else
#define MF mount_flags
#endif
#define MA mount_args

/* Information about options used to parse the options and put their
 * values in the appropriate places.
 */
typedef enum { OPT_IGNORE, OPT_FLAG_ON, OPT_FLAG_OFF, OPT_NUM } OptType;
typedef struct {
	char *name;		/* option name */
	OptType type;	/* option type */
	int flag_value;	/* value to use to set/clear flags */
	int *flags;		/* flags to be set or cleared */
	int *value;		/* place to put value (OPT_NUM only) */
} Option;

Option options[] = {
/* numeric values in the NFS_ARGS structure (together with a bit to
 * indicate whether the attribute is present)
 */
{ "wsize",    OPT_NUM,      NFSMNT_WSIZE,   &MA.flags,   &MA.wsize    },
{ "rsize",    OPT_NUM,      NFSMNT_RSIZE,   &MA.flags,   &MA.rsize    },
{ "timeo",    OPT_NUM,      NFSMNT_TIMEO,   &MA.flags,   &MA.timeo    },
{ "retrans",  OPT_NUM,      NFSMNT_RETRANS, &MA.flags,   &MA.retrans  },
{ "acdirmax", OPT_NUM,      NFSMNT_ACDIRMAX,&MA.flags,   &MA.acdirmax },
{ "acdirmin", OPT_NUM,      NFSMNT_ACDIRMIN,&MA.flags,   &MA.acdirmin },
{ "acregmax", OPT_NUM,      NFSMNT_ACREGMAX,&MA.flags,   &MA.acregmax },
{ "acregmin", OPT_NUM,      NFSMNT_ACREGMIN,&MA.flags,   &MA.acregmin },
/* short-hand to set acdirmax, acdirmin, acregmax, and acregmin */
{ "actimeo",  OPT_NUM,      1,              &ac_tflag,   &ac_timeout  },

/* other flags in NFS_ARGS.flags */
{ "intr",     OPT_FLAG_ON,  NFSMNT_INT,     &MA.flags,   0            },
{ "nointr",   OPT_FLAG_OFF, NFSMNT_INT,     &MA.flags,   0            },
{ "noac",     OPT_FLAG_ON,  NFSMNT_NOAC,    &MA.flags,   0            },
{ "hard",     OPT_FLAG_OFF, NFSMNT_SOFT,    &MA.flags,   0            },
{ "soft",     OPT_FLAG_ON,  NFSMNT_SOFT,    &MA.flags,   0            },
#if #platform(sunos) || #platform(solaris) || #platform(linux)
{ "secure",   OPT_FLAG_ON,  NFSMNT_SECURE,  &MA.flags,   0            },
{ "posix",    OPT_FLAG_ON,  NFSMNT_POSIX,   &MA.flags,   0            },
#endif /* sun || linux */
#if #platform(solaris)
{ "grpid",    OPT_FLAG_ON,  NFSMNT_GRPID,   &MA.flags,   0            },
#endif
#if #platform(ultrix)
{ "pgthresh", OPT_FLAG_ON,  NFSMNT_PGTHRESH,&MA.flags,   0            },
#else
{ "nocto",    OPT_FLAG_ON,  NFSMNT_NOCTO,   &MA.flags,   0            },
#endif

/* flags passed to the Flags argument of LOCAL_MOUNT */
{ "ro",       OPT_FLAG_ON,  M_RDONLY,       &MF,         0            },
{ "rw",       OPT_FLAG_OFF, M_RDONLY,       &MF,         0            },
{ "nosuid",   OPT_FLAG_ON,  M_NOSUID,       &MF,         0            },
{ "suid",     OPT_FLAG_OFF, M_NOSUID,       &MF,         0            },
#if #platform(sunos)
{ "grpid",    OPT_FLAG_ON,  M_GRPID,        &MF,         0            },
#endif
#if #platform(sunos) || #platform(solaris)
{ "remount",  OPT_FLAG_ON,  M_REMOUNT,      &MF,         0            },
#endif
#if #platform(ultrix)
{ "force",    OPT_FLAG_ON,  M_FORCE,        &MF,         0            },
{ "noexec",   OPT_FLAG_ON,  M_NOEXEC,       &MF,         0            },
{ "nodev",    OPT_FLAG_ON,  M_NODEV,        &MF,         0            },
{ "nocache",  OPT_FLAG_ON,  M_NOCACHE,      &MF,         0            },
{ "sync",     OPT_FLAG_ON,  M_SYNC,         &MF,         0            },
#endif

/* misc other flags and parameters */
{ "bg",       OPT_FLAG_ON,  1,              &background, 0            },
{ "fg",       OPT_FLAG_OFF, 1,              &background, 0            },
{ "mport",    OPT_NUM,      1,              0,           &mport       },
{ "port",     OPT_NUM,      0,              0,           &port        },
{ "retry",    OPT_NUM,      0,              0,           &max_retries },

/* options allowed for compatibility sake, but otherwise ignored */
{ "noauto",   OPT_IGNORE,   0,              0,           0            },
{ "noquota",  OPT_IGNORE,   0,              0,           0            },
{ "quota",    OPT_IGNORE,   0,              0,           0            },
#if #platform(solaris)
{ "llock",    OPT_IGNORE,   0,              0,           0            },
{ "kerberos", OPT_IGNORE,   0,              0,           0            },
#endif


{ 0,          0,            0,              0,           0            }
}; /* options */

/* Information used to print out bitmasks for debugging
 * (from <sys/mount.h>)
typedef struct {
	int mask;
	char *name;
} FlagInfo;
 */

FlagInfo mount_flags_info[] = {
#if #platform(sunos)
	/* from <sys/mount.h> */
	{ 0x01, "M_RDONLY" },	/* mount fs read only */
	{ 0x02, "M_NOSUID" },	/* mount fs with setuid not allowed */
	{ 0x04, "M_NEWTYPE" },	/* use type string instead of int */
	{ 0x08, "M_GRPID" },	/* Old BSD group-id on create */
	{ 0x10, "M_REMOUNT" },	/* change options on an existing mount */
	{ 0x20, "M_NOSUB" },	/* Disallow mounts beneath this mount */
	{ 0x40, "M_MULTI" },	/* Do multi-component lookup on files */
	{ 0x80, "M_SYS5" },		/* Mount with Sys 5-specific semantics */
#endif /* sunos */
#if #platform(solaris)
	/* from  <sys/mnttab.h> */
	{ 0x01, "MS_RDONLY" },	/* Read-only */
	{ 0x02, "MS_FSS" },		/* Old (4-argument) mount (compatibility) */
	{ 0x04, "MS_DATA" },	/* 6-argument mount */
	{ 0x10, "MS_NOSUID" },	/* Setuid programs disallowed */
	{ 0x20, "MS_REMOUNT" },	/* Remount */
	{ 0x40, "MS_NOTRUNC" },	/* Return ENAMETOOLONG for long filenames */
	{ 0x80, "MS_OVERLAY" },	/* allow overlay mounts */
#endif /* solaris */
#if #platform(hpux)
	/* from <sys/mount.h> */
	{ 0x01, "M_RDONLY" },	/* mount fs read only */
	{ 0x02, "M_NOSUID" },	/* mount fs with setuid not allowed */
	{ 0x04, "M_QUOTA" },	/* mount fs with quotas enabled */
#endif /* hpux */
#if #platform(ultrix)
	/* from <sys/mount.h> */
	{ 0x0001, "M_RONLY" },
	{ 0x0002, "M_MOD" },
	{ 0x0004, "M_QUOTA" },
	{ 0x0008, "M_LOCAL" },
	{ 0x0010, "M_NOEXEC" },
	{ 0x0020, "M_NOSUID" },
	{ 0x0040, "M_NODEV" },
	{ 0x0080, "M_FORCE" },
	{ 0x0100, "M_SYNC" },
	{ 0x0200, "M_DONE" },
	{ 0x0400, "M_NOCACHE" },
	{ 0x0800, "M_EXPORTED" },	/* export flag */
	{ 0x1000, "M_NOFH" },		/* no fhandle flag */
	{ 0x2000, "M_EXRONLY" },	/* export read-only */
#endif /* ultrix */
	{ 0, 0 }
};

FlagInfo mount_args_info[] = {
#if #platform(sunos)
	/* from <sys/mount.h> */
	{ 0x001, "NFSMNT_SOFT" },		/* soft mount (hard is default) */
	{ 0x002, "NFSMNT_WSIZE" },		/* set write size */
	{ 0x004, "NFSMNT_RSIZE" },		/* set read size */
	{ 0x008, "NFSMNT_TIMEO" },		/* set initial timeout */
	{ 0x010, "NFSMNT_RETRANS" },	/* set number of request retrys */
	{ 0x020, "NFSMNT_HOSTNAME" },	/* set hostname for error printf */
	{ 0x040, "NFSMNT_INT" },		/* allow interrupts on hard mount */
	{ 0x080, "NFSMNT_NOAC" },		/* don't cache attributes */
	{ 0x0100, "NFSMNT_ACREGMIN" },	/* set min secs for file attr cache */
	{ 0x0200, "NFSMNT_ACREGMAX" },	/* set max secs for file attr cache */
	{ 0x0400, "NFSMNT_ACDIRMIN" },	/* set min secs for dir attr cache */
	{ 0x0800, "NFSMNT_ACDIRMAX" },	/* set max secs for dir attr cache */
	{ 0x1000, "NFSMNT_SECURE" },	/* secure mount */
	{ 0x2000, "NFSMNT_NOCTO" },		/* no close-to-open consistency */
	{ 0x4000, "NFSMNT_POSIX" },		/* static pathconf kludge info */
#endif /* sunos */
#if #platform(solaris)
	/* from <nfs/mount.h> */
	{ 0x001, "NFSMNT_SOFT" },		/* soft mount (hard is default) */
	{ 0x002, "NFSMNT_WSIZE" },		/* set write size */
	{ 0x004, "NFSMNT_RSIZE" },		/* set read size */
	{ 0x008, "NFSMNT_TIMEO" },		/* set initial timeout */
	{ 0x010, "NFSMNT_RETRANS" },	/* set number of request retrys */
	{ 0x020, "NFSMNT_HOSTNAME" },	/* set hostname for error printf */
	{ 0x040, "NFSMNT_INT" },		/* allow interrupts on hard mount */
	{ 0x080, "NFSMNT_NOAC" },		/* don't cache attributes */
	{ 0x0100, "NFSMNT_ACREGMIN" },	/* set min secs for file attr cache */
	{ 0x0200, "NFSMNT_ACREGMAX" },	/* set max secs for file attr cache */
	{ 0x0400, "NFSMNT_ACDIRMIN" },	/* set min secs for dir attr cache */
	{ 0x0800, "NFSMNT_ACDIRMAX" },	/* set max secs for dir attr cache */
	{ 0x1000, "NFSMNT_SECURE" },	/* secure mount */
	{ 0x2000, "NFSMNT_NOCTO" },		/* no close-to-open consistency */
	{ 0x4000, "NFSMNT_KNCONF" },	/* transport's knetconfig structure */
	{ 0x8000, "NFSMNT_GRPID" },		/* System V-style gid inheritance */
	{ 0x10000, "NFSMNT_RPCTIMESYNC" },	/* use RPC to do secure NFS time sync */
	{ 0x20000, "NFSMNT_KERBEROS" },	/* use kerberos credentials */
	{ 0x40000, "NFSMNT_POSIX" },	/* static pathconf kludge info */
	{ 0x80000, "NFSMNT_LLOCK" },	/* Local locking (no lock manager) */
#endif /* solaris */
#if #platform(hpux)
	{ 0x001, "NFSMNT_SOFT" },		/* soft mount (hard is default) */
	{ 0x002, "NFSMNT_WSIZE" },		/* set write size */
	{ 0x004, "NFSMNT_RSIZE" },		/* set read size */
	{ 0x008, "NFSMNT_TIMEO" },		/* set initial timeout */
	{ 0x010, "NFSMNT_RETRANS" },	/* set number of request retrys */
	{ 0x020, "NFSMNT_HOSTNAME" },	/* set hostname for error printf */
	{ 0x040, "NFSMNT_INT" },		/* set option to have interruptable mounts */
	{ 0x080, "NFSMNT_NODEVS" },		/* turn off device file access (default on) */
	{ 0x100, "NFSMNT_FSNAME" },		/* provide name of server's fs to system */
	{ 0x200, "NFSMNT_IGNORE" },		/* mark this file system as ignore in mnttab */
	{ 0x400, "NFSMNT_NOAC" },		/* don't cache file attributes */
	{ 0x800, "NFSMNT_NOCTO" },		/* don't get new attributes on open */
	{ 0x1000, "NFSMNT_DYNAMIC" },	/* Use dynamic read and write sizes */
	{ 0x02000, "NFSMNT_ACREGMIN" },	/* set min secs for file attr cache */
	{ 0x04000, "NFSMNT_ACREGMAX" },	/* set max secs for file attr cache */
	{ 0x08000, "NFSMNT_ACDIRMIN" },	/* set min secs for dir attr cache */
	{ 0x10000, "NFSMNT_ACDIRMAX" },	/* set max secs for dir attr cache */
#endif /* hpux */
#if #platform(linux)
	{ 0x0001,	"NFS_MOUNT_SOFT" },
	{ 0x0002,	"NFS_MOUNT_INTR" },
	{ 0x0004,	"NFS_MOUNT_SECURE" },
	{ 0x0008,	"NFS_MOUNT_POSIX" },
	{ 0x0010,	"NFS_MOUNT_NOCTO" },
	{ 0x0020,	"NFS_MOUNT_NOAC" },
#endif /* linux */
#if #platform(ultrix)
	/* from <nfs/nfs_gfs.h> */
	{ 0x0001, "NFSMNT_RONLY", },	/* mount read-only */
	{ 0x0002, "NFSMNT_SOFT", },		/* soft mount (hard is default) */
	{ 0x0004, "NFSMNT_WSIZE", },	/* set write size */
	{ 0x0008, "NFSMNT_RSIZE", },	/* set read size */
	{ 0x0010, "NFSMNT_TIMEO", },	/* set initial timeout */
	{ 0x0020, "NFSMNT_RETRANS", },	/* set number of request retrys */
	{ 0x0040, "NFSMNT_HOSTNAME", },	/* set hostname for error printf */
	{ 0x0080, "NFSMNT_PGTHRESH", },	/* set page threshold for exec */
	{ 0x0100, "NFSMNT_INT", },		/* allow hard mount keyboard interrupts */
	{ 0x0200, "NFSMNT_NOAC", },		/* don't cache attributes */
#endif /* ultrix */
	{ 0, 0 }
};

/* Parse an option string according to the options[] table.
 * Return 1 on success.
 * Return 0 on failure, printing messages to stderr.
 */
int process_opts(const char *opts) {
	char  *head, *tail, *arg;
	Option *opt;
	int errors = 0;

#if #platform(linux)
	/* Linux needs to have some defaults filled in.
	 * See comment above about NFS_ARGS.flags
	 */
	mount_args.version = 1;
	mount_args.timeo = 7;
	mount_args.retrans = 3;
	mount_args.acregimn = 3;
	mount_args.acregmax = 60;
	mount_args.acdirmin = 30;
	mount_args.acdirmax = 60;
#endif /* linux */
#if #platform(ultrix)
	mount_args.flags = NFSMNT_INT;
	mount_args.pg_thresh = 64;
	mount_args.acregmin = 3;
	mount_args.acregmax = 60;
	mount_args.acdirmin = 30;
	mount_args.acdirmax = 60;
#endif /* ultrix */

	if (opts == 0)
		return 1;

	/* Make a temp copy for convenience */
	tail = xmalloc(strlen(opts) + 1);
	strcpy(tail, opts);
	while (tail) {
		head = tail;
		tail = strchr(tail,',');
		if (tail)
			*tail++ = 0;
		arg = strchr(head,'=');
		if (arg)
			*arg++ = 0;

		for (opt = options; opt->name; opt++) {
			if (strcmp(opt->name, head) == 0)
				break;
		}
		if (!opt) {
			fprintf(stderr,"%s: unknown option `%s'\n", progname, head);
			errors++;
			continue;
		}
		switch (opt->type) {
			case OPT_IGNORE:
				break;
			case OPT_NUM:
				if (arg == 0) {
					fprintf(stderr, "%s: missing value for `%s' option\n",
						progname, head);
					errors++;
					break;
				}
				if (opt->flags)
					(*opt->flags) |= opt->flag_value;
				(*opt->value) = atoi(arg);
				break;
			case OPT_FLAG_ON:
				(*opt->flags)  |= opt->flag_value;
				break;
			case OPT_FLAG_OFF:
				(*opt->flags)  &= ~opt->flag_value;
				break;
		}
	}
#if #platform(ultrix)
	if (mount_args.gfs_flags & M_RONLY)
		mount_args.flags |=  NFSMNT_RONLY;
#endif
	if (ac_tflag) {
		mount_args.acdirmax = ac_timeout;
		mount_args.acdirmin = ac_timeout;
		mount_args.acregmax = ac_timeout;
		mount_args.acregmin = ac_timeout;
		mount_args.flags |=
			NFSMNT_ACDIRMAX
			| NFSMNT_ACDIRMIN
			| NFSMNT_ACREGMAX
			| NFSMNT_ACREGMIN;
	}
	if (background)
		fprintf(stderr, "%s: Warning: `bg' is not implemented\n",
			progname);
	return 1;
} /* process_opts */

/* Contact the remote host using the NFS MOUNT protocol to ask to mount the
 * indicated path.  Return 0 (and print a message) on failure; 1 on success.
 *
 * On success, the name and address of HOST are recorded in the global
 * variable mount_args, as is the file handle corresponding to PATH returned
 * by the remote nfs_mount daemon.
 */
int remote_mount(char *host, char *path) {
	struct hostent *h;
	static struct sockaddr_in sock_addr;
	struct timeval tv;
	int sock = RPC_ANYSOCK;
	CLIENT *rpc_handle;
	enum clnt_stat status;
	static struct fhstatus result;
	int try;

	/* Create an RPC handle to talk to the server */
	h = gethostbyname(host);
	if (!h) {
		fprintf(stderr, "%s: host %s not found\n", progname, host);
		return 0;
	}
	memcpy((char *)&sock_addr.sin_addr, h->h_addr, sizeof sock_addr.sin_addr);
	sock_addr.sin_family = AF_INET;
	sock_addr.sin_port = htons(mport);
	tv.tv_sec = 5;
	tv.tv_usec = 0;
	rpc_handle = clntudp_create(
		&sock_addr, (u_long)MOUNTPROG, (u_long)MOUNTVERS, tv, &sock);
	if (!rpc_handle) {
		clnt_pcreateerror("mount");
		return 0;
	}
	rpc_handle->cl_auth = authunix_create_default();

	/* Send an RPC mount request to the server */
	for (try = 0; ; try++) {
		status = clnt_call(rpc_handle, MOUNTPROC_MNT, XDR_PATH, (caddr_t)&path,
			xdr_fhstatus, (caddr_t)&result, tv);
		if (status == RPC_SUCCESS)
			break;

		/* no response from server */
		fprintf(stderr, "%s: nfs server %s/%d not responding",
			progname, host, mport);
		clnt_perror(rpc_handle, "");

		/* try again? */
		if (try == max_retries) {
			fprintf(stderr, "%s: giving up on %s/%d\n",
				progname, host, mport);
			return 0;
		}
	}

	/* Check result */
	if (result.fhs_status) {
		if (result.fhs_status == EACCES)
			fprintf(stderr, "%s: access denied for %s:%s\n",
				progname, host, path);
		else {
			errno = result.fhs_status;
			perror(path);
		}
		return 0;
	}

	/* Extract results */
#if #platform(solaris)
	{
		/* see <sys/mount.h> for struct nfs_args  */
		struct stat statbuf;
		static struct knetconfig kn;	/* see <rpc/clnt.h> */
		static struct netbuf addr_buf;	/* see <sys/tiuser.h> */

		addr_buf.maxlen = addr_buf.len = sizeof sock_addr;
		addr_buf.buf = (char *)&sock_addr;
		mount_args.addr = &addr_buf;

		if (stat("/dev/udp", &statbuf)) {
			perror("/dev/udp");
			return 0;
		}
		memset(&kn, 0, sizeof kn);
		kn.knc_semantics = NC_TPI_CLTS;
		kn.knc_protofmly = "inet";
		kn.knc_proto = "udp";
		kn.knc_rdev = statbuf.st_rdev;
		mount_args.knconf = &kn;
		mount_args.flags |= NFSMNT_KNCONF;

		mount_args.hostname = host;
		mount_args.flags |= NFSMNT_HOSTNAME;
		mount_args.fh = (caddr_t) &result.fhs_fh;
	}
#endif /* solaris */
#if #platform(sunos)
	mount_args.fh = (caddr_t) &result.fhs_fh;
	mount_args.hostname = host;
	mount_args.flags |= NFSMNT_HOSTNAME;
	mount_args.addr = &sock_addr;
#endif /* sunos */
#if #platform(hpux)
	mount_args.fh = (fhandle_t *) &result.fhs_fh;
	mount_args.hostname = host;
	mount_args.flags |= NFSMNT_HOSTNAME;
	mount_args.addr = &sock_addr;
#endif /* hpux */
#if #platform(ultrix)
	mount_args.fh = (fhandle_t *) result.fhstatus_u.fhs_fhandle;
	mount_args.hostname = host;
	mount_args.flags |= NFSMNT_HOSTNAME;
	mount_args.addr = &sock_addr;
#endif /* ultrix */
#if #platform(linux)
	/* linux puts copies of things into the structure rather than pointers */
	memcpy((caddr_t)&mount_args.root, (caddr_t) &result.fhstatus_u.fhs_fhandle,
		sizeof mount_args.root);
	strncpy(mount_args.hostname, host,
		sizeof mount_args.hostname);
	memcpy((caddr_t)&mount_args.addr, (caddr_t)&sock_addr,
		sizeof mount_args.addr);
#endif /* linux */
	return 1;
} /* remote_mount */

/* For the -v flag */
static void pflags(FILE *fi, FlagInfo *info, int flags) {
	char *sep = "";
	for (; info->name; info++) {
		if (flags & (info->mask)) {
			fprintf(fi, "%s%s", sep, info->name);
			sep = "|";
		}
	}
}

static void dumpargs(void) {
	printf("mount_flags = 0x%08x (", MF);
	pflags(stdout, mount_flags_info, MF);
	printf(")\n");
	printf("background = %d, port = %d, mport = %d, max_retries = %d\n",
		background, port, mport, max_retries);
	printf("mount_args.flags = 0x%08x\n\t", MA.flags);
	pflags(stdout, mount_args_info, MA.flags);
	printf("\n");
	printf("mount_args.wsize = %d\n", MA.wsize);
	printf("mount_args.rsize = %d\n", MA.rsize);
	printf("mount_args.timeo = %d\n", MA.timeo);
	printf("mount_args.acregmin = %d\n", MA.acregmin);
	printf("mount_args.acregmax = %d\n", MA.acregmax);
	printf("mount_args.acdirmin = %d\n", MA.acdirmin);
	printf("mount_args.acdirmax = %d\n", MA.acdirmax);
} /* dump_args */

/* Augment the opts string with mport=XXXX and, in the case of sun systems
 * dev=xxx.  Return the new opt string (in malloced space).
 */
char *augment_opts(char *dir, char *opts) {
	char *new_opts;
	char dev_info[10];
	int opts_len;

	if (!get_mounts())
		return 0;

	if (opts == 0 || *opts == 0)
		opts = "rw";

	opts_len = strlen(opts) + strlen(",mport=XXXXXX") + 1;
#if #platform(sunos) || #platform(solaris)
	/* SunOS and Solaris like to add a "dev=XXXX" item to mtab.
	 * Don't ask me why.
	 */
	{
		struct stat statb;
		if (stat(dir, &statb) < 0) {
			perror(dir);
			return 0;
		}
		sprintf(dev_info, ",dev=%04x", (unsigned int)statb.st_dev & 0xffff);
	}
	opts_len += strlen(",dev=XXXX");
#else /* not sun */
	dev_info[0] = 0;
#endif /* not sun */
	new_opts = xmalloc(opts_len);
	sprintf(new_opts, "%s,mport=%u%s", opts, mport, dev_info);
	return new_opts;
} /* augment_opts */

void usage(void) {
	fprintf(stderr, "usage: %s [-r] [-v] [-o options] host:path /path\n",
		progname);
	exit(1);
}

int main(int argc, char **argv) {
	int c;
	extern char *optarg;
	extern int optind;
	char *opts = 0;
	char *host, *remote_name, *remote_path, *local_path;

	progname = argv[0];
	if (geteuid() != 0) {
		fprintf(stderr, "%s: you must be root to mount a file system\n",
			progname);
	}
	while ((c = getopt(argc,argv,"vro:"))!=EOF) switch(c) {
		case 'v':
			verbose++;
			break;
		case 'r':
			mount_flags |= M_RDONLY;
			break;
		case 'o':
			opts = optarg;
			break;
		default:
			usage();
	}

	if (optind+2 != argc)
		usage();
	
	remote_name = argv[optind]; 	/* should be "host:path" */
	local_path = argv[optind+1];
	host = xmalloc(strlen(remote_name) + 1);
	strcpy(host, remote_name);
	remote_path = strchr(host, ':');
	if (!remote_path) {
		fprintf(stderr, "%s: file system `%s' must have the form host:path\n",
			progname, host);
		return 1;
	}
	*remote_path++ = 0;
	if (*local_path != '/') {
		fprintf(stderr, "%s: mount point `%s' must start with '/'\n",
			progname, local_path);
		return 1;
	}

	if (!process_opts(opts))
		return 1;

	if (!remote_mount(host, remote_path))
		return 1;

	opts = augment_opts(local_path, opts);
#if #platform(ultrix)
	mount_args.optstr = opts;
#endif /* ultrix */

	if (verbose)
		dumpargs();

	if (LOCAL_MOUNT(local_path, mount_flags, mount_args)) {
		fprintf(stderr, "%s: ", progname);
		perror("mount");
		return 1;
	}

	add_mount(xstrdup(local_path), xstrdup(remote_name), opts);
	if (!put_mounts()) {
		/* If put_mounts fails, perhaps we should back out of the
		 * whole thing (both remotely and locally), but it shouldn't ever
		 * fail!
		 */
		return 1;
	}

	return 0;
} /* main */
