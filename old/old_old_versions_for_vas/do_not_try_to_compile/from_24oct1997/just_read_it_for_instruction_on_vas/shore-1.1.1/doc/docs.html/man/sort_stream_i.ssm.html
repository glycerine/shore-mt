<!-- Warning: Do not edit this file. -->
<!-- It was created automatically by yam2html.pl 1.3  -->
<!-- on Mon Oct 27 09:41:09 CST 1997 from file manssm/sort_stream_i.ssm -->
<!DOCTYPE HTML public "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<TITLE>
sort_stream_i(ssm) -- Shore Reference Manual
</TITLE>
<LINK REV="made" HREF="mailto:solomon@cs.wisc.edu">
</HEAD>

<BODY>

<!-- .so tmac.man.local -->
<H1><A NAME="HRR.0">
sort_stream_i - Sorting Utility Class
</A></H1><HR>
<H1>
CONTENTS
</H1>
<UL>
<LI>
<A HREF="#HRR.1">SYNOPSIS</A>
</LI>
<LI>
<A HREF="#HRR.2">DESCRIPTION</A>
</LI>
<LI>
<A HREF="#HRR.3">ERRORS</A>
</LI>
<LI>
<A HREF="#HRR.4">EXAMPLES</A>
</LI>
<LI>
<A HREF="#HRR.5">VERSION</A>
</LI>
<LI>
<A HREF="#HRR.6">SPONSORSHIP</A>
</LI>
<LI>
<A HREF="#HRR.7">COPYRIGHT</A>
</LI>
<LI>
<A HREF="#HRR.8">SEE ALSO</A>
</LI></UL><HR>
<H1><A NAME="HRR.1">SYNOPSIS</A></H1>
<BLOCKQUOTE><PRE>
#include &lt;sm_vas.h&gt;  // which includes sort.h

class sort_stream_i {
  public:

    sort_stream_i();	
    sort_stream_i(const key_info_t&amp; k, const sort_parm_t&amp; s, uint est_rec_sz=0);
    ~sort_stream_i();

    // initialize the sort_stream
    void	init(const key_info_t&amp; k, const sort_parm_t&amp; s, uint est_rec_sz=0);
    // close the sort stream (release any resource held)
    void	finish();
    // put &lt;key, elem&gt; pair into the sort stream
    rc_t	put(const cvec_t&amp; key, const cvec_t&amp; elem);
    // fetch next pair in sorted order
    rc_t	get_next(vec_t&amp; key, vec_t&amp; elem, bool&amp; eof);
    // detect if the stream is empty
    bool	is_empty();
    // detect if the stream is sorted or not
    bool	is_sorted()
};


struct key_info_t {
    enum key_type_t 	{ t_char=0, t_int, t_float, t_string, t_spatial };
    enum where_t 	{ t_hdr=0, t_body };

    key_type_t  type;	    // key type
    nbox_t 	universe;   // for spatial object only
    bool	derived;    // if true, the key must be the only item in rec
			    // header, and the header will not be copied to
			    // the result record (allow user to store derived
			    // key temporarily for sorting purpose).

    // following applies to file sort only
    where_t 	where;      // where the key resides
    uint4	offset;	    // offset from the begin
    uint4	len;	    // key length
    
    key_info_t() {
      type = t_int;
      where = t_body;
      offset = 0;
      len = sizeof(int);
      derived = FALSE;
    }
};


//
// sort parameter
//
struct sort_parm_t {
    uint2    run_size;		// size for each run (# of pages)
    vid_t    vol;		// volume for files
    serial_t logical_id;	// logical oid
    bool     unique;		// result unique ?
    bool     ascending;		// ascending order ?
    bool     destructive;	// destroy the input file at the end ?
    bool     keep_lid;          // preserve logical oid for recs in sorted
				// file -- only for destructive sort
    lvid_t   lvid;              // logical volume id
    sm_store_property_t property; // temporary file ?

    sort_parm_t() : run_size(10), unique(false), ascending(true),
		    destructive(false), property(t_regular) {}
};

</PRE></BLOCKQUOTE>

<HR>
<H1><A NAME="HRR.2">DESCRIPTION</A></H1>

Class 
 <strong>sort_stream_i</strong>
class is used for sorting a stream of records. After creating
an instance of
 <strong>sort_stream_i,</strong>
you can keep putting &lt;key, element&gt; pairs
into the stream and will save all the records to a temporary
persistent store, sort them and return them in a sorted order
via calls to
 <strong>get_next.</strong>
The temporary store is destroyed automatically
upon completion.

<P>
To create a
 <strong>sort_stream_i</strong>
instance, you need to supply a
 <strong>key_info_t</strong>
parameter, which includes information about the key type 
See 
<A HREF="btree.ssm.html"><STRONG>btree(ssm)</STRONG></A>
for a description of key types.

A
 <strong>sort_parm_t</strong>
parameter is needed
to provide information on the run size, temporary file volume.
Besides, estimated record length will help the sort code to allocate
the right amount of resources for the sort.

<P>
Note that
 <strong>sort_stream</strong>
exists only during the put and fetch, after
the last pair is fetched through
 <strong>get_next()</strong>
the stream is destroyed.


<HR>
<H1><A NAME="HRR.3">ERRORS</A></H1>

TODO.

<HR>
<H1><A NAME="HRR.4">EXAMPLES</A></H1>

TODO.

<HR>
<H1><A NAME="HRR.5">VERSION</A></H1>
This manual page applies to Version 1.1.1 of the Shore software.
<HR>
<H1><A NAME="HRR.6">SPONSORSHIP</A></H1>
The Shore project is sponsored by the Advanced Research Project Agency, ARPA
order number 018 (formerly 8230), monitored by the U.S. Army Research
Laboratory under contract DAAB07-91-C-Q518.
<HR>
<H1><A NAME="HRR.7">COPYRIGHT</A></H1>
Copyright &#169; 1994, 1995, 1996, 1997,
Computer Sciences Department, University of
Wisconsin -- Madison. All Rights Reserved.
<HR>
<H1><A NAME="HRR.8">SEE ALSO</A></H1>
<A HREF="btree.ssm.html"><STRONG>btree(ssm)</STRONG></A>,
<A HREF="file.ssm.html"><STRONG>file(ssm)</STRONG></A>

</BODY>
</HTML>
