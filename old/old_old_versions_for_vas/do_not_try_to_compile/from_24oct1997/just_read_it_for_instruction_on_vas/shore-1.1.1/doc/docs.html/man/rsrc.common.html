<!-- Warning: Do not edit this file. -->
<!-- It was created automatically by yam2html.pl 1.3  -->
<!-- on Mon Oct 27 09:41:12 CST 1997 from file mancommon/rsrc.common -->
<!DOCTYPE HTML public "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<TITLE>
rsrc(common) -- Shore Reference Manual
</TITLE>
<LINK REV="made" HREF="mailto:solomon@cs.wisc.edu">
</HEAD>

<BODY>

<!-- .so tmac.man.local -->
<H1><A NAME="HRR.0">
rsrc_m, rsrc_i - Resource Manager and Iterator Classes
</A></H1><HR>
<H1>
CONTENTS
</H1>
<UL>
<LI>
<A HREF="#HRR.1">SYNOPSIS</A>
</LI>
<LI>
<A HREF="#HRR.2">DESCRIPTION</A>
<UL>
<LI>
<A HREF="#HRR.2.1">Requirements:</A>
</LI>
<LI>
<A HREF="#HRR.2.2">Rsrc_m Interface</A>
</LI>
<LI>
<A HREF="#HRR.2.3">Rsrc_i Interface</A>
</LI>
</UL>
</LI>
<LI>
<A HREF="#HRR.3">VERSION</A>
</LI>
<LI>
<A HREF="#HRR.4">SPONSORSHIP</A>
</LI>
<LI>
<A HREF="#HRR.5">COPYRIGHT</A>
</LI>
<LI>
<A HREF="#HRR.6">SEE ALSO</A>
</LI></UL><HR>
<H1><A NAME="HRR.1">SYNOPSIS</A></H1>
<BLOCKQUOTE><PRE>
<TT>#include &lt;rsrc.h&gt;</TT>

template &lt;class TYPE, class KEY&gt;
class rsrc_m : public w_base_t {
    friend class rsrc_i&lt;TYPE, KEY&gt;;
public:
    NORET			rsrc_m(
	TYPE* 			    space,
	int 			    n, 
	char*			    descriptor=0);
    NORET			~rsrc_m();

    void			mutex_acquire();
    void			mutex_release();

    bool			is_cached(const KEY&amp; k);

    w_rc_t 			grab(
	TYPE*&amp;			    ret,
	const KEY&amp; 		    k,
	bool&amp;			    found,
	bool&amp;			    is_new,
	latch_mode_t		    mode = LATCH_EX,
	int			    timeout = sthread_base_t::WAIT_FOREVER);

    w_rc_t 			find(
	TYPE*&amp;			    ret,
	const KEY&amp; 		    k, 
	latch_mode_t 		    mode = LATCH_EX,
	int 			    ref_bit = 1,
	int 			    timeout = sthread_base_t::WAIT_FOREVER);

    void			publish_partial(const TYPE* rsrc);
    void			publish(
	const TYPE* 		    rsrc,
	bool			    error_occurred = false);
    
    bool 			is_mine(const TYPE* rsrc);

    void 			pin(
	const TYPE* 		    rsrc,
	latch_mode_t		    mode = LATCH_EX);

    void 			upgrade_latch_if_not_block(
	const TYPE* 		    rsrc,
	bool&amp;			    would_block);

    void			unpin(
	const TYPE*&amp; 		    rsrc,
	int			    ref_bit = 1);
    // number of times pinned
    int				pin_cnt(const TYPE* t);
    w_rc_t			remove(const TYPE*&amp; t) { 
	w_rc_t rc;
	bool get_mutex = ! _mutex.is_mine();
	if (get_mutex)    W_COERCE(_mutex.acquire());
	rc = _remove(t);
	if (get_mutex)    _mutex.release();
	return rc;
    }

    void 			dump(ostream &amp;o,bool debugging=1)const;
    int				audit(bool prt= false) const;

    void			snapshot(u_int&amp; npinned, u_int&amp; nfree);

    unsigned long 		ref_cnt, hit_cnt;

// iterator
template &lt;class TYPE, class KEY&gt;
class rsrc_i {
public:
    NORET			rsrc_i(
	rsrc_m&lt;TYPE, KEY&gt;&amp;	    r,
	latch_mode_t 		    m = LATCH_EX,
	int 			    start = 0)
	: _mode(m), _idx(start), _curr(0), _r(r) {};

    NORET			~rsrc_i();
    
    TYPE* 			next();
    TYPE* 			curr() 	{ return _curr ? _curr-&gt;ptr : 0; }
    w_rc_t			discard_curr();

private: // disabled methods
    NORET			rsrc_i(const rsrc_i&amp;);
    rsrc_i&amp;			operator=(const rsrc_i&amp;);
};

/*
 *  rsrc_t
 *	control block (handle) to a resource
 */
template &lt;class TYPE, class KEY&gt;
struct rsrc_t {
public:
    NORET			rsrc_t()    {};
    NORET			~rsrc_t()   {};
    w_link_t			link;		// used in resource hash table
    latch_t 			latch;		// latch on the resource
    KEY				key;		// key of the resource
    KEY				old_key;
    bool			old_key_valid;
    TYPE* 			ptr;		// pointer to the resource
    w_base_t::uint4_t		waiters;	// # of waiters
    w_base_t::uint4_t		ref;		// ref count
    scond_t			exit_transit;	// signaled when
						// initialization is done
    
};


</PRE></BLOCKQUOTE>
<HR>
<H1><A NAME="HRR.2">DESCRIPTION</A></H1>
<P>
The 
 <strong>rsrc_m</strong>
template class manages a fixed size pool of &quot;resources&quot; (of type T) in a
multi-threaded environment.  A structure, 
 <strong>rsrc_t,</strong>
is associated with
each resource.  Class
 <strong>rsrc_t</strong>
contains a key, K, a pointer to
the resource and a latch to protect access to the resource.  The
 <strong>rsrc_t</strong>
elements are stored in a hash table,
 <strong>hash_t.</strong>
Because of the latches, each resource can be individually &quot;pinned&quot;
for any desired length of time without restricting access to 
other resources.

<P>
The template class
 <strong>rsrc_i</strong>
is the iterator for the
 <strong>rsrc_m</strong>
class.  

<P>
When a entry needs to be added and the table is full, on old entry is
removed based on an LRU policy.

<P>
The rsrc_m is relatively expensive, so it is probably best used
to manage large resources or where high concurrency is needed.
A good example is managing access to pages in a buffer pool.

<H2><A NAME="HRR.2.1">Requirements:</A></H2>
The 
 <strong>rsrc_m</strong>
template takes two class parameters:
<DL>
<DT>T</DT><DD>
the class type of the resources to be manages.
</DD>
<DT>K</DT><DD>
the unique key of the resource for lookup purposes.
<em>Note:</em>
that
 <strong>K</strong>
must define
 <strong>K::operator=()</strong>
for copying since
 <strong>rsrc_m</strong>
saves a copy of
 <strong>K</strong>for<strong>lookup</strong>purpose,<strong>and</strong>
 <strong>u_long hash(const K&amp;)</strong>
hash function for
 <strong>K</strong>
because
 <strong>rsrc_m</strong>
is hash-table based.

<P>
</DD>
</DL>
A resource in
 <strong>rsrc_m</strong>
 can be in one of three states:
<DL>
<DT>unused</DT><DD>
the resource is free; no key is associated with the resource.
</DD>
<DT>cached</DT><DD>
the resource is cached and is associated with a key.
</DD>
<DT>in-transit</DT><DD>
 the resource is begin replaced; its key is being changed.

</DD>
</DL>
<H2><A NAME="HRR.2.2">Rsrc_m Interface</A></H2>

<P>
<strong>rsrc_m(rsrc, cnt, desc)</strong>
<DL>
<PP>
The constructor creates a resource manager to manage the
resources specified by the array
 <em>rsrc.</em>
The number of resources (ie. the length of the array) is specified by
 <em>cnt.</em>
The 
 <em>desc</em>
is an optional string used for naming the latches protecting
the resources.  It can be useful in debugging.

<P>
</DL>
<strong>~rsrc_m()</strong>
<DL>
<PP>
The destructor destroys the resource manager.  There should not be
any resources pinned when the resource manager is is destroyed.

<P>
</DL>
<strong>grab(ret, key, found, is_new, mode, timeout)</strong>
<DL>
<PP>
The
 <strong>grab</strong>
method pins the resource associated with
 <em>key</em>
and sets a latch in mode
 <em>mode</em>
on the resource.
The calling thread should subsequently free 
 <em>rsrc</em>
by calling 
 <strong>unpin.</strong>

<PP>
If the resource is cached, 
 <strong>grab</strong>
simply returns it. Otherwise,
 <strong>grab</strong>
will either allocate an unused resource or find another
cached resource to replace using a pseudo-LRU (clock) algorithm.  The
calling thread could potentially block if 
 <em>mode</em>
causes a latch
conflict (i.e., when there is contention to the resource). If 
 <strong>grab</strong>
is successful, a pointer to the cached/allocated/replacement
resource is returned in 
 <em>ret.</em>
The 
 <em>found</em>
flag is set to indicate
cache hit/miss.  In the case of a cache miss, the resource returned is
said to be 
 <strong>in-transit,</strong>
and the 
 <em>is_new</em>
flag indicates
whether 
 <em>ret</em>
points to:

<PP>
(1) a previously unused resource (true), or
<PP>
(2) a previously cached resource of another key (false).

<P>
</DL>
<DL>
<PP>
In case 1, the in-transit resource returned simply needs to be
initialized with the new key. All other threads that ask for a
resource with the new key will block. The caller should initialize the
resource and subsequently call 
 <strong>publish,</strong>
which formally publishes
the new key and resets the resource's in-transit status.
<P>
</DL>
<DL>
<PP>
In case 2, the in-transit resource returned is temporarily associated
with both the new key (as specified in 
 <strong>grab</strong>
and the old key. All other threads that ask for a resource with any of
these keys will block. The caller sehould first clean up the resource
(invalidate the old key) and call 
 <strong>publish_partial,</strong>
which informs
 <strong>rsrc_m</strong>
that the old key is no longer valid. The caller should then
proceed as in case 1.

<P>
</DL>
<DL>
<PP>
In essense, the caller should proceed as follows:
<BLOCKQUOTE><PRE>
    grab the resource
    if not found then
	if not is_new then
	    clean up the resource (optional), e.g.,flush the dirty page
	    call publish_partial() (optional)
	initialize the resource (obligatory), e.g.,read the new page
	call publish() (obligatory)
    ... use the resource ...
    call unpin() to free the resource
</DL>
</PRE></BLOCKQUOTE>

<P>
<strong>find(ret, key, mode, ref_bit, timeout)</strong>
<DL>
<PP>
The
 <strong>find</strong>
method looks up and pins a cached resource identified by
 <em>key.</em>
It returns an the error
 <strong>fcNOTFOUND</strong>
 if the resource is not cached. If the resource is cached, a 
 <em>mode</em>
 latch is acquired on the resource and a pointer to the resource is
returned in 
 <em>ret.</em>
The calling thread should subsequently free the
resource by calling 
 <strong>unpin.</strong>
As in 
 <strong>grab,</strong>
 the calling thread could potentially
block if 
 <em>mode</em>
causes a latch conflict (i.e.,when there is contention to the resource).
The 
 <em>refbit</em>
parameter is a hint
to the
 <strong>rsrc_m</strong>
replacement algorithm; 
 <em>refbit</em>
is directly proportional to the duration that a
resource remained cached. Thus, a zero 
 <em>refbit</em>
implies that the 
 <strong>rsrc_m</strong>
should reuse the resource as soon as needed after it is unpinned.

<P>
</DL>
<strong>pin(rsrc, mode)</strong>
<DL>
<PP>
The
 <strong>pin</strong>
method pins the resource 
 <em>rsrc.</em>
The latch on the resource is acquired in mode
 <em>mode.</em>
The calling thread should subsequently free 
 <em>rsrc</em>
by calling 
 <strong>unpin.</strong>

<P>
</DL>
<strong>publish(rsrc, error_flag)</strong>
<DL>
<PP>
The
 <strong>publish</strong>
method makes the resource 
 <em>rsrc,</em>
that was previously
obtained by a 
 <strong>grab</strong>
call with a cache miss, available.  See the description of
 <strong>grab</strong>
for more details.  The
 <em>error_flag</em>
parameter is informs the
 <strong>rsrc_m</strong>
that the resource has not been successfully initialized, and should
be invalidated.

<P>
</DL>
<strong>publish_partial(rsrc)</strong>
<DL>
<PP>
The
 <strong>publish_partial</strong>
method partially publishes the resource 
 <em>rsrc</em>
that was previously obtained with a call to
 <strong>grab.</strong>
See the description of
 <strong>grab</strong>
for more details.

<P>
</DL>
<strong>unpin(rsrc, refbit)</strong>
<DL>
<PP>
The
 <strong>unpin</strong>
method releases the latch on the resource 
 <em>rsrc.</em>
The 
 <em>refbit</em>
parameter is a hint
to the
 <strong>rsrc_m</strong>
replacement algorithm; 
 <em>refbit</em>
is directly proportional to the duration that a
resource remained cached. Thus, a zero 
 <em>refbit</em>
implies that the 
 <strong>rsrc_m</strong>
should reuse the resource as soon as needed.

</DL>
<H2><A NAME="HRR.2.3">Rsrc_i Interface</A></H2>

The 
 <strong>rsrc_i</strong>
template is used to iterate over all of the resources
in an instance of
 <strong>rsrc_m.</strong>

<P>
<strong>rsrc_m(r, mode, start)</strong>
<DL>
<PP>
The constructor initilizes an iterator for the
 <strong>rsrc_m</strong>
instance indicated by parameter
 <em>r.</em>
Each resource will be pinned (latched) in mode
 <em>mode.</em>
The iterator starts at the 
 <em>start,</em>
element in the array of resources that
 <em>r</em>
manages.
The iterator will only return those resources actually
in the hash table.

<P>
</DL>
<strong>~rsrc_m()</strong>
<DL>
<PP>
The destructor ends the iterator by unpinning and currently
pinned resource.

<P>
</DL>
<strong>next()</strong>
<DL>
<PP>
The
 <strong>next</strong>
method unpins the current resource, advances the iterator to the next
resource, and pins it.
 <strong>Next</strong>
returns a pointer to the resource
after it has advanced.  It will return 0 if there are no more resources.
 <strong>Next</strong>
skips any resources not in the hash table.

<P>
</DL>
<strong>curr()</strong>
<DL>
<PP>
The
 <strong>curr</strong>
method returns a pointer to the currently pinned resource.

<P>
</DL>
<strong>discard_curr()</strong>
<DL>
<PP>
The
 <strong>discard_curr</strong>
method unpins the current resource and removes it from the hash table.

TODO

</DL>
<HR>
<H1><A NAME="HRR.3">VERSION</A></H1>
This manual page applies to Version 1.1.1 of the Shore software.
<HR>
<H1><A NAME="HRR.4">SPONSORSHIP</A></H1>
The Shore project is sponsored by the Advanced Research Project Agency, ARPA
order number 018 (formerly 8230), monitored by the U.S. Army Research
Laboratory under contract DAAB07-91-C-Q518.
<HR>
<H1><A NAME="HRR.5">COPYRIGHT</A></H1>
Copyright &#169; 1994, 1995, 1996, 1997,
Computer Sciences Department, University of
Wisconsin -- Madison. All Rights Reserved.

<HR>
<H1><A NAME="HRR.6">SEE ALSO</A></H1>

<A HREF="latch_t.common.html"><STRONG>latch_t(common)</STRONG></A>,
<A HREF="intro.common.html"><STRONG>intro(common)</STRONG></A>.

</BODY>
</HTML>
