<!-- Warning: Do not edit this file. -->
<!-- It was created automatically by yam2html.pl 1.3  -->
<!-- on Mon Oct 27 09:40:52 CST 1997 from file mancxxlb/index.cxxlb -->
<!DOCTYPE HTML public "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<TITLE>
index(cxxlb) -- Shore Reference Manual
</TITLE>
<LINK REV="made" HREF="mailto:solomon@cs.wisc.edu">
</HEAD>

<BODY>

<!-- .so tmac.man.local -->
<H1><A NAME="HRR.0">
index - SDL index attribute types
</A></H1><HR>
<H1>
CONTENTS
</H1>
<UL>
<LI>
<A HREF="#HRR.1">SYNOPSIS</A>
</LI>
<LI>
<A HREF="#HRR.2">DESCRIPTION</A>
</LI>
<LI>
<A HREF="#HRR.3">ORDERING</A>
</LI>
<LI>
<A HREF="#HRR.4">LANGUAGE BINDING</A>
</LI>
<LI>
<A HREF="#HRR.5">SCANNING AN INDEX</A>
</LI>
<LI>
<A HREF="#HRR.6">RESTRICTIONS</A>
</LI>
<LI>
<A HREF="#HRR.7">BUGS</A>
</LI>
<LI>
<A HREF="#HRR.8">VERSION</A>
</LI>
<LI>
<A HREF="#HRR.9">SPONSORSHIP</A>
</LI>
<LI>
<A HREF="#HRR.10">COPYRIGHT</A>
</LI>
<LI>
<A HREF="#HRR.11">SEE ALSO</A>
</LI></UL><HR>
<H1><A NAME="HRR.1">SYNOPSIS</A></H1>
<BLOCKQUOTE><PRE>
interface index_obj {
public:
    typedef long     keytype; // can be any simple type
    typedef string   valtype; // can be any simple type
                              // including Ref&lt;X&gt; or,
                              // equivalently, X.

    attribute index&lt;keytype,valtype&gt; idx;
    // attribute maps keytype-values to 
    // valtype-values through an index.
};
</PRE></BLOCKQUOTE>
<HR>
<H1><A NAME="HRR.2">DESCRIPTION</A></H1>
<P>
The SDL language and the C++ binding to SDL support indices through
a simple interface to the underlying Shore Storage Manager (SSM)
index facility.
Indices are declared as attributes of SDL interfaces, using
the template-style notation 
<tt>index&lt;keytype,valtype&gt;</tt>
for the type
of the attribute.  
Keys can be simple types or structured data types.
Comparisons on keys are done on byte-by-byte basis,
so it is inadvisable to use structured data types
for keys (see &quot;ORDERING&quot;, below).
In general, it is best to use primitive SDL types
such as 
<em>long, string, char.</em>
<P>
Values have any of the types that keys can have,
with the addition of references (
 <em>Ref&lt;type&gt;</em>).
<P>
Index operations are performed through member-function 
calls on index attributes.
The index facility allows users to insert (key,value) pairs
into an index, to retrieve the set of (key,value) pairs stored in
the index for some range of keys, and to delete specific
(key,value) pairs.
Keys and values within a particular index will each
range over some fixed type; 
typically, the key will be a numeric type
or string, and the value will be a reference to some SDL
object type.
<HR>
<H1><A NAME="HRR.3">ORDERING</A></H1>
<P>
The underlying Shore Storage Manager support for indices 
orders keys based on bitwise binary lexical ordering.
This ordering works well for the primitive integral and floating
point types on the Sparc architecture machines supported by the
Beta release, and for strings.  Care must be taken
if composed types such as 
 <em>structs</em>
are used as keys; the ordering
used may be problematic.  
There is no
way to specify a user-defined ordering.
Similarly, uniqueness of (key,value) pairs is dependent on 
equality of values inserted for equal keys; this comparison
for equality is based on strict bitwise equality. If a structure
is used as a key or value type,  care must be taken that padding
in the structure layout (due to alignment)
does not cause uninitialized data to be stored in the index.
Such  uninitialized data may make it impossible for correct
comparisons to be done.
<HR>
<H1><A NAME="HRR.4">LANGUAGE BINDING</A></H1>
<P>
Indices in SDL are declared as attributes in objects with a declaration
of the form
<BLOCKQUOTE><PRE>
interface a {
public:
    attribute index&lt;keytype,valtype&gt; varname;
};
</PRE></BLOCKQUOTE>
<P>
The 
<tt>index&lt;keytype,valtype&gt;</tt>
declarator may be used in other contexts,
e.g. as an element of structs and arrays,
but not as a member of a union.
<P>
In the C++ language binding, an interface attribute looks like a C++
template class instantiation, with visible fields and member functions 
as listed below.  
<BLOCKQUOTE><PRE>
template &lt;class Key, class Val&gt; 
class Index
{

  public:
    // externally visibly names for the type parameters
    typedef Key KeyType;
    typedef Val ValType;

    // initialize an index and set type of index.
    shrc init(IndexKind kind) const;

    // insert a (key,value) pair
    shrc insert(const Key &amp;key,const Val &amp;elt) const;

    // remove a (key,value) pair
    shrc remove(const Key &amp;key,const Val &amp;elt) const;

    // remove all (key,value) pairs with a given key 
    // the second parameter , nrm, returns the 
    // number of elements removed.
    shrc remove(const Key &amp;key, int &amp;nrm) const;

    // find  a single (key,value) pair with a given key 
    shrc find(Key key, Val &amp; elt,bool &amp;found) const;
};
</PRE></BLOCKQUOTE>
<P>
If an object type (that is, the name of an SDL interface type)
is used as the value type parameter in the declaration
of an index in SDL, the object is always inserted by reference; 
that is, a reference to the object is stored as the value,
not a copy of its contents.
In other words, the declarations
<tt>index&lt;keytype,Person&gt; </tt>
and
<tt>index&lt;keytype,ref&lt;Person&gt; &gt;</tt>
are equivalent, and result in the 
language binding
<tt>Index&lt;keytype, Ref&lt;Person&gt; &gt;.</tt>
<P>
Similarly, since the language binding for the
<tt>string</tt>
type is the class
<tt>sdl_string,</tt>
the declaration
<tt>index&lt;string,Person&gt;</tt>
results in the language binding
<tt>Index&lt;sdl_string,Ref&lt;Person&gt; &gt;.</tt>
<P>
The member functions for index attributes are
all declared 
<tt>const</tt>
because they do not modify the object containing
the attribute; the underlying index is modified, of course, but the
object containing the attribute is not.
<P>
After an object containing an index attribute is created, the index
must be initialized using the 
 <strong>init</strong>
method of the index attribute.
Allowable values for the single parameter to the 
 <strong>init</strong>
member function, which determines the type of SSM index used, are the elements
of the enumeration type IndexKind, shown below.
<BLOCKQUOTE><PRE>
    enum IndexKind { LHash, BTree, UniqueBTree, RTree, RDTree };
</PRE></BLOCKQUOTE>
Once initialized, an index cannot be removed from an object;
the index remains until the object is destroyed, even if
the index contains no entries.
<P>
The following example illustrates the creation of an index
and insertion of values into the index.  
Here, we assume the existence
of an array of persistent pointers (Refs) and we create an index that
will associate each element of the array with its position in the
array. 
In the following examples, a Shore transaction is assumed to
be active, and the macro 
<tt>SH_DO</tt>
is used to handling possible errors with index calls.

See
<A HREF="transaction.oc.html"><STRONG>transaction(oc)</STRONG></A>
for information about the SH_DO macro, transactions, and error handling.
<BLOCKQUOTE><PRE>
// SDL language declaration
module index_vars {
    interface Person {
    public:
        attribute string    name;
        attribute long      age;
    };

    interface  IndexObj {
    public:
        attribute index&lt;string, Person&gt; name_index;
        attribute index&lt;long, Person&gt;     age_index;
    }
}

// Assume an instance of IndexObj has
// been created, and we have a valid
// reference to in w:
//
Ref&lt;IndexObj&gt;   w;
shrc            rc;

// Code fragment to initialize:
rc= w-&gt;name_index.init(UniqueBTree);
rc= w-&gt;age_index.init(BTree);

// Code fragment to insert:
rc = w-&gt;name_index.insert(p-&gt;name, p);
rc = w-&gt;age_index.insert(p-&gt;age, p);

// Code fragment to remove all entries
// when you don't know the value
int num;

rc = w-&gt;name_index.remove(&quot;daffy&quot;, num);

// Code fragment to remove a (key,value) pair
Ref&lt;Person&gt; p;
bool        found=false;

rc = w-&gt;age_index.remove(34, p, found);
</PRE></BLOCKQUOTE>
<P>
If there is only one (key,value) pair in an index for some key,
the value associated with that key may be found using the
 <strong>find</strong>
member function of the index attribute.  
If more than one (key,value)
pair exists for the particular key (the index cannot be
a UniqueBTree in this case), the result is undefined.
<BLOCKQUOTE><PRE>
// Code fragment to find an entry
Ref&lt;Person&gt; p;
bool        found=false;

rc = w-&gt;name_index.find(&quot;donald&quot;, p, found);
if(rc==0 &amp;&amp; found &amp;&amp; p) {
	// go ahead and dereference p
	...
}
</PRE></BLOCKQUOTE>
<P>
Index lookups that require more than one (key,value) pair
to be returned are described below.
<HR>
<H1><A NAME="HRR.5">SCANNING AN INDEX</A></H1>
An
 <em>IndexScanIter</em>
class template is
provided to implement retrieval of the set of (key,value) pairs
associated with some range of keys.
This template implements a simple iteration primitive
that allows the programmer to iterate over the sequence of 
(key,value) pairs that are the result
of a particular index lookup operation.
<BLOCKQUOTE><PRE>

//
// an enumeration defined in ShoreApp.h
//
enum CompareOp { 
    // only the identifiers are given; the 
    // values are not to be implied from this
    // pseudo-declaration:
    eqOp, gtOp, geOp, ltOp, leOp,

    // for boundary comparisons:
    gtNegInf, geNegInf, 
    ltPosInf, lePosInf
};

template &lt;class Key, class Val&gt;
class IndexScanIter
{
public:
    bool     eof;        // scanned the last entry?
    //    copies of key and value of last entry scanned
    Key     &amp;cur_key;
    Val     &amp;cur_val;

    //constructors...
    // ... for an iterator over the entire index--
    IndexScanIter(const Index&lt;Key,Val&gt; idx);

    // ... for an iterator over the part of the index
    //        that lies between l and u, inclusive
    IndexScanIter(const Index&lt;Key,Val&gt; &amp;idx,Key l, Key u) :

    // Alternatively,
    // set upper and lower bounds and conditions
    // before using the iterator:
    //
    SetLB(Key b) ;
    SetUB(Key b) ;
    SetLowerCond(CompareOp o);
    SetUpperCond(CompareOp o);

    // move the cursor -- must be done once 
    // to make the cursor valid.
    shrc next();

    // clean up
    shrc close();

    ~IndexScanIter(); // destroys copies and closes
}
</PRE></BLOCKQUOTE>
The iterator template class contains public &quot;cursor&quot;
data fields that indicate the current (key,value) pair in
the set of such pairs resulting from the lookup
and a 
 <strong>next</strong>
member function, which
is used to move the cursor to the next element of the set.
The class is initialized through parameters to its constructors;
range bounds may also be separately specified by 
 <strong>SetUB</strong>
and 
 <strong>SetLB</strong>
member functions to set the upper and lower bounds of the retrieve
range, respectively.  Note that range queries using upper and lower
bounds are meaningful only for b-tree indices; hash indices do
not support retrieves where the upper and lower bounds differ.
If a lower bound is not set, the index scan will begin at the
least element contained in the index; if an upper bound is not
set, the scan will terminate with the greatest element in the index.
If neither lower or upper bounds are set, the entire index will be
scanned.
The 
 <em>IndexScanIter</em>
class must be used in conjunction with an
index attribute of an SDL object, and the type parameter of the iterator
class must match the type of the index attribute.  
Care must be taken when the index attribute is declared with
a reference, as in
<tt>index&lt;long,Person&gt;.</tt>
The corresponding use of 
 <em>IndexScanIter</em>
is
<tt>IndexScanIter&lt;long,Ref&lt;Person&gt; &gt;</tt>
<strong>and you must be sure to place a space between the two occurrences of '&gt;', lest the C++ compiler parse them as a right-shift token.</strong>
<P>
An implementation of the now-obsolete
<tt>index_iter</tt>
template class
is retained for backward compatibility, but it is not
documented here.
<P>
The following examples illustrate the scanning of 
an index.  The two examples use different idioms for
the scan.
<BLOCKQUOTE><PRE>
shrc									rc;
// scan of entire index
IndexScanIter&lt;long,Ref&lt;Person&gt; &gt;        iter(w-&gt;age_index); 

while( !(rc = iter.next()) &amp;&amp; !iter.eof) {
	p = iter.cur_val;
	if(p) {
		...
	}
}
</PRE></BLOCKQUOTE>
<BLOCKQUOTE><PRE>
shrc									rc;
// scan of part of index-- from beginning through &quot;c&quot;
IndexScanIter&lt;sdl_string,Ref&lt;Person&gt; &gt;        iter(w-&gt;name_index); 
iter.SetLowerCond(geNegInf);
iter.SetUB(&quot;c&quot;);
iter.SetUpperCond(leOp);

for (rc = iter.next(); rc == RCOK &amp;&amp; !iter.eof; rc = iter.next() ) {
	p = iter.cur_val;
	if(p) {
		...
	}
}
<HR>
<H1><A NAME="HRR.6">RESTRICTIONS</A></H1>

The template 
<tt>Index&lt;k, v&gt;</tt>
cannot be instantiated as a transient data structure.
It is only valid when used as an attribute of an Shore object
whose type is defined as an SDL interface.

<HR>
<H1><A NAME="HRR.7">BUGS</A></H1>
Only the two index types
<strong>BTree</strong>
and 
<strong>UniqueBTree</strong>
are supported for applications.

</PRE></BLOCKQUOTE>
<HR>
<H1><A NAME="HRR.8">VERSION</A></H1>
This manual page applies to Version 1.1.1 of the Shore software.
<HR>
<H1><A NAME="HRR.9">SPONSORSHIP</A></H1>
The Shore project is sponsored by the Advanced Research Project Agency, ARPA
order number 018 (formerly 8230), monitored by the U.S. Army Research
Laboratory under contract DAAB07-91-C-Q518.
<HR>
<H1><A NAME="HRR.10">COPYRIGHT</A></H1>
Copyright &#169; 1994, 1995, 1996, 1997,
Computer Sciences Department, University of
Wisconsin -- Madison. All Rights Reserved.
<HR>
<H1><A NAME="HRR.11">SEE ALSO</A></H1>
<A HREF="intro.sdl.html"><STRONG>intro(sdl)</STRONG></A>,
<A HREF="string.cxxlb.html"><STRONG>string(cxxlb)</STRONG></A>,
<A HREF="errors.oc.html"><STRONG>errors(oc)</STRONG></A>,
<A HREF="transaction.oc.html"><STRONG>transaction(oc)</STRONG></A>
and
<A HREF="../sdlman/sdlman.html">Shore Data Language Reference Manual</A>

</BODY>
</HTML>
