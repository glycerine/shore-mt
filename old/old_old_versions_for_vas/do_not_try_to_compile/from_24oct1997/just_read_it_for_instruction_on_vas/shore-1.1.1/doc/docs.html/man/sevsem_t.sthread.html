<!-- Warning: Do not edit this file. -->
<!-- It was created automatically by yam2html.pl 1.3  -->
<!-- on Mon Oct 27 09:41:10 CST 1997 from file mansthread/sevsem_t.sthread -->
<!DOCTYPE HTML public "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<TITLE>
sevsem_t(sthread) -- Shore Reference Manual
</TITLE>
<LINK REV="made" HREF="mailto:solomon@cs.wisc.edu">
</HEAD>

<BODY>

<!-- .so tmac.man.local -->
<H1><A NAME="HRR.0">
sevsem_t - Shore Event Semaphore Class
</A></H1><HR>
<H1>
CONTENTS
</H1>
<UL>
<LI>
<A HREF="#HRR.1">SYNOPSIS</A>
</LI>
<LI>
<A HREF="#HRR.2">DESCRIPTION</A>
</LI>
<LI>
<A HREF="#HRR.3">ERRORS</A>
</LI>
<LI>
<A HREF="#HRR.4">EXAMPLES</A>
</LI>
<LI>
<A HREF="#HRR.5">VERSION</A>
</LI>
<LI>
<A HREF="#HRR.6">SPONSORSHIP</A>
</LI>
<LI>
<A HREF="#HRR.7">COPYRIGHT</A>
</LI>
<LI>
<A HREF="#HRR.8">SEE ALSO</A>
</LI></UL><HR>
<H1><A NAME="HRR.1">SYNOPSIS</A></H1>
<BLOCKQUOTE><PRE>
#include &lt;sthread.h&gt;

/*
 *  Event semaphore
 */
class sevsem_t : public sthread_base_t {
public:
    NORET			sevsem_t(
	int 			    is_post = 0,
	const char* 		    name = 0);
    NORET			~sevsem_t();

    w_rc_t			post();
    w_rc_t			reset(int* pcnt = 0);
    w_rc_t			wait(int4_t timeout = WAIT_FOREVER);
    void 			query(int&amp; pcnt);
    
    void	 		setname(
	const char* 		    n1, 
	const char* 		    n2 = 0);
};

</PRE></BLOCKQUOTE>
<HR>
<H1><A NAME="HRR.2">DESCRIPTION</A></H1>

An event semaphore functions as a counting semaphore in that a thread
can use an event semaphore to trigger execution of other threads. This
is useful if, for example, one thread (producer) provides data to many
other threads (consumer). Using an event semaphore frees the consumers
from the trouble of polling to determine when new data is available.

<P>
<strong>sevsem_t(is_post, name)</strong>
<DL>
<PP>
The constructor creates an event semaphore.  The
 <em>name</em>
parameter is stored in the semaphore for debugging purposes.  If 
 <em>is_post</em>
is 
 <strong>true,</strong>
the event semaphore is set to
posted right after construction. Otherwise, the event semaphore is
reset after construction.

<P>
</DL>
<strong>~sevsem_t()</strong>
<DL>
<PP>

<P>
</DL>
<strong>reset(pcnt)</strong>
<DL>
<PP>
The
 <strong>reset</strong>
method resets the event semaphore (i.e., reset post count to 0),
and returns the number of times the semaphore was posted since it was
last reset in 
 <em>pcnt.</em>
All threads that subsequently wait on this semaphore will be blocked.

<P>
</DL>
<strong>post()</strong>
<DL>
<PP>
The
 <strong>post</strong>
method posts the semaphore and increments the post count. All threads
waiting on this semaphore are unblocked and resume execution. Threads
that wait on the semaphore after the semaphore has been posted and
before the next time it is reset, will not be blocked. If the semaphore
is subsequently reset, threads that calls 
 <strong>wait()</strong>
will again be blocked.
<PP>
If the semaphore is reset when 
 <strong>post</strong>
is called, the semaphore is
posted and the post count is set to 1.  If the semaphore is already
posted when 
 <em>post</em>
is called, the post count is incremented, and an error, 
 <strong>stSEMPOSTED,</strong>
is returned to the calling thread.

<P>
</DL>
<strong>wait(timeout)</strong>
<DL>
<PP>
The
 <strong>wait</strong>
method waits on the event semaphore.  If the semaphore is already
posted, 
 <strong>wait</strong>
returns immediately and the thread continues to run. Otherwise, the
thread is blocked until the semaphore is posted. Note that 
 <strong>wait</strong>
does not decrement the post count; only 
 <strong>reset</strong>
modifies the post count in any way.

<P>
</DL>
<strong>query(pcnt)</strong>
<DL>
<PP>
The
 <strong>query</strong>
method returns, in
 <em>pcnt,</em>
the number of times the semaphore was posted since it was
last reset.


</DL>
<HR>
<H1><A NAME="HRR.3">ERRORS</A></H1>

TODO.

<HR>
<H1><A NAME="HRR.4">EXAMPLES</A></H1>

TODO.

<HR>
<H1><A NAME="HRR.5">VERSION</A></H1>
This manual page applies to Version 1.1.1 of the Shore software.
<HR>
<H1><A NAME="HRR.6">SPONSORSHIP</A></H1>
The Shore project is sponsored by the Advanced Research Project Agency, ARPA
order number 018 (formerly 8230), monitored by the U.S. Army Research
Laboratory under contract DAAB07-91-C-Q518.
<HR>
<H1><A NAME="HRR.7">COPYRIGHT</A></H1>
Copyright &#169; 1994, 1995, 1996, 1997,
Computer Sciences Department, University of
Wisconsin -- Madison. All Rights Reserved.
<HR>
<H1><A NAME="HRR.8">SEE ALSO</A></H1>
<A HREF="errors.sthread.html"><STRONG>errors(sthread)</STRONG></A>,
<A HREF="sthread_t.sthread.html"><STRONG>sthread_t(sthread)</STRONG></A>,
<A HREF="smutex_t.sthread.html"><STRONG>smutex_t(sthread)</STRONG></A>,
<A HREF="scond_t.sthread.html"><STRONG>scond_t(sthread)</STRONG></A>,
<A HREF="file_handlers.sthread.html"><STRONG>file_handlers(sthread)</STRONG></A>,
<A HREF="intro.sthread.html"><STRONG>intro(sthread)</STRONG></A>.

</BODY>
</HTML>
