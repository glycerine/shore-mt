#ifndef SM_STATS_T_MSG_GEN_H
#define SM_STATS_T_MSG_GEN_H

/* DO NOT EDIT --- GENERATED from sm_stats.dat by stats.pl
           on Mon Jan  2 14:58:12 2012

<std-header orig-src='shore' genfile='true'>

SHORE -- Scalable Heterogeneous Object REpository

Copyright (c) 1994-99 Computer Sciences Department, University of
                      Wisconsin -- Madison
All Rights Reserved.

Permission to use, copy, modify and distribute this software and its
documentation is hereby granted, provided that both the copyright
notice and this permission notice appear in all copies of the
software, derivative works or modified versions, and any portions
thereof, and that both notices appear in supporting documentation.

THE AUTHORS AND THE COMPUTER SCIENCES DEPARTMENT OF THE UNIVERSITY
OF WISCONSIN - MADISON ALLOW FREE USE OF THIS SOFTWARE IN ITS
"AS IS" CONDITION, AND THEY DISCLAIM ANY LIABILITY OF ANY KIND
FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.

This software was developed with support by the Advanced Research
Project Agency, ARPA order number 018 (formerly 8230), monitored by
the U.S. Army Research Laboratory under contract DAAB07-91-C-Q518.
Further funding for this work was provided by DARPA through
Rome Research Laboratory Contract No. F30602-97-2-0247.

*/
/*  -- do not edit anything above this line --   </std-header>*/


/* SM_bf_one_page_write  */ "Single page written to volume",
/* SM_bf_two_page_write  */ "Two-page writes to volume",
/* SM_bf_three_page_write */ "Three-page writes to volume",
/* SM_bf_four_page_write */ "Four-page writes to volume",
/* SM_bf_five_page_write */ "Five-page writes to volume",
/* SM_bf_six_page_write  */ "Six-page writes to volume",
/* SM_bf_seven_page_write */ "Seven-page writes to volume",
/* SM_bf_eight_page_write */ "Eight-page writes to volume",
/* SM_bf_more_page_write */ "Over-eight-page writes to volume",
/* SM_bf_cleaner_sweeps  */ "Number of sweeps of the bf_cleaner thread",
/* SM_bf_cleaner_signalled */ "Number of sweeps initiated by a kick",
/* SM_bf_evicted_while_cleaning */ "Page evicted from bp while being cleaned",
/* SM_bf_already_evicted */ "Could not find page to copy for flushing (evicted)",
/* SM_bf_dirty_page_cleaned */ "Found page already cleaned (hot)",
/* SM_bf_flushed_OHD_page */ "Non-cleaner thread had to flush an old-hot-dirty page synchronously",
/* SM_bf_kick_full       */ "Kicks because pool is full of dirty pages",
/* SM_bf_kick_replacement */ "Kicks because doing page replacement",
/* SM_bf_kick_threshold  */ "Kicks because dirty page threshold met",
/* SM_bf_sweep_page_hot_skipped */ "Page swept was not flushed because it was hot ",
/* SM_bf_discarded_hot   */ "Discarded a page from the bp when someone was waiting to latch it",
/* SM_bf_log_flush_all   */ "Number of whole-log flushes by bf_cleaner",
/* SM_bf_log_flush_lsn   */ "Number of partial log flushes by bf_cleaner",
/* SM_bf_write_out       */ "Pages written out in background or forced",
/* SM_bf_sleep_await_clean */ "Times slept awaiting cleaner to clean a page for fix()",
/* SM_bf_fg_scan_cnt     */ "Foreground scans of buffer pool",
/* SM_bf_unfix_cleaned   */ "Unfix-clean cleaned a page that had a rec_lsn",
/* SM_rwlock_r_waits     */ "Number of waits for read lock on srwlock",
/* SM_rwlock_w_waits     */ "Number of waits for write lock on srwlock",
/* SM_need_latch_condl   */ "Conditional latch requests ",
/* SM_latch_condl_nowaits */ "Conditional latch requests immediately granted ",
/* SM_need_latch_uncondl */ "Unconditional latch requests ",
/* SM_latch_uncondl_nowaits */ "Uncondl latch requests immediately granted ",
/* SM_latch_uncondl_waits */ "Uncondl latch requests not immediately granted ",
/* SM_btree_latch_wait   */ "Waited on btree store latch (not in buffer pool)",
/* SM_io_latch_wait      */ "Waited on io store latch (not in buffer pool)",
/* SM_bf_look_cnt        */ "Calls to find/grab",
/* SM_bf_grab_latch_failed */ "Page found but could not acquire latch ",
/* SM_bf_hit_cnt         */ "Found page in buffer pool in find/grab",
/* SM_bf_hit_wait        */ "Found page in buffer pool but awaited latch",
/* SM_bf_hit_wait_any_p  */ "Found page in b pool but awaited latch",
/* SM_bf_hit_wait_btree_p */ "Found page in b pool but awaited latch",
/* SM_bf_hit_wait_file_p */ "Found page in b pool but awaited latch",
/* SM_bf_hit_wait_keyed_p */ "Found page in b pool but awaited latch",
/* SM_bf_hit_wait_lgdata_p */ "Found page in b pool but awaited latch",
/* SM_bf_hit_wait_lgindex_p */ "Found page in b pool but awaited latch",
/* SM_bf_hit_wait_rtree_p */ "Found page in b pool but awaited latch",
/* SM_bf_hit_wait_rtree_base_p */ "Found page in b pool but awaited latch",
/* SM_bf_hit_wait_extlink_p */ "Found page in b pool but awaited latch",
/* SM_bf_hit_wait_stnode_p */ "Found page in b pool but awaited latch",
/* SM_bf_hit_wait_zkeyed_p */ "Found page in b pool but awaited latch",
/* SM_bf_hit_wait_scan   */ "Found any_p page in b pool but awaited latch in scan",
/* SM_bf_replace_out     */ "Pages written out to free a frame for fixing",
/* SM_bf_replaced_dirty  */ "Victim for page replacement is dirty",
/* SM_bf_replaced_clean  */ "Victim for page replacement is clean",
/* SM_bf_replaced_unused */ "Victim for page replacement is unused frame",
/* SM_bf_awaited_cleaner */ "Had to wait for page cleaner to be done with page",
/* SM_bf_no_transit_bucket */ "Wanted in-transit-out bucket was full ",
/* SM_bf_prefetch_requests */ "Requests to prefetch a page ",
/* SM_bf_prefetches      */ "Prefetches performed",
/* SM_bf_upgrade_latch_unconditional */ "Unconditional latch upgrade",
/* SM_bf_upgrade_latch_race */ "Dropped and reqacquired latch to upgrade",
/* SM_bf_upgrade_latch_changed */ "A page changed during a latch upgrade race",
/* SM_restart_repair_rec_lsn */ "Cleared rec_lsn on a page dirtied by unlogged changes",
/* SM_vol_reads          */ "Data volume read requests (from disk)",
/* SM_vol_writes         */ "Data volume write requests (to disk)",
/* SM_vol_blks_written   */ "Data volume pages written (to disk)",
/* SM_vol_alloc_exts     */ "Free extents allocated to stores",
/* SM_vol_free_exts      */ "Extents deallocated from stores",
/* SM_need_vol_lock_r    */ "Times requested vol lock for read",
/* SM_need_vol_lock_w    */ "Times requested vol lock for write",
/* SM_nowait_vol_lock_r  */ "Times vol read lock acquired immediately",
/* SM_nowait_vol_lock_w  */ "Times vol write lock acquired immediately",
/* SM_await_vol_lock_r   */ "Requests not acquired immediately",
/* SM_await_vol_lock_w   */ "Requests not acquired immediately",
/* SM_io_m_lsearch       */ "Times a linear search was started in io manager",
/* SM_io_m_lsearch_extents */ "Extents visited in io manager linear searches",
/* SM_vol_cache_primes   */ "Caches primed",
/* SM_vol_cache_prime_fix */ "Fixes due to cache primes",
/* SM_vol_cache_clears   */ "Caches cleared (dismounts)",
/* SM_vol_last_extent_search */ "Extents inspected to find the last one",
/* SM_vol_last_page_cache_update */ "Last extent inserted into cached",
/* SM_vol_last_page_cache_invalidate */ "Last extent cache cleared",
/* SM_vol_last_page_cache_find */ "Looked for cached last extent/page",
/* SM_vol_last_page_cache_hit */ "Found cached last extent/page",
/* SM_vol_resv_cache_insert */ "Inserted store,ext pair in reserved-pages ache",
/* SM_vol_resv_cache_erase */ "Removed store,ext pair in reserved-pages ache",
/* SM_vol_resv_cache_hit */ "Pages allocated from extents via cache",
/* SM_vol_resv_cache_fail */ "Failed to allocate from an extent found in cache",
/* SM_vol_lock_noalloc   */ "Failed to allocate from an extent due to lock contention",
/* SM_log_dup_sync_cnt   */ "Times the log was flushed superfluously",
/* SM_log_daemon_wait    */ "Times the log daemon waited for a kick",
/* SM_log_daemon_work    */ "Times the log daemon flushed something",
/* SM_log_fsync_cnt      */ "Times the fsync system call was used",
/* SM_log_chkpt_cnt      */ "Checkpoints taken",
/* SM_log_chkpt_wake     */ "Checkpoints requested by kicking the chkpt thread",
/* SM_log_fetches        */ "Log records fetched from log (read)",
/* SM_log_inserts        */ "Log records inserted into log (written)",
/* SM_log_full           */ "A transaction encountered log full",
/* SM_log_full_old_xct   */ "An old transaction had to abort",
/* SM_log_full_old_page  */ "A transaction had to abort due to holding a dirty old page",
/* SM_log_full_wait      */ "A log full was resolved by waiting for space",
/* SM_log_full_force     */ "A log full was resolved by forcing the buffer pool",
/* SM_log_full_giveup    */ "A transaction aborted because neither waiting nor forcing helped",
/* SM_log_file_wrap      */ "Log file numbers wrapped around",
/* SM_log_bytes_generated */ "Bytes of log records inserted ",
/* SM_log_bytes_written  */ "Bytes written to log including skip and padding",
/* SM_log_bytes_rewritten */ "Bytes written minus generated    ",
/* SM_log_bytes_generated_rb */ "Bytes of log records inserted during rollback",
/* SM_log_bytes_rbfwd_ratio */ "Ratio of rollback: forward log bytes inserted",
/* SM_log_flush_wait     */ "Flushes awaited log flush daemon",
/* SM_log_short_flush    */ "Log flushes <= 1 block",
/* SM_log_long_flush     */ "Log flushes > 1 block",
/* SM_lock_deadlock_cnt  */ "Deadlocks detected",
/* SM_lock_false_deadlock_cnt */ "False positive deadlocks",
/* SM_lock_dld_upd_waitmap_cnt */ "Wait map updates for deadlock detection",
/* SM_lock_dld_call_cnt  */ "Deadlock detector total calls",
/* SM_lock_dld_first_call_cnt */ "Deadlock detector first called for one lock",
/* SM_lock_dld_false_victim_cnt */ "Deadlock detector victim not blocked",
/* SM_lock_dld_victim_self_cnt */ "Deadlock detector picked self as victim ",
/* SM_lock_dld_victim_other_cnt */ "Deadlock detector picked other as victim ",
/* SM_lock_dld_retry     */ "Awaited lock release woke up waiting thread",
/* SM_lock_dld_deadlock  */ "Deadlock detection woke up waiting thread",
/* SM_lock_dld_timeout   */ "Timeout woke up waiting thread",
/* SM_nonunique_fingerprints */ "Smthreads created a non-unique fingerprint",
/* SM_unique_fingerprints */ "Smthreads created a unique fingerprint",
/* SM_rec_pin_cnt        */ "Times records were pinned in the buffer pool",
/* SM_rec_unpin_cnt      */ "Times records were unpinned",
/* SM_rec_repin_cvt      */ "Converted latch-lock to lock-lock deadlock",
/* SM_fm_pagecache_hit   */ "Found recently-used page",
/* SM_fm_page_nolatch    */ "Couldn't latch recently-used page ",
/* SM_fm_page_moved      */ "Recently-used page moved to new store",
/* SM_fm_page_invalid    */ "Recently-used page no longer allocated to this store",
/* SM_fm_page_nolock     */ "Recently-used page could not be locked for record alloc",
/* SM_fm_alloc_page_reject */ "Rejected attempt to allocate a page: could not latch",
/* SM_fm_page_full       */ "Recently-used page was full",
/* SM_fm_error_not_handled */ "Unhandled error in latch-lock-get-slot ",
/* SM_fm_ok              */ "Success in latch-lock-get-slot",
/* SM_fm_histogram_hit   */ "Histogram says file search worthwhile",
/* SM_fm_search_pages    */ "Pages inspected in file search",
/* SM_fm_bogus_pbucketmap */ "Pbucketmap was inaccurate ",
/* SM_fm_search_failed   */ "File search unsuccessful",
/* SM_fm_search_hit      */ "File search successful",
/* SM_fm_lastpid_cached  */ "Have last pid cached",
/* SM_fm_lastpid_hit     */ "Found slot on page lastpid ",
/* SM_fm_alloc_pg        */ "Allocated a new page",
/* SM_fm_ext_touch       */ "Updates to extent info",
/* SM_fm_ext_touch_nop   */ "No-op updates to extent info",
/* SM_fm_nospace         */ "Could not create rec",
/* SM_fm_cache           */ "Policy permitted looking in cache (number of probes)",
/* SM_fm_compact         */ "Policy permitted searching file",
/* SM_fm_append          */ "Policy permitted appending to file",
/* SM_fm_appendonly      */ "Policy required strict append",
/* SM_bt_find_cnt        */ "Btree lookups (find_assoc())",
/* SM_bt_insert_cnt      */ "Btree inserts (create_assoc())",
/* SM_bt_remove_cnt      */ "Btree removes (destroy_assoc())",
/* SM_bt_traverse_cnt    */ "Btree traversals",
/* SM_bt_partial_traverse_cnt */ "Btree traversals starting below root",
/* SM_bt_restart_traverse_cnt */ "Restarted traversals",
/* SM_bt_posc            */ "POSCs established",
/* SM_bt_scan_cnt        */ "Btree scans started",
/* SM_bt_splits          */ "Btree pages split (interior and leaf)",
/* SM_bt_cuts            */ "Btree pages removed (interior and leaf)",
/* SM_bt_grows           */ "Btree grew a level",
/* SM_bt_shrinks         */ "Btree shrunk a level",
/* SM_bt_links           */ "Btree links followed",
/* SM_bt_upgrade_fail_retry */ "Failure to upgrade a latch forced a retry",
/* SM_bt_clr_smo_traverse */ "Cleared SMO bits on traverse",
/* SM_bt_pcompress       */ "Prefixes compressed",
/* SM_bt_plmax           */ "Maximum prefix levels encountered",
/* SM_sort_keycmp_cnt    */ "Key-comparison callbacks",
/* SM_sort_lexindx_cnt   */ "Lexify index key callbacks",
/* SM_sort_getinfo_cnt   */ "Create-sort-key callbacks",
/* SM_sort_mof_cnt       */ "Marshal-object callbacks",
/* SM_sort_umof_cnt      */ "Unmarshal-object callbacks",
/* SM_sort_memcpy_cnt    */ "Memcpys",
/* SM_sort_memcpy_bytes  */ "Bytes copied in memcpy",
/* SM_sort_keycpy_cnt    */ "Keycopies (part of memcpy_cnt)",
/* SM_sort_mallocs       */ "Allocations",
/* SM_sort_malloc_bytes  */ "Bytes allocated total",
/* SM_sort_malloc_hiwat  */ "Max allocated at any one time",
/* SM_sort_malloc_max    */ "Largest chunk allocated",
/* SM_sort_malloc_curr   */ "Amt presently allocated",
/* SM_sort_tmpfile_cnt   */ "Records written to temp files",
/* SM_sort_tmpfile_bytes */ "Bytes written to temp files",
/* SM_sort_duplicates    */ "Duplicate records eliminated",
/* SM_sort_page_fixes    */ "Orig slotted pages fixed by sort for read",
/* SM_sort_page_fixes_2  */ "Tmp file slotted pages fixed by sort for read",
/* SM_sort_lg_page_fixes */ "Large obj pages explicitly fixed by sort",
/* SM_sort_rec_pins      */ "Recs explicitly pinned by sort",
/* SM_sort_files_created */ "Files created by sort",
/* SM_sort_recs_created  */ "Final records created by sort",
/* SM_sort_rec_bytes     */ "Bytes in final records",
/* SM_sort_runs          */ "Runs merged",
/* SM_sort_run_size      */ "Pages of input recs per run",
/* SM_sort_phases        */ "Polyphase phases",
/* SM_sort_ntapes        */ "Number of pseudo-tapes used by sort",
/* SM_any_p_fix_cnt      */ "Fix method called for unknown type",
/* SM_btree_p_fix_cnt    */ "Btree_p fix method called",
/* SM_file_p_fix_cnt     */ "File_p fix method called",
/* SM_keyed_p_fix_cnt    */ "Keyed_p fix method called",
/* SM_lgdata_p_fix_cnt   */ "Lgdata_p fix method called",
/* SM_lgindex_p_fix_cnt  */ "Lgindex_p fix method called",
/* SM_rtree_p_fix_cnt    */ "Rtree_p fix method called",
/* SM_rtree_base_p_fix_cnt */ "Rtree_base_p fix method called",
/* SM_extlink_p_fix_cnt  */ "Extlink_p fix method called",
/* SM_stnode_p_fix_cnt   */ "Stnode_p fix method called",
/* SM_zkeyed_p_fix_cnt   */ "Zkeyed_p_fix_method_called",
/* SM_page_fix_cnt       */ "Times page_p::_fix was called (even if page already fixed)",
/* SM_bf_fix_cnt         */ "Times bp fix called  (conditional or unconditional)",
/* SM_bf_refix_cnt       */ "Times pages were refixedn in bp (cheaper than fix)",
/* SM_bf_unfix_cnt       */ "Times pages were unfixed in bp",
/* SM_vol_check_owner_fix */ "Fixes to check page allocation-to-store status",
/* SM_page_alloc_cnt     */ "Pages allocated",
/* SM_page_dealloc_cnt   */ "Pages deallocated",
/* SM_ext_lookup_hits    */ "Hits in extent lookups in cache ",
/* SM_ext_lookup_misses  */ "Misses in extent lookups in cache ",
/* SM_alloc_page_in_ext  */ "Requests to allocate a page in a given extent",
/* SM_vol_free_page      */ "Extents fixed to free a page ",
/* SM_vol_next_page      */ "Next-page requests (might fix more than one ext map page)",
/* SM_vol_next_page_with_space */ "Next-page-with-space requests ",
/* SM_vol_find_free_exts */ "Free extents requested",
/* SM_xct_log_flush      */ "Log flushes by xct for commit/prepare",
/* SM_begin_xct_cnt      */ "Transactions started",
/* SM_commit_xct_cnt     */ "Transactions committed",
/* SM_abort_xct_cnt      */ "Transactions aborted",
/* SM_log_warn_abort_cnt */ "Transactions aborted due to log space warning",
/* SM_prepare_xct_cnt    */ "Transactions prepared",
/* SM_rollback_savept_cnt */ "Rollbacks to savepoints (not incl aborts)",
/* SM_internal_rollback_cnt */ "Internal partial rollbacks ",
/* SM_s_prepared         */ "Externally coordinated prepares",
/* SM_sdesc_cache_hit    */ "Times sdesc_cache hit on cached indexes",
/* SM_sdesc_cache_search */ "Times sdesc_cache was searched",
/* SM_sdesc_cache_search_cnt */ "Entries searched",
/* SM_sdesc_cache_miss   */ "Times sdesc_cache missed altogether",
/* SM_mpl_attach_cnt     */ "Times a thread was not the only one attaching to a transaction",
/* SM_anchors            */ "Log Anchors grabbed",
/* SM_compensate_in_log  */ "Compensations written in log buffer",
/* SM_compensate_in_xct  */ "Compensations written in xct log buffer",
/* SM_compensate_records */ "Compensations written as own log record ",
/* SM_compensate_skipped */ "Compensations would be a no-op",
/* SM_log_switches       */ "Times log turned off",
/* SM_get_logbuf         */ "Times acquired log buf for xct",
/* SM_await_1thread_xct  */ "Times blocked on 1thread mutex for xct (mcs_lock only)",
/* SM_lock_query_cnt     */ "High-level query for lock information",
/* SM_unlock_request_cnt */ "High-level unlock requests",
/* SM_lock_request_cnt   */ "High-level lock requests",
/* SM_lock_acquire_cnt   */ "Acquires to satisfy high-level requests",
/* SM_lock_head_t_cnt    */ "Locks heads put in table for chains of requests",
/* SM_lock_await_alt_cnt */ "Transaction had a waiting thread in the lock manager and had to wait on alternate resource",
/* SM_lock_extraneous_req_cnt */ "Extraneous requests (already granted)",
/* SM_lock_conversion_cnt */ "Requests requiring conversion",
/* SM_lock_cache_hit_cnt */ "Hits on lock cache (avoid acquires)",
/* SM_lock_request_t_cnt */ "Lock request structures chained off lock heads",
/* SM_lock_esc_to_page   */ "Number of escalations to page level",
/* SM_lock_esc_to_store  */ "Number of escalations to store level",
/* SM_lock_esc_to_volume */ "Number of escalations to volume level",
/* SM_lk_vol_acq         */ "Volume locks acquired",
/* SM_lk_store_acq       */ "Store locks acquired",
/* SM_lk_page_acq        */ "Page locks acquired",
/* SM_lk_kvl_acq         */ "Key-value locks acquired",
/* SM_lk_rec_acq         */ "Record locks acquired",
/* SM_lk_ext_acq         */ "Extent locks acquired",
/* SM_lk_user1_acq       */ "User1 locks acquired",
/* SM_lk_user2_acq       */ "User2 locks acquired",
/* SM_lk_user3_acq       */ "User3 locks acquired",
/* SM_lk_user4_acq       */ "User4 locks acquired",
/* SM_lock_wait_cnt      */ "Lock acquires that waited in smthread_block",
/* SM_lock_block_cnt     */ "Times lock acquire called smthread_block",
/* SM_lk_vol_wait        */ "Volume locks waited",
/* SM_lk_store_wait      */ "Store locks waited",
/* SM_lk_page_wait       */ "Page locks waited",
/* SM_lk_kvl_wait        */ "Key-value locks waited",
/* SM_lk_rec_wait        */ "Record locks waited",
/* SM_lk_ext_wait        */ "Extent locks waited",
/* SM_lk_user1_wait      */ "User1 locks waited",
/* SM_lk_user2_wait      */ "User2 locks waited",
/* SM_lk_user3_wait      */ "User3 locks waited",
/* SM_lk_user4_wait      */ "User4 locks waited",

#endif /* SM_STATS_T_MSG_GEN_H */
